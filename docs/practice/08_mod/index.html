<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go Modules # Golang 在 1.11 推出了 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，解决了 GOPATH 的问题，相当于弃用了 GOPATH。
Go Module 机制 # Go Module 不同于基于 GOPATH 和 Vendor 的项目构建，其主要是通过 $GOPATH/pkg/mod 下缓存的模块来对项目进行构建。 同一个模块版本的数据只缓存一份，所有其他模块共享使用。
可以使用 go clean -modcache 清理所有已缓存的模块版本数据。
GO111MODULE # Go Module 目前是可选的，可以通过环境变量 GO111MODULE 来控制是否启用，GO111MODULE 有三种类型:
on 所有的构建，都使用 Module 机制 off 所有的构建，都不使用 Module 机制，而是使用 GOPATH 和 Vendor auto 在 GOPATH 下的项目，不使用 Module 机制，不在 GOPATH 下的项目使用 GOPROXY # GOPROXY 用于设置 Go Module 代理。使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它的值是一个以 , 分割的 Go module proxy 列表。Golang 1."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Go Modules"><meta property="og:description" content="Go Modules # Golang 在 1.11 推出了 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，解决了 GOPATH 的问题，相当于弃用了 GOPATH。
Go Module 机制 # Go Module 不同于基于 GOPATH 和 Vendor 的项目构建，其主要是通过 $GOPATH/pkg/mod 下缓存的模块来对项目进行构建。 同一个模块版本的数据只缓存一份，所有其他模块共享使用。
可以使用 go clean -modcache 清理所有已缓存的模块版本数据。
GO111MODULE # Go Module 目前是可选的，可以通过环境变量 GO111MODULE 来控制是否启用，GO111MODULE 有三种类型:
on 所有的构建，都使用 Module 机制 off 所有的构建，都不使用 Module 机制，而是使用 GOPATH 和 Vendor auto 在 GOPATH 下的项目，不使用 Module 机制，不在 GOPATH 下的项目使用 GOPROXY # GOPROXY 用于设置 Go Module 代理。使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它的值是一个以 , 分割的 Go module proxy 列表。Golang 1."><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/practice/08_mod/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-11T15:38:35+08:00"><title>Go Modules | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.b61ba6d90760fd8612220baf974a489819ffb4f242eaac5d0fddce0aa273deaf.js integrity="sha256-thum2Qdg/YYSIguvl0pImBn/tPJC6qxdD93OCqJz3q8=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/ class=active>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li><li><a href=/golang-learn/docs/advance/04_netpooler/>网络轮询器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go Modules</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#go-modules>Go Modules</a><ul><li><a href=#go-module-机制>Go Module 机制</a></li><li><a href=#go111module>GO111MODULE</a></li><li><a href=#goproxy>GOPROXY</a></li><li><a href=#gomod>go.mod</a><ul><li><a href=#replace-使用>replace 使用</a></li></ul></li><li><a href=#gosum>go.sum</a></li><li><a href=#go-checksum-database>Go Checksum Database</a></li><li><a href=#gosumdb>GOSUMDB</a></li><li><a href=#go-mod-命令>go mod 命令</a></li><li><a href=#关于私有-module>关于私有 module</a></li><li><a href=#迁移项目到-go-module>迁移项目到 Go Module</a><ul><li><a href=#准备环境>准备环境</a></li><li><a href=#迁移>迁移</a></li></ul></li><li><a href=#迁移到-vendor>迁移到 vendor</a></li><li><a href=#添加新依赖包>添加新依赖包</a></li><li><a href=#依赖包冲突问题>依赖包冲突问题</a></li><li><a href=#go-getinstall-代理问题>Go get/install 代理问题</a></li><li><a href=#管理-go-的环境变量>管理 Go 的环境变量</a></li><li><a href=#控制包的版本>控制包的版本</a><ul><li><a href=#为什么-go-get-拉取的是-v000>为什么 go get 拉取的是 v0.0.0</a></li><li><a href=#发布-tags-的多种模式>发布 tags 的多种模式</a></li></ul></li><li><a href=#发布-module>发布 module</a><ul><li><a href=#语义化版本>语义化版本</a></li><li><a href=#gosum-1>go.sum</a></li></ul></li><li><a href=#todo>Todo</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=go-modules>Go Modules
<a class=anchor href=#go-modules>#</a></h1><p>Golang 在 1.11 推出了 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，解决了 <code>GOPATH</code> 的问题，相当于弃用了 <code>GOPATH</code>。</p><h2 id=go-module-机制>Go Module 机制
<a class=anchor href=#go-module-%e6%9c%ba%e5%88%b6>#</a></h2><p>Go Module 不同于基于 <code>GOPATH</code> 和 Vendor 的项目构建，其主要是通过 <code>$GOPATH/pkg/mod</code> 下缓存的模块来对项目进行构建。
<strong>同一个模块版本的数据只缓存一份，所有其他模块共享使用</strong>。</p><p>可以使用 <code>go clean -modcache</code> 清理所有已缓存的模块版本数据。</p><h2 id=go111module>GO111MODULE
<a class=anchor href=#go111module>#</a></h2><p>Go Module 目前是可选的，可以通过环境变量 <code>GO111MODULE</code> 来控制是否启用，<code>GO111MODULE</code> 有三种类型:</p><ul><li><code>on</code> 所有的构建，都使用 Module 机制</li><li><code>off</code> 所有的构建，都不使用 Module 机制，而是使用 <code>GOPATH</code> 和 Vendor</li><li><code>auto</code> 在 <code>GOPATH</code> 下的项目，不使用 Module 机制，不在 <code>GOPATH</code> 下的项目使用</li></ul><h2 id=goproxy>GOPROXY
<a class=anchor href=#goproxy>#</a></h2><p><code>GOPROXY</code> 用于设置 Go Module 代理。使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它的值是一个以 <code>,</code>
分割的 Go module proxy 列表。Golang 1.13 以后它有一个默认的值 <code>GOPROXY=https://proxy.golang.org,direct</code>，
但是 <code>proxy.golang.org</code> 在中国是无法访问的，可以执行 <code>go env -w GOPROXY=https://goproxy.cn,direct</code> 来替换这个值。</p><ul><li><code>off</code>，当 <code>GOPROXY=off</code> 时禁止 Go 在后续操作中使用 Go module proxy。</li><li><code>direct</code>，值列表中的 <code>direct</code> 用于指示 Go 回源到模块版本的源地址去抓取(如 GitHub)。当值列表中上一个 Go module proxy 返
回 404 或 410 错误时，Go 自动尝试列表中的下一个 proxy，当遇见 <code>direct</code> 时回源源地址，遇见 EOF 时终止并抛
出 “invalid version: unknown revision&mldr;” 的错误。</li></ul><h2 id=gomod>go.mod
<a class=anchor href=#gomod>#</a></h2><p><code>go.mod</code> 是 Go moduels 项目所必须的最重要的文件，描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头，目前有 5 个动词:</p><ul><li><code>module</code>：定义当前项目的模块路径。</li><li><code>go</code>：设置预期的 Go 版本。</li><li><code>require</code>：设置特定的模块版本。</li><li><code>exclude</code>：从使用中排除一个特定的模块版本。</li><li><code>replace</code>：将一个模块版本替换为另外一个模块版本。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>module</span> <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>foobar</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#ae81ff>1.13</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>require</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>apple</span> <span style=color:#a6e22e>v0</span><span style=color:#ae81ff>.1.2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>banana</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.2.3</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>banana</span><span style=color:#f92672>/</span><span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v2</span><span style=color:#ae81ff>.3.4</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>pineapple</span> <span style=color:#a6e22e>v0</span><span style=color:#ae81ff>.0.0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>20190924185754</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#a6e22e>b0db40df49a</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>exclude</span> <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>banana</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.2.4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>replace</span> <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>apple</span> <span style=color:#a6e22e>v0</span><span style=color:#ae81ff>.1.2</span> =&gt; <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>rda</span> <span style=color:#a6e22e>v0</span><span style=color:#ae81ff>.1.0</span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>replace</span> <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>banana</span> =&gt; <span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>hugebanana</span>
</span></span></code></pre></div><h3 id=replace-使用>replace 使用
<a class=anchor href=#replace-%e4%bd%bf%e7%94%a8>#</a></h3><p>如果找不到 proxy,那么可以用 <code>replace</code>.用文本编辑器打开 <code>go.mod</code>,加入如下内容:</p><pre tabindex=0><code>// Fix unable to access &#39;https://go.googlesource.com/xxx/&#39;: The requested URL returned error: 502
replace (
	golang.org/x/crypto =&gt; github.com/golang/crypto latest
	golang.org/x/lint =&gt; github.com/golang/lint latest
	golang.org/x/net =&gt; github.com/golang/net latest
	golang.org/x/oauth2 =&gt; github.com/golang/oauth2 latest
	golang.org/x/sync =&gt; github.com/golang/sync latest
	golang.org/x/sys =&gt; github.com/golang/sys latest
	golang.org/x/text =&gt; github.com/golang/text latest
	golang.org/x/time =&gt; github.com/golang/time latest
	golang.org/x/tools =&gt; github.com/golang/tools latest
)
</code></pre><p><code>go mod tidy</code> 命令会把 <code>latest</code> 自动替换成最新的版本号：</p><pre tabindex=0><code>replace (
	golang.org/x/crypto =&gt; github.com/golang/crypto v0.0.0-20191206172530-e9b2fee46413
	golang.org/x/lint =&gt; github.com/golang/lint v0.0.0-20191125180803-fdd1cda4f05f
	golang.org/x/net =&gt; github.com/golang/net v0.0.0-20191207000613-e7e4b65ae663
	golang.org/x/oauth2 =&gt; github.com/golang/oauth2 v0.0.0-20191202225959-858c2ad4c8b6
	golang.org/x/sync =&gt; github.com/golang/sync v0.0.0-20190911185100-cd5d95a43a6e
	golang.org/x/sys =&gt; github.com/golang/sys v0.0.0-20191206220618-eeba5f6aabab
	golang.org/x/text =&gt; github.com/golang/text v0.3.2
	golang.org/x/time =&gt; github.com/golang/time v0.0.0-20191024005414-555d28b269f0
	golang.org/x/tools =&gt; github.com/golang/tools v0.0.0-20191206204035-259af5ff87bd
)
</code></pre><p>如果是老项目，可能会出现类似错误：</p><pre tabindex=0><code>go: golang.org/x/net@v0.0.0-20190628185345-da137c7871d7: 
git fetch -f origin refs/heads/*:refs/heads/* refs/tags/*:refs/tags/* 
in /go/pkg/mod/cache/vcs/4a22365141bc4eea5d5ac4a1395e653f2669485db75ef119e7bbec8e19b12a21: exit status 128:
	fatal: unable to access &#39;https://go.googlesource.com/net/&#39;: The requested URL returned error: 502
</code></pre><p>原因就是提示 net 包除了最新版之外,还需要其它的版本 <code>v0.0.0-20190628185345-da137c7871d7</code>，需要修改 <code>go.mod</code>:</p><pre tabindex=0><code>golang.org/x/net v0.0.0-20190628185345-da137c7871d7 =&gt; github.com/golang/net v0.0.0-20191207000613-e7e4b65ae663
</code></pre><h2 id=gosum>go.sum
<a class=anchor href=#gosum>#</a></h2><p><code>go.sum</code> 类似于 dep 的 <code>Gopkg.lock</code>。列出了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今
后的操作中保证项目所依赖的那些模块版本不会被篡改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>k8s</span>.<span style=color:#a6e22e>io</span><span style=color:#f92672>/</span><span style=color:#a6e22e>client</span><span style=color:#f92672>-</span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>v0</span><span style=color:#ae81ff>.0.0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>20190620085101</span><span style=color:#f92672>-</span><span style=color:#ae81ff>78</span><span style=color:#a6e22e>d2af792bab</span> <span style=color:#a6e22e>h1</span>:<span style=color:#a6e22e>E8Fecph0qbNsAbijJJQryKu4Oi9QTp5cVpjTE</span><span style=color:#f92672>+</span><span style=color:#a6e22e>nqg6g</span>=
</span></span><span style=display:flex><span><span style=color:#a6e22e>k8s</span>.<span style=color:#a6e22e>io</span><span style=color:#f92672>/</span><span style=color:#a6e22e>client</span><span style=color:#f92672>-</span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>v0</span><span style=color:#ae81ff>.0.0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>20190620085101</span><span style=color:#f92672>-</span><span style=color:#ae81ff>78</span><span style=color:#a6e22e>d2af792bab</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span>.<span style=color:#a6e22e>mod</span> <span style=color:#a6e22e>h1</span>:<span style=color:#a6e22e>E95RaSlHr79aHaX0aGSwcPNfygDiPKOVXdmivCIZT0k</span>=
</span></span></code></pre></div><p>上面示例中一个模块路径有两种，前者为 Go module 打包整个模块包文件 zip 后再进行 hash 值，而后者为针对 <code>go.mod</code> 的 hash 值。
他们两者，要不就是同时存在，要不就是只存在 <code>go.mod</code> hash。</p><p>当 Go 认为肯定用不到某个模块版本的时候就会省略它的 zip hash，就会出现不存在 zip hash，只存在 <code>go.mod</code> hash 的情况。</p><h2 id=go-checksum-database>Go Checksum Database
<a class=anchor href=#go-checksum-database>#</a></h2><p>Go Checksum Database 用于保护 Go 从任何源拉到 Go 模块版本不会被篡改。详细可以查看 <code>go help module-auth</code>。</p><h2 id=gosumdb>GOSUMDB
<a class=anchor href=#gosumdb>#</a></h2><p><code>GOSUMDB</code> 是一个 Go checksum database 的值。当它等于 <code>off</code> 时表示禁止 Go 在后续操作中校验模块版本。</p><ul><li>默认值 <code>sum.golang.org</code> 中国无法访问，可以将 <code>GOPROXY</code> 设置为 <code>goproxy.cn</code>。<code>goproxy.cn</code> 支持代理 <code>sum.golang.org</code>。</li></ul><h2 id=go-mod-命令>go mod 命令
<a class=anchor href=#go-mod-%e5%91%bd%e4%bb%a4>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Go mod provides access to operations on modules.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Note that support <span style=color:#66d9ef>for</span> modules is built into all the go commands,
</span></span><span style=display:flex><span>not just <span style=color:#e6db74>&#39;go mod&#39;</span>. For example, day-to-day adding, removing, upgrading,
</span></span><span style=display:flex><span>and downgrading of dependencies should be <span style=color:#66d9ef>done</span> using <span style=color:#e6db74>&#39;go get&#39;</span>.
</span></span><span style=display:flex><span>See <span style=color:#e6db74>&#39;go help modules&#39;</span> <span style=color:#66d9ef>for</span> an overview of module functionality.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        go mod &lt;command&gt; <span style=color:#f92672>[</span>arguments<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The commands are:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        download    下载 go.mod 文件中指明的所有依赖到本地缓存
</span></span><span style=display:flex><span>        edit        编辑 go.mod 文件
</span></span><span style=display:flex><span>        graph       查看现有的依赖结构
</span></span><span style=display:flex><span>        init        在当前目录生成 go.mod 文件
</span></span><span style=display:flex><span>        tidy        添加依赖的模块，并移除无用的模块
</span></span><span style=display:flex><span>        vendor      导出现有的所有依赖
</span></span><span style=display:flex><span>        verify      校验一个模块是否被篡改过
</span></span><span style=display:flex><span>        why         解释为什么需要一个模块
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Use <span style=color:#e6db74>&#34;go help mod &lt;command&gt;&#34;</span> <span style=color:#66d9ef>for</span> more information about a command.
</span></span></code></pre></div><h2 id=关于私有-module>关于私有 module
<a class=anchor href=#%e5%85%b3%e4%ba%8e%e7%a7%81%e6%9c%89-module>#</a></h2><p>如果项目依赖了私有模块，<code>GOPROXY</code> 访问不到，可以使用 <code>GOPRIVATE</code>。</p><p>比如 <code>GOPRIVATE=*.corp.example.com</code> 表示所有模块路径以 <code>corp.example.com</code> 的下一级域名 (如 <code>team1.corp.example.com</code>) 为前缀的
模块版本都将不经过 Go module proxy 和 Go checksum database （<strong>注意不包括 <code>corp.example.com</code> 本身</strong>）。</p><p><code>GOPRIVATE</code> 较为特殊，它的值将作为 <code>GONOPROXY</code> 和 <code>GONOSUMDB</code> 的默认值。所以只使用 <code>GOPRIVATE</code> 就足够。</p><h2 id=迁移项目到-go-module>迁移项目到 Go Module
<a class=anchor href=#%e8%bf%81%e7%a7%bb%e9%a1%b9%e7%9b%ae%e5%88%b0-go-module>#</a></h2><h3 id=准备环境>准备环境
<a class=anchor href=#%e5%87%86%e5%a4%87%e7%8e%af%e5%a2%83>#</a></h3><ol><li>开启 <code>GO11MODULE</code>：<code>go env -w GO111MODULE=on</code>，<strong>确保项目目录不在 <code>GOPATH</code> 中</strong>。</li><li>配置代理 <code>export GOPROXY=https://goproxy.cn,direct</code>。</li></ol><h3 id=迁移>迁移
<a class=anchor href=#%e8%bf%81%e7%a7%bb>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># clone 项目, 不要在 `GOPATH` 中, 之前的项目的结构是 `GOPATH/src/cdf-mannager`</span>
</span></span><span style=display:flex><span>git clone https://github.com/xxx/cdf-mannager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除 vender</span>
</span></span><span style=display:flex><span>cd cdf-mannager
</span></span><span style=display:flex><span>rm -rf vender
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># init</span>
</span></span><span style=display:flex><span>go mod init cdf-mannager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 下载依赖 也可以不执行这一步， go run 或 go build 会自动下载</span>
</span></span><span style=display:flex><span>go mod download
</span></span></code></pre></div><p>Go 会把 <code>Gopkg.lock</code> 或者 <code>glide.lock</code> 中的依赖项写入到 <code>go.mod</code> 文件中。<code>go.mod</code> 文件的内容像下面这样：</p><pre tabindex=0><code>module cdf-manager

require (
        github.com/fsnotify/fsnotify v1.4.7
        github.com/gin-contrib/sse v0.0.0-20170109093832-22d885f9ecc7
        github.com/gin-gonic/gin v0.0.0-20180814085852-b869fe1415e4
        github.com/golang/protobuf v0.0.0-20170601230230-5a0f697c9ed9
        github.com/hashicorp/hcl v1.0.0
        github.com/inconshreveable/mousetrap v0.0.0-20141017200713-76626ae9c91c
        github.com/json-iterator/go v0.0.0-20170829155851-36b14963da70
        github.com/lexkong/log v0.0.0-20180607165131-972f9cd951fc
        github.com/magiconair/properties v1.8.0
        github.com/mattn/go-isatty v0.0.0-20170307163044-57fdcb988a5c
        github.com/mitchellh/mapstructure v1.1.2
        github.com/pelletier/go-toml v1.2.0
        github.com/satori/go.uuid v0.0.0-20180103152354-f58768cc1a7a
        github.com/spf13/afero v1.1.2
        github.com/spf13/cast v1.3.0
        github.com/spf13/cobra v0.0.0-20180427134550-ef82de70bb3f
        github.com/spf13/jwalterweatherman v1.0.0
        github.com/spf13/pflag v1.0.3
        github.com/spf13/viper v0.0.0-20181207100336-6d33b5a963d9
        github.com/ugorji/go v1.1.2-0.20180831062425-e253f1f20942
        github.com/willf/pad v0.0.0-20160331131008-b3d780601022
        golang.org/x/sys v0.0.0-20190116161447-11f53e031339
        golang.org/x/text v0.3.0
        gopkg.in/go-playground/validator.v8 v8.0.0-20160718134125-5f57d2222ad7
        gopkg.in/yaml.v2 v2.2.2
)
</code></pre><p><strong>如果是一个新项目，或者删除了 <code>Gopkg.lock</code> 文件，可以直接运行：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go mod init cdf-mannager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 拉取必须模块 移除不用的模块</span>
</span></span><span style=display:flex><span>go mod tidy
</span></span></code></pre></div><p>接下来就可以运行 <code>go run main.go</code> 了。</p><h2 id=迁移到-vendor>迁移到 vendor
<a class=anchor href=#%e8%bf%81%e7%a7%bb%e5%88%b0-vendor>#</a></h2><p>如果不想使用 go mod 的缓存方式，可以使用 <code>go mod vendor</code> 回到使用的 vendor 目录进行包管理的方式。</p><p>这个命令并只是单纯地把 <code>go.sum</code> 中的所有依赖下载到 vendor 目录里。</p><p>再使用 <code>go build -mod=vendor</code> 来构建项目，因为在 go modules 模式下 <code>go build</code> 是屏蔽 vendor 机制的:</p><p>发布时需要带上 vendor 目录。</p><h2 id=添加新依赖包>添加新依赖包
<a class=anchor href=#%e6%b7%bb%e5%8a%a0%e6%96%b0%e4%be%9d%e8%b5%96%e5%8c%85>#</a></h2><p>添加新依赖包有下面几种方式：</p><ol><li>直接修改 <code>go.mod</code> 文件，然后执行 <code>go mod download</code>。</li><li>使用 <code>go get packagename@vx.x.x</code>，会自动更新 <code>go.mod</code> 文件的。</li><li><code>go run</code>、<code>go build</code> 也会自动下载依赖。</li></ol><p><code>go get</code> 拉取新的依赖：</p><h2 id=依赖包冲突问题>依赖包冲突问题
<a class=anchor href=#%e4%be%9d%e8%b5%96%e5%8c%85%e5%86%b2%e7%aa%81%e9%97%ae%e9%a2%98>#</a></h2><p>迁移后遇到了下面的报错：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>../gowork/pkg/mod/github.com/gin-gonic/gin@v0.0.0-20180814085852-b869fe1415e4/binding/msgpack.go:12:2: unknown import path <span style=color:#e6db74>&#34;github.com/ugorji/go/codec&#34;</span>: ambiguous import: found github.com/ugorji/go/codec in multiple modules:
</span></span><span style=display:flex><span>	github.com/ugorji/go v0.0.0-20170215201144-c88ee250d022 <span style=color:#f92672>(</span>/root/gowork/pkg/mod/github.com/ugorji/go@v0.0.0-20170215201144-c88ee250d022/codec<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>	github.com/ugorji/go/codec v0.0.0-20181204163529-d75b2dcb6bc8 <span style=color:#f92672>(</span>/root/gowork/pkg/mod/github.com/ugorji/go/codec@v0.0.0-20181204163529-d75b2dcb6bc8<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>通过 <code>go mod graph</code> 可以查看具体依赖路径：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>github.com/spf13/viper@v1.3.2 github.com/ugorji/go/codec@v0.0.0-20181204163529-d75b2dcb6bc8
</span></span><span style=display:flex><span>github.com/gin-gonic/gin@v1.3.1-0.20190120102704-f38a3fe65f10 github.com/ugorji/go@v1.1.1
</span></span></code></pre></div><p>可以看到 <code>viper</code> 和 <code>gin</code> 分别依赖了 <code>github.com/ugorji/go</code> 和 <code>github.com/ugorji/go/codec</code>。</p><p>应该是 <code>go</code> 把这两个 <code>path</code> 当成不同的模块引入导致的冲突。<a href=https://github.com/ugorji/go/issues/279>workaround</a>。</p><h2 id=go-getinstall-代理问题>Go get/install 代理问题
<a class=anchor href=#go-getinstall-%e4%bb%a3%e7%90%86%e9%97%ae%e9%a2%98>#</a></h2><p>设置代理之后，go 程序会使用指定的代理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># windows</span>
</span></span><span style=display:flex><span>set http_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>set https_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># linux</span>
</span></span><span style=display:flex><span>export http_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>export https_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span></code></pre></div><p>注意如果你要拉去的依赖是使用 Git 作为源控制管理器，那么 Git 的 proxy 也需要配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git config --global http.proxy http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>git config --global https.proxy http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span></code></pre></div><h2 id=管理-go-的环境变量>管理 Go 的环境变量
<a class=anchor href=#%e7%ae%a1%e7%90%86-go-%e7%9a%84%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f>#</a></h2><ul><li>Golang 1.13 新增了 <code>go env -w</code> 用于写入环境变量，写入到 <code>$HOME/.config/go/env</code> （<code>os.UserConfigDir</code> 返回的路径）文件中。</li><li><code>go env -w</code> 不会覆盖系统环境变量。</li><li>建议删除 Go 相关的系统环境变量，使用 <code>go env -w</code> 配置。</li></ul><h2 id=控制包的版本>控制包的版本
<a class=anchor href=#%e6%8e%a7%e5%88%b6%e5%8c%85%e7%9a%84%e7%89%88%e6%9c%ac>#</a></h2><p><code>go get</code> 进行包管理时：</p><ul><li>拉取最新的版本(优先择取 tag)：<code>go get golang.org/x/text@latest</code></li><li>拉取 master 分支的最新 commit：<code>go get golang.org/x/text@master</code></li><li>拉取 tag 为 <code>v0.3.2</code> 的 commit：<code>go get golang.org/x/text@v0.3.2</code></li><li>拉取 hash 为 342b231 的 commit，最终会被转换为 <code>v0.3.2</code>：<code>go get golang.org/x/text@342b2e</code>。因为 Go modules 会与 tag 进
行对比，若发现对应的 commit 与 tag 有关联，则进行转换。</li><li>用 <code>go get -u</code> 更新现有的依赖，<code>go get -u all</code> 更新所有模块。</li></ul><h3 id=为什么-go-get-拉取的是-v000>为什么 go get 拉取的是 v0.0.0
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88-go-get-%e6%8b%89%e5%8f%96%e7%9a%84%e6%98%af-v000>#</a></h3><p>为什么 go get 拉取的是 v0.0.0，它什么时候会拉取正常带版本号的 tags 呢。实际上这需要区分两种情况，如下：</p><ul><li>所拉取的模块有发布 tags<ul><li>如果只有单个模块，那么就取主版本号最大的那个 tag。</li><li>如果有多个模块，则推算相应的模块路径，取主版本号最大的那个 tag（子模块的 tag 的模块路径会有前缀要求）</li></ul></li><li>所拉取的模块没有发布过 tags<ul><li>默认取主分支最新一次 commit 的 commithash。<code>github.com/ugorji/go/codec@v0.0.0-20181204163529-d75b2dcb6bc8</code>
是因为 <code>github.com/ugorji/go/codec</code> 没有发布任何的 tag。因此它默认取的是主分支最新一次 commit 的 commit 时间和 commithash，
也就是 <code>20181204163529-d75b2dcb6bc8</code>。</li></ul></li></ul><h3 id=发布-tags-的多种模式>发布 tags 的多种模式
<a class=anchor href=#%e5%8f%91%e5%b8%83-tags-%e7%9a%84%e5%a4%9a%e7%a7%8d%e6%a8%a1%e5%bc%8f>#</a></h3><p>例如一个项目中，一共打了两个 tag，分别是：<code>v0.0.1</code> 和 <code>module/codec/v0.0.1</code>，<code>module/codec/v0.0.1</code> 这种 tag，有什么用？</p><p>其实是 Go modules 在同一个项目下多个模块的 tag 表现方式，其主要目录结构为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>demomodules
</span></span><span style=display:flex><span>├── go.mod
</span></span><span style=display:flex><span>├── module
</span></span><span style=display:flex><span>│   └── codec
</span></span><span style=display:flex><span>│       ├── go.mod
</span></span><span style=display:flex><span>│       └── codec.go
</span></span><span style=display:flex><span>└── demomodules.go
</span></span></code></pre></div><p>demomodules 这个项目的根目录有一个 go.mod 文件，而在 module/codec 目录下也有一个 go.mod 文件，其模块导入和版本信息的对应关系如下：</p><table><thead><tr><th>tag</th><th>模块导入路径</th><th>含义</th></tr></thead><tbody><tr><td>v0.0.1</td><td>github.com/pooky/demomodules</td><td>demomodules 项目的 v 0.0.1 版本</td></tr><tr><td>module/codec/v0.01</td><td>github.com/pooky/demomodules/module/codec</td><td>demomodules 项目下的子模块 module/codec 的 v0.0.1 版本</td></tr></tbody></table><p>拉取子模块，执行如下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go get github.com/pooky/demomodules/module/codec@v0.0.1
</span></span></code></pre></div><h2 id=发布-module>发布 module
<a class=anchor href=#%e5%8f%91%e5%b8%83-module>#</a></h2><h3 id=语义化版本>语义化版本
<a class=anchor href=#%e8%af%ad%e4%b9%89%e5%8c%96%e7%89%88%e6%9c%ac>#</a></h3><p>Golang 官方推荐的最佳实践叫做 semver（Semantic Versioning），也就是语义化版本。</p><p>就是一种清晰可读的，明确反应版本信息的版本格式。</p><pre tabindex=0><code>版本格式：主版本号.次版本号.修订号
</code></pre><ul><li>主版本号：做了不兼容的 API 修改</li><li>次版本号：向下兼容的新增功能</li><li>修订号： 向下兼容的问题修正。</li></ul><p>形如 <code>vX.Y.Z</code>。</p><h4 id=语义化版本的问题>语义化版本的问题
<a class=anchor href=#%e8%af%ad%e4%b9%89%e5%8c%96%e7%89%88%e6%9c%ac%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h4><p>如果你使用和发布的包没有版本 tag 或者处于 1.x 版本，那么可能体会不到什么区别，主要的区别体现在 <code>v2.x</code> 以及更高版本的包上。</p><p>go module 的谦容性规则：<strong>如果旧软件包和新软件包具有相同的导入路径，则新软件包必须向后兼容旧软件包</strong>
也就是说如果导入路径不同，就无需保持兼容。</p><p>实际上 Go modules 在主版本号为 v0 和 v1 的情况下省略了版本号，而在主版本号为 v2 及以上则需要明确指定出主版本号，否则会出现冲突，其 tag 与模块导入路径的大致对应关系如下：</p><table><thead><tr><th>tag</th><th>模块导入路径</th></tr></thead><tbody><tr><td>v0.0.0</td><td>github.com/pooky/demomodules</td></tr><tr><td>v1.0.0</td><td>github.com/pooky/demomodules</td></tr><tr><td>v2.0.0</td><td>github.com/pooky/demomodules/v2</td></tr></tbody></table><p><code>v2.x</code> 表示发生了重大变化，无法保证向后兼容，这时就需要在包的导入路径的末尾附加版本信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>module</span> <span style=color:#a6e22e>my</span><span style=color:#f92672>-</span><span style=color:#a6e22e>module</span><span style=color:#f92672>/</span><span style=color:#a6e22e>v2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>require</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>some</span><span style=color:#f92672>/</span><span style=color:#a6e22e>pkg</span><span style=color:#f92672>/</span><span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v2</span><span style=color:#ae81ff>.0.0</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>some</span><span style=color:#f92672>/</span><span style=color:#a6e22e>pkg</span><span style=color:#f92672>/</span><span style=color:#a6e22e>v2</span><span style=color:#f92672>/</span><span style=color:#a6e22e>mod1</span> <span style=color:#a6e22e>v2</span><span style=color:#ae81ff>.0.0</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>my</span><span style=color:#f92672>/</span><span style=color:#a6e22e>pkg</span><span style=color:#f92672>/</span><span style=color:#a6e22e>v3</span> <span style=color:#a6e22e>v3</span><span style=color:#ae81ff>.0.1</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>格式总结为 <code>pkgpath/vN</code>，其中 N 是大于 1 的主要版本号。代码里导入时也需要附带上这个版本信息，如 <code>import "some/my-module/v2"</code>。</p><h4 id=为什么忽略-v0-和-v1-的主版本号>为什么忽略 v0 和 v1 的主版本号
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bf%bd%e7%95%a5-v0-%e5%92%8c-v1-%e7%9a%84%e4%b8%bb%e7%89%88%e6%9c%ac%e5%8f%b7>#</a></h4><p>忽略 v1 版本的原因：考虑到许多开发人员创建一旦到达 v1 版本便永不改变的软件包，这是官方所鼓励的
忽略了 v0 版本的原因：根据语义化版本规范，v0 的这些版本完全没有兼容性保证。需要一个显式的 v0 版本的标识对确保兼容性没有多大帮助。</p><h3 id=gosum-1>go.sum
<a class=anchor href=#gosum-1>#</a></h3><p>npm 的 <code>package-lock.json</code> 会记录所有库的准确版本，来源以及校验和，发布时不需要带上它，因为内容过于详细会对版本控制以及变更记录
等带来负面影响。</p><p><code>go.sum</code> 也有类似的作用，会记录当前 module 所有的顶层和间接依赖，以及这些依赖的校验和，从而提供一个可以 100% 复现的构建过程并对构建对
象提供安全性的保证。同时还会保留过去使用的包的版本信息，以便日后可能的版本回退，这一点也与普通的锁文件不同。</p><p>准确地说，<code>go.sum</code> 是一个构建状态跟踪文件。</p><p>所以应该把 <strong><code>go.sum</code> 和 <code>go.mod</code> 一同添加进版本控制工具的跟踪列表，同时需要随着你的模块一起发布</strong>。</p><h2 id=todo>Todo
<a class=anchor href=#todo>#</a></h2><p><code>go get</code> 和 <code>go install</code> 的区别</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/dedeb749b420ef5a794bb6cd78a203c768c176c7 title='Last modified by shipengqi | October 11, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 11, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/practice/08_mod.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#go-modules>Go Modules</a><ul><li><a href=#go-module-机制>Go Module 机制</a></li><li><a href=#go111module>GO111MODULE</a></li><li><a href=#goproxy>GOPROXY</a></li><li><a href=#gomod>go.mod</a><ul><li><a href=#replace-使用>replace 使用</a></li></ul></li><li><a href=#gosum>go.sum</a></li><li><a href=#go-checksum-database>Go Checksum Database</a></li><li><a href=#gosumdb>GOSUMDB</a></li><li><a href=#go-mod-命令>go mod 命令</a></li><li><a href=#关于私有-module>关于私有 module</a></li><li><a href=#迁移项目到-go-module>迁移项目到 Go Module</a><ul><li><a href=#准备环境>准备环境</a></li><li><a href=#迁移>迁移</a></li></ul></li><li><a href=#迁移到-vendor>迁移到 vendor</a></li><li><a href=#添加新依赖包>添加新依赖包</a></li><li><a href=#依赖包冲突问题>依赖包冲突问题</a></li><li><a href=#go-getinstall-代理问题>Go get/install 代理问题</a></li><li><a href=#管理-go-的环境变量>管理 Go 的环境变量</a></li><li><a href=#控制包的版本>控制包的版本</a><ul><li><a href=#为什么-go-get-拉取的是-v000>为什么 go get 拉取的是 v0.0.0</a></li><li><a href=#发布-tags-的多种模式>发布 tags 的多种模式</a></li></ul></li><li><a href=#发布-module>发布 module</a><ul><li><a href=#语义化版本>语义化版本</a></li><li><a href=#gosum-1>go.sum</a></li></ul></li><li><a href=#todo>Todo</a></li></ul></li></ul></nav></div></aside></main></body></html>