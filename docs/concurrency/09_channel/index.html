<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Channel # Don’t communicate by sharing memory; share memory by communicating. 不要通过共享内存来通信，通过通信来共享内存。 这是 Go 语言最重要的编程理念。goroutine 通过 channel 向另一个 goroutine 发送消息，channel 和 goroutine 结合，可以实现用通信代替共享内存的 CSP （Communicating Sequential Process）模型。
使用 # 创建 channel：
// 无缓冲 channel ch := make(chan int) // 带缓冲 channel，缓冲区为 3 ch = make(chan int, 3) channel 的零值是 nil。
无缓冲 channel # 无缓冲 channel 也叫做同步 channel：
一个 goroutine 基于一个无缓冲 channel 发送数据，那么就会阻塞，直到另一个 goroutine 在相同的 channel 上执行接收操作。 一个 goroutine 基于一个无缓冲 channel 先执行了接收操作，也会阻塞，直到另一个 goroutine 在相同的 channel 上执行发送操作 带缓冲 channel # 带缓冲的 channel 有一个缓冲区："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Channel"><meta property="og:description" content="Channel # Don’t communicate by sharing memory; share memory by communicating. 不要通过共享内存来通信，通过通信来共享内存。 这是 Go 语言最重要的编程理念。goroutine 通过 channel 向另一个 goroutine 发送消息，channel 和 goroutine 结合，可以实现用通信代替共享内存的 CSP （Communicating Sequential Process）模型。
使用 # 创建 channel：
// 无缓冲 channel ch := make(chan int) // 带缓冲 channel，缓冲区为 3 ch = make(chan int, 3) channel 的零值是 nil。
无缓冲 channel # 无缓冲 channel 也叫做同步 channel：
一个 goroutine 基于一个无缓冲 channel 发送数据，那么就会阻塞，直到另一个 goroutine 在相同的 channel 上执行接收操作。 一个 goroutine 基于一个无缓冲 channel 先执行了接收操作，也会阻塞，直到另一个 goroutine 在相同的 channel 上执行发送操作 带缓冲 channel # 带缓冲的 channel 有一个缓冲区："><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-03T10:03:13+08:00"><title>Channel | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.85ac43de481b0867c3ed54a5a2263e836d58519eeddb4df16af262f7ed157d12.js integrity="sha256-haxD3kgbCGfD7VSloiY+g21YUZ7t203xavJi9+0VfRI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础数据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/ class=active>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li><li><a href=/golang-learn/docs/concurrency/12_errorgroup/>ErrGroup</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go Core Dump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li></ul></li><li><span>🛠️ Go 工程实践</span><ul><li><a href=/golang-learn/docs/project/01_specs/>项目规范</a></li><li><a href=/golang-learn/docs/project/02_structure/>项目的目录结构</a></li><li><a href=/golang-learn/docs/project/03_code/>代码规范</a></li><li><a href=/golang-learn/docs/project/04_commitizen/>Commit 规范</a></li><li><a href=/golang-learn/docs/project/05_version/>版本规范</a></li><li><a href=/golang-learn/docs/project/06_api_doc/>API 文档</a></li><li><a href=/golang-learn/docs/project/07_flow/>Git 工作流程</a></li><li><a href=/golang-learn/docs/project/08_make/>项目管理</a></li><li><a href=/golang-learn/docs/project/09_actions/>GitHub Actions</a></li><li><a href=/golang-learn/docs/project/10_dependabot/>GitHub Dependabot</a></li><li><a href=/golang-learn/docs/project/11_templates/>GitHub 模板</a></li><li><a href=/golang-learn/docs/project/12_goreleaser/>GoReleaser</a></li></ul></li><li><a href=/golang-learn/docs/advance/>🔍 底层原理</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Channel</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#channel>Channel</a><ul><li><a href=#使用>使用</a><ul><li><a href=#无缓冲-channel>无缓冲 channel</a></li><li><a href=#带缓冲-channel>带缓冲 channel</a></li><li><a href=#关闭-channel>关闭 channel</a></li><li><a href=#单向-channel>单向 channel</a></li><li><a href=#cap-和-len>cap 和 len</a></li><li><a href=#使用-range-遍历-channel>使用 range 遍历 channel</a></li><li><a href=#使用-channel-实现互斥锁>使用 channel 实现互斥锁</a></li></ul></li><li><a href=#原理>原理</a><ul><li><a href=#创建-channel>创建 channel</a></li><li><a href=#向-channel-发送数据>向 channel 发送数据</a></li><li><a href=#从-channel-接收数据>从 channel 接收数据</a></li><li><a href=#关闭-channel-1>关闭 channel</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=channel>Channel
<a class=anchor href=#channel>#</a></h1><pre tabindex=0><code>Don’t communicate by sharing memory; share memory by communicating.
不要通过共享内存来通信，通过通信来共享内存。
</code></pre><p>这是 Go 语言最重要的编程理念。goroutine 通过 channel 向另一个 goroutine 发送消息，channel 和 goroutine 结合，可以实现用通信代替共享内存的 CSP （Communicating Sequential Process）模型。</p><h2 id=使用>使用
<a class=anchor href=#%e4%bd%bf%e7%94%a8>#</a></h2><p>创建 channel：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 无缓冲 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 带缓冲 channel，缓冲区为 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ch</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><blockquote><p>channel 的零值是 <code>nil</code>。</p></blockquote><h3 id=无缓冲-channel>无缓冲 channel
<a class=anchor href=#%e6%97%a0%e7%bc%93%e5%86%b2-channel>#</a></h3><p>无缓冲 channel 也叫做同步 channel：</p><ul><li>一个 goroutine 基于一个无缓冲 channel 发送数据，那么就会阻塞，直到另一个 goroutine 在相同的 channel 上执行接收操作。</li><li>一个 goroutine 基于一个无缓冲 channel 先执行了接收操作，也会阻塞，直到另一个 goroutine 在相同的 channel 上执行发送操作</li></ul><h3 id=带缓冲-channel>带缓冲 channel
<a class=anchor href=#%e5%b8%a6%e7%bc%93%e5%86%b2-channel>#</a></h3><p>带缓冲的 channel 有一个缓冲区：</p><ul><li>若缓冲区未满则不会阻塞，发送者可以不断的发送数据。当缓冲区满了后，发送者就会阻塞。</li><li>当缓冲区为空时，接受者就会阻塞，直至有新的数据</li></ul><h3 id=关闭-channel>关闭 channel
<a class=anchor href=#%e5%85%b3%e9%97%ad-channel>#</a></h3><p>使用 <code>close</code> 函数关闭 channel：</p><ul><li>channel 关闭后不能再发送数据</li><li>channel 关闭后可以接收已经发送成功的数据。</li><li>channel 关闭后如果 channel 中没有数据，那么接收者会收到一个 channel 元素的零值。</li></ul><p><code>close</code> 表示这个 channel 不会再继续发送数据，所以要<strong>在发送者所在的 goroutine 去关闭 channel</strong>。</p><blockquote><p>关闭一个 <code>nil</code> 的 channel 会导致 panic。<br>重复关闭 channel 会导致 panic。<br>向已关闭的 channel 发送值会导致 panic。<br></p></blockquote><h3 id=单向-channel>单向 channel
<a class=anchor href=#%e5%8d%95%e5%90%91-channel>#</a></h3><p>当一个 channel 作为一个函数参数时，它一般总是被专门用于<strong>只发送或者只接收</strong>。</p><ul><li><code>chan&lt;- int</code> 表示一个只发送 <code>int</code> 的 channel。</li><li><code>&lt;-chan int</code> 表示一个只接收 <code>int</code> 的 channel。</li></ul><h3 id=cap-和-len>cap 和 len
<a class=anchor href=#cap-%e5%92%8c-len>#</a></h3><ul><li><code>cap</code> 函数可以获取 channel 内部缓冲区的容量。</li><li><code>len</code> 函数可以获取 channel 内部缓冲区有效元素的个数。</li></ul><h3 id=使用-range-遍历-channel>使用 range 遍历 channel
<a class=anchor href=#%e4%bd%bf%e7%94%a8-range-%e9%81%8d%e5%8e%86-channel>#</a></h3><p>使用 <code>range</code> 循环可以遍历 channel，它依次从 channel 中接收数据，当 channel 被关闭并且没有值可接收时跳出循环：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 关闭 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果不关闭 channel，range 就会阻塞当前 goroutine, 直到 channel 关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>close(<span style=color:#a6e22e>ch</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ch</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>) 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用-channel-实现互斥锁>使用 channel 实现互斥锁
<a class=anchor href=#%e4%bd%bf%e7%94%a8-channel-%e5%ae%9e%e7%8e%b0%e4%ba%92%e6%96%a5%e9%94%81>#</a></h3><p>我们可以使用容量只有 <code>1</code> 的 channel 来保证最多只有一个 goroutine 在同一时刻访问一个共享变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sema</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#ae81ff>1</span>) <span style=color:#75715e>// a binary semaphore guarding balance 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>balance</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Deposit</span>(<span style=color:#a6e22e>amount</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sema</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{} <span style=color:#75715e>// acquire lock 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>balance</span> = <span style=color:#a6e22e>balance</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>amount</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>sema</span> <span style=color:#75715e>// release lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Balance</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sema</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{} <span style=color:#75715e>// acquire lock 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>balance</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>sema</span> <span style=color:#75715e>// release lock 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// return b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=原理>原理
<a class=anchor href=#%e5%8e%9f%e7%90%86>#</a></h2><p>channel 本质上就是一个有锁的环形队列，channel 的结构体 <code>hchan</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// total data in the queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// size of the circular queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// points to an array of dataqsiz elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span> <span style=color:#75715e>// element type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// send index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// receive index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of recv waiters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of send waiters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// lock protects all fields in hchan, as well as several
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// fields in sudogs blocked on this channel.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Do not change another G&#39;s status while holding this lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (in particular, do not ready a G), as this can deadlock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// with stack shrinking.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>qcount</code>：channel 中的元素个数</li><li><code>dataqsiz</code>：channel 中的循环队列的长度</li><li><code>buf</code>：channel 的缓冲区数据指针，指向底层的循环数组，只针对有缓冲的 channel。</li><li><code>elemsize</code>：channel 中元素大小</li><li><code>elemtype</code>：channel 中元素类型</li><li><code>closed</code>：channel 是否被关闭的标志位</li><li><code>sendx</code>：表示当前可以发送的元素在底层循环数组中位置索引</li><li><code>recvx</code>：表示当前可以发送的元素在底层循环数组中位置索引</li><li><code>sendq</code>：向 channel 发送数据而被阻塞的 goroutine 队列</li><li><code>recvq</code>：读取 channel 的数据而被阻塞的 goroutine 队列</li><li><code>lock</code>：保护 <code>hchan</code> 中所有字段</li></ul><p><code>waitq</code> 是一个双向链表，链表中所有的元素都是 <code>sudog</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>waitq</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>first</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>last</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sudog</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 指向当前的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 指向下一个 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 指向上一个 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 指向元素数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=创建-channel>创建 channel
<a class=anchor href=#%e5%88%9b%e5%bb%ba-channel>#</a></h3><p>创建 channel 要使用 <code>make</code>，编译器会将 <code>make</code> 转换成 <code>makechan</code> 或者 <code>makechan64</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/chan.go#L72
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>chantype</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Elem</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// compiler checks this but be safe.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>mem</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 无缓冲 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 调用 mallocgc 方法分配一段连续的内存空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>PtrBytes</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// channel 存储的元素类型不是指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 分配一块连续的内存给 hchan 和底层数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>mem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>c</span>), <span style=color:#a6e22e>hchanSize</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 默认情况下，进行两次内存分配操作，分别为 hchan 和缓冲区分配内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = new(<span style=color:#a6e22e>hchan</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置元素大小，元素类型，循环数组的长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemsize</span> = uint16(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Size_</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span> = <span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> = uint(<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lockInit</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankHchan</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 mallocgc 函数创建 channel，就意味着 channel 都是分配在堆上的。所以<strong>当一个 channel 没有被任何 goroutine 引用时，是会被 GC 回收的</strong>。</p><h3 id=向-channel-发送数据>向 channel 发送数据
<a class=anchor href=#%e5%90%91-channel-%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae>#</a></h3><p>发送操作，也就是 <code>ch &lt;- i</code> 语句，编译器最终会将该语句转换成 <code>chansend</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// block 为 true 时，表示当前操作是阻塞的 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 不可以阻塞，直接返回 false，表示未发送成功
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 挂起当前 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanSendNilChan</span>, <span style=color:#a6e22e>traceBlockForever</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>full</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 执行发送数据的逻辑之前，先为当前 channel 加锁，防止多个线程并发修改数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 如果 channel 已经关闭，那么向该 channel 发送数据会导致 panic：send on closed channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 解锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 当前接收队列里存在 goroutine，通过 runtime.send 直接将数据发送给阻塞的接收者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 走到这里，说明没有等待数据的接收者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 对于有缓冲的 channel，并且还有缓冲空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &lt; <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算出下一个可以存储数据的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 将发送的数据拷贝到缓冲区中并增加 sendx 索引和 qcount 计数器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// sendx 索引 +1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 由于 buf 是一个循环数组，所以当 sendx 等于 dataqsiz 时会重新回到数组开始的位置。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 走到这里，说明缓冲空间已满，或者是无缓冲 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 如果不可以阻塞，直接返回 false，表示未发送成功
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 缓冲空间已满或者是无缓冲 channel，发送方会被阻塞
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取当前发送数据的 goroutine 的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 构造一个 sudog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置这一次阻塞发送的相关信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span> <span style=color:#75715e>// 待发送数据的内存地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span> <span style=color:#75715e>// 当前发送数据的 goroutine 的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span> <span style=color:#75715e>// 是否在 select 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span> <span style=color:#75715e>// 发送的 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将 sudog 放入到发送等待队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 挂起当前 goroutine，等待唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanSend</span>, <span style=color:#a6e22e>traceBlockChanSend</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>KeepAlive</span>(<span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// goroutine 开始被唤醒了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>closed</span> <span style=color:#f92672>:=</span> !<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 移除 mysg 上绑定的 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>closed</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;chansend: spurious wakeup&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 被唤醒了，但是 channel 已经关闭了，panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 返回 true 表示已经成功向 channel 发送了数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>send</code> 发送数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// sg 是接收者的 sudog 结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// sg.elem 指向接收到的值存放的位置，如 val &lt;- ch，指的就是 &amp;val
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 直接拷贝内存到 val &lt;- ch 表达式中变量 val 所在的内存地址（&amp;val）上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取 sudog 上绑定的等待接收的 goroutine 的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unlockf</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 唤醒等待接收的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>skip</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><code>goready</code> 是将 goroutine 的状态改成 <code>runnable</code>，然后需要等待调度器的调度。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>src</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// src 是当前 goroutine 发送的数据的内存地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// dst 是接收者的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dst</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 写屏障
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>typeBitsBulkBarrier</span>(<span style=color:#a6e22e>t</span>, uintptr(<span style=color:#a6e22e>dst</span>), uintptr(<span style=color:#a6e22e>src</span>), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 拷贝内存数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>src</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=从-channel-接收数据>从 channel 接收数据
<a class=anchor href=#%e4%bb%8e-channel-%e6%8e%a5%e6%94%b6%e6%95%b0%e6%8d%ae>#</a></h3><p>Go 中可以使用两种不同的方式去接收 channel 中的数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch</span>
</span></span></code></pre></div><p>编译器的处理后分别会转换成 <code>chanrecv1</code>，<code>chanrecv2</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv1</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv2</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>received</span> = <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>两个方法最终还是调用了 <code>chanrecv</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/chan.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>selected</span>, <span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// channel 是 nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 不可以阻塞，直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 挂起当前 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanReceiveNilChan</span>, <span style=color:#a6e22e>traceBlockForever</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>empty</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>empty</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>raceacquire</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 执行接收数据的逻辑之前，先为当前 channel 加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// channel 已关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 底层的循环数组 buf 中没有元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>raceacquire</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// typedmemclr 根据类型清理相应地址的内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// channel 未关闭，并且等待发送队列里存在 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 发送的 goroutine 被阻塞，那有两种情况：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 1. 这是一个非缓冲型的 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 2. 缓冲型的 channel，但是 buf 满了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// recv 直接进行内存拷贝
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>recv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// channel 未关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 缓冲型 channel 并且 buf 里有元素，可以正常接收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 直接从循环数组里取出要接收的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 这里表示，代码中没有忽略要接收的值，不是 &#34;&lt;- ch&#34;，而是 &#34;val &lt;- ch&#34;，ep 指向 val
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 拷贝数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#a6e22e>qp</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 清理掉循环数组里相应位置的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// recvx 索引 +1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 元素个数 -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 非阻塞接收，释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// selected 返回 false，因为没有接收到值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 走到这里说明 buf 是空的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 没有数据可接收，阻塞当前接收的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取当前接收的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 构造一个 sudog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置这一次阻塞接收的相关信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span> <span style=color:#75715e>// 待接收数据的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span> <span style=color:#75715e>// 当前接收的 goroutine 指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span> <span style=color:#75715e>// 是否在 select 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span> <span style=color:#75715e>// 接收的 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将 sudog 放入到接收等待队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 挂起当前接收 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanReceive</span>, <span style=color:#a6e22e>traceBlockChanRecv</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 被唤醒了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>success</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>success</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>recv</code> 接收数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>recv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 无缓冲的 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>racesync</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里表示，代码中没有忽略要接收的值，不是 &#34;&lt;- ch&#34;，而是 &#34;val &lt;- ch&#34;，ep 指向 val
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 直接拷贝数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>recvDirect</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 缓冲型的 channel，但是 buf 已满
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 将底层的循环数组 buf 队首的元素拷贝到接收数据的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 将发送者的数据放入 buf
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#a6e22e>qp</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 将发送者数据拷贝到 buf
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 增加 recvx 索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>unlockf</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 唤醒发送的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>skip</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=关闭-channel-1>关闭 channel
<a class=anchor href=#%e5%85%b3%e9%97%ad-channel-1>#</a></h3><p><code>close</code> 关闭 channel 会被编译器转换成 <code>closechan</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/chan.go#L357
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>closechan</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 关闭一个 nil 的 channel，panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of nil channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 先加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 重复关闭，panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 设置 channel 关闭的标志位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>glist</span> <span style=color:#a6e22e>gList</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 channel 等待接收队列的里 sudog 释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 从接收队列里取出一个 sudog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>()
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 接收队列空了，跳出循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 获取接收 goroutine 的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 放入链表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将 channel 等待发送队列的里 sudog 释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果存在，这些 goroutine 将会 panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 可以查看 chansend 函数中的逻辑：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 对于发送者，如果被唤醒后 channel 已关闭，则会 panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从发送队列里取出一个 sudog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 发送队列空了，跳出循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取发送 goroutine 的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 放入链表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 遍历链表，唤醒所有 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>empty</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>pop</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>schedlink</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>recvq</code> 和 <code>sendq</code> 中的所有 goroutine 被唤醒后，会分别去执行 <code>chanrecv</code> 和 <code>chansend</code> 中 <code>gopark</code> 后面的代码。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/c3f5fc9206b580b4993549de65beb4210f2967a9 title='Last modified by PengQi Shi | November 3, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 3, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/concurrency/09_channel.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#channel>Channel</a><ul><li><a href=#使用>使用</a><ul><li><a href=#无缓冲-channel>无缓冲 channel</a></li><li><a href=#带缓冲-channel>带缓冲 channel</a></li><li><a href=#关闭-channel>关闭 channel</a></li><li><a href=#单向-channel>单向 channel</a></li><li><a href=#cap-和-len>cap 和 len</a></li><li><a href=#使用-range-遍历-channel>使用 range 遍历 channel</a></li><li><a href=#使用-channel-实现互斥锁>使用 channel 实现互斥锁</a></li></ul></li><li><a href=#原理>原理</a><ul><li><a href=#创建-channel>创建 channel</a></li><li><a href=#向-channel-发送数据>向 channel 发送数据</a></li><li><a href=#从-channel-接收数据>从 channel 接收数据</a></li><li><a href=#关闭-channel-1>关闭 channel</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>