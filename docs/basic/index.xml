<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🍚 语言基础 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/docs/basic/</link><description>Recent content in 🍚 语言基础 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/docs/basic/index.xml" rel="self" type="application/rss+xml"/><item><title>基础据类型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</guid><description>数值类型 # 整型 # uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数 # float32 和 float64 的算术规范由 IEEE-754 浮点数国际标准定义。</description></item><item><title>数组</title><link>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</guid><description> 数组 # 数组是一个由固定长度，相同类型的元素组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，并且可以利用索引快速访问数组中的元素。
初始化 # arr1 := [3]int{1, 2, 3} arr2 := [...]int{1, 2, 3} // `...` 省略号，表示数组的长度是根据初始化值的个数来计算 数组的长度在编译阶段确定，初始化之后大小就无法改变。
数组是否应该在堆栈中初始化在编译期就确定了。
根据数组大小：
当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上。 当元素数量大于 4 个时，会将数组中的元素放置到静态区，并在运行时取出。</description></item><item><title>切片</title><link>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</guid><description>切片 # 切片 (slice) 在使用上和数组差不多，区别是切片是可变长的，定义的时候不需要指定 size。
切片可以看做是对数组的一层简单的封装，切片的底层数据结构中，包含了一个数组。
切片的结构体：
// src/reflect/value.go type SliceHeader struct { Data uintptr // 指向底层数组 Len int // 当前切片长度 Cap int // 当前切片容量 } 注意 Cap 也是底层数组的长度。Data 是一块连续的内存，可以存储切片 Cap 大小的所有元素。
如图，虽然 slice 的 Len 是 5，但是底层数组的长度是 10，也就是 Cap。
初始化 # 初始化切片有三种方式：
使用 make // len 是切片的初始长度 // capacity 为可选参数, 指定容量 s := make([]int, len, capacity) 使用字面量 arr :=[]int{1,2,3} 使用下标截取数组或者切片的一部分，这里可以传入三个参数 [low:high:max]，max - low 是新的切片的容量 cap。 numbers := []int{0,1,2,3,4,5,6,7,8} s := numbers[1:4] // [1 2 3] s := numbers[4:] // [4 5 6 7 8] s := numbers[:3]) // [0 1 2] 《Go 学习笔记》 第四版 中的示例：</description></item><item><title>哈希表</title><link>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</guid><description>哈希表 # map 是一个无序的 key/value 对的集合，同一个 key 只会出现一次。
哈希表的设计原理 # 哈希表其实是数组的扩展。哈希表是利用数组可以根据下标随机访问（时间复杂度是 O(1)）这一特性来实现快速查找的。
哈希函数 # 哈希表是通过哈希函数将 key 转化为数组的下标，然后将数据存储在数组下标对应的位置。查询时，也是同样的使用哈希函数计算出数组下标，从下标对应的位置取出数据。
哈希函数的基本要求：
哈希函数计算出来的值是一个非负整数。 如果 key1 == key2 那么 hash(key1) == hash(key2) 如果 key1 != key2 那么 hash(key1) != hash(key2) 第三点，想要实现一个不同的 key 对应的哈希值绝对不一样的哈希函数，几乎是不可能的，也就说无法避免哈希冲突。
常用的处理哈希冲突的方法有两种：开放寻址法和链表法。
开放寻址法 # 开放寻址法核心思想是，如果出现了哈希冲突，就重新探测一个空闲位置，将其插入。
上图蓝色表示已经插入的元素，key9 哈希后得到的数组下标为 6，但是已经有数据了，产生了冲突。那么就按顺序向后查找直到找到一个空闲的位置，如果到数组的尾部都没有找到空闲的位置，就从头开始继续找。 上图最终找到位置 1 并插入元素。
查找的逻辑和插入类似，从哈希函数计算出来的下标位置开始查找，比较数组中下标位置的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。直到找到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。
可以看出当数组中空闲位置不多的时候，哈希冲突的概率就会大大提高。装载因子（load factor）就是用来表示空位的多少。
装载因子=已插入的元素个数/哈希表的长度 装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。
链表法 # 链表法是最常见的哈希冲突的解决办法。在哈希表中，每个桶（bucket）会对应一条链表，所有哈希值相同的元素都放到相同桶对应的链表中。
插入时，哈希函数计算后得出存放在几号桶，然后遍历桶中的链表了：
找到键相同的键值对，则更新键对应的值； 没有找到键相同的键值对，则在链表的末尾追加新的键值对 链表法实现的哈希表的装载因子：
装载因子=已插入的元素个数/桶数量 Go map 原理 # 表示 map 的结构体是 hmap：</description></item><item><title>函数</title><link>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</guid><description>函数 # 参数传递 # Go 使用的是值传递，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型， 区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。 但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
注意，如果实参是 slice、map、function、channel 等类型（引用类型），实参可能会由于函数的间接引用被修改。
没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。
表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和 垃圾回收的成本。在栈上复制小对象，要比堆上分配内存要快的多。如果复制成本高，或者需要修改原对象，使用指针更好。
可变参数 # 变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个。比如 fmt.Printf，Printf 接收一个的必备参数，之 后接收任意个数的后续参数。
在参数列表的最后一个参数类型之前加上省略符号 ...，表示该函数会接收任意数量的该类型参数。
func sum(vals ...int) int { total := 0 for _, val := range vals { total += val } return total } // 调用 fmt.Println(sum()) // &amp;#34;0&amp;#34; fmt.Println(sum(3)) // &amp;#34;3&amp;#34; fmt.Println(sum(1, 2, 3, 4)) // &amp;#34;10&amp;#34; // 还可以使用类似 ES6 的解构赋值的语法 values := []int{1, 2, 3, 4} fmt.</description></item><item><title>接口</title><link>https://shipengqi.github.io/golang-learn/docs/basic/06_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/06_interface/</guid><description>接口 # Go 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实 现了这个接口，无须显示声明。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。
一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。
接口的零值就是它的类型和值的部分都是 nil。
简单的说，interface 是一组 method 的组合，我们通过 interface 来定义对象的一组行为。
定义接口：
type 接口名 interface { 方法名1 [返回类型] 方法名2 [返回类型] 方法名3 [返回类型] ... } /* 定义结构体 */ type struct_name struct { /* variables */ } /* 实现接口方法 */ func (struct_name_variable struct_name) 方法名1() [返回类型] { /* 方法实现 */ } ... func (struct_name_variable struct_name) 方法名2() [返回类型] { /* 方法实现*/ } 实例：
type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.</description></item><item><title>反射</title><link>https://shipengqi.github.io/golang-learn/docs/basic/07_reflect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/07_reflect/</guid><description>反射 # 反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道 这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。
reflect.TypeOf # reflect.TypeOf 获取类型信息。 reflect.TypeOf 接受任意的 interface{} 类型, 并以 reflect.Type 形式返回其动态类型：
t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; type X int func main() { var a X = 20 t := reflect.TypeOf(a) fmt.Println(t.Name(), t.Kind()) // X int } 上面的代码，注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型。所以在判断类型时， 要选择正确的方式。
type X int type Y int func main() { var a, b X = 10, 20 var c Y = 30 ta, tb, tc := reflect.</description></item><item><title>泛型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/08_generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/08_generic/</guid><description> 泛型 #</description></item><item><title>指针</title><link>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</guid><description>指针 # 指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个 保存内存地址的整形变量。
x := 1 p := &amp;amp;x // p, of type *int, points to x fmt.Println(*p) // &amp;#34;1&amp;#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &amp;#34;2&amp;#34; 上面的代码，初始化一个变量 x，&amp;amp; 是取地址操作，&amp;amp;x 就是取变量 x 的内存地址，那么 p 就是一个指针， 类型是 *int，p 这个指针保存了变量 x 的内存地址。接下来 *p 表示读取指针指向的变量的值，也就是变量 x 的值 1。 *p也可以被赋值。
任何类型的指针的零值都是 nil。当指针指向同一个变量或者 nil 时是相等的。 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
指向指针的指针 # var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;amp;a /* 指向指针 ptr 地址 */ pptr = &amp;amp;ptr /* 获取 pptr 的值 */ fmt.</description></item><item><title>range</title><link>https://shipengqi.github.io/golang-learn/docs/basic/10_range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/10_range/</guid><description>range # 带有 range 子句的 for 语句会先把被遍历的字符串值拆成一个字节序列（注意是字节序列），然后再试图找出这个字节序列中 包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。
这样的 for 语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码 值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 rune。
str := &amp;#34;Go 爱好者 &amp;#34; for i, c := range str { fmt.Printf(&amp;#34;%d: %q [% x]\n&amp;#34;, i, c, []byte(string(c))) } 完整的打印内容如下：
0: &amp;#39;G&amp;#39; [47] 1: &amp;#39;o&amp;#39; [6f] 2: &amp;#39;爱&amp;#39; [e7 88 b1] 5: &amp;#39;好&amp;#39; [e5 a5 bd] 8: &amp;#39;者&amp;#39; [e8 80 85] 注意了，&amp;lsquo;爱&amp;rsquo;是由三个字节共同表达的，所以第四个 Unicode 字符&amp;rsquo;好&amp;rsquo;对应的索引值并不是 3，而是 2 加 3 后得到的 5。</description></item><item><title>select</title><link>https://shipengqi.github.io/golang-learn/docs/basic/11_select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/11_select/</guid><description>select # select 类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。
当条件满足时，select 会去通信并执行 case 之后的语句，这时候其它通信是不会执行的。 如果多个 case 同时满足条件，select 会随机地选择一个执行。如果没有 case 可运行，它将阻塞，直到有 case 可运行。
一个默认的子句应该总是可运行的。
select { case communication clause: ... case communication clause: ... default: /* 可选 */ ... } for range 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。for range 会复制目标数据。可改用数组指针或者切片。
range 关键字右边的位置上的代码被称为 range 表达式。
range 表达式只会在 for 语句开始执行时被求值一次，无论后边会有多少次迭代； range 表达式的求值结果会被复制，也就是说，被迭代的对象是 range 表达式结果值的副本而不是原值。 for range 在性能比 for 稍差，因为 for range 会进行值拷贝。 字符串的复制成本很小，切片，字典，通道等引用类型本身是指针的封装，复制成本也很小，无序专门优化。
如果 range 的目标表达式是函数，也只会运行一次。
numbers1 := []int{1, 2, 3, 4, 5, 6} for i := range numbers1 { if i == 3 { numbers1[i] |= i } } fmt.</description></item><item><title>defer</title><link>https://shipengqi.github.io/golang-learn/docs/basic/12_defer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/12_defer/</guid><description>defer # 堆上分配 # 编译器不仅将 defer 关键字都转换成 runtime.deferproc 函数，它还会通过以下三个步骤为所有调用 defer 的函数末尾插入 runtime.deferreturn 的函数调用
runtime.deferproc 负责创建新的延迟调用； runtime.deferreturn 负责在函数调用结束时执行所有的延迟调用；
runtime.deferproc 会为 defer 创建一个新的 runtime._defer 结构体、设置它的函数指针 fn、程序计数器 pc 和栈指针 sp 并将相关的参数拷贝到相邻的内存空间中：
func deferproc(siz int32, fn *funcval) { sp := getcallersp() argp := uintptr(unsafe.Pointer(&amp;amp;fn)) + unsafe.Sizeof(fn) callerpc := getcallerpc() d := newdefer(siz) if d._panic != nil { throw(&amp;#34;deferproc: d.panic != nil after newdefer&amp;#34;) } d.fn = fn d.pc = callerpc d.sp = sp switch siz { case 0: case sys.</description></item><item><title>panic</title><link>https://shipengqi.github.io/golang-learn/docs/basic/13_panic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/13_panic/</guid><description>panic # Panic 异常 # Go 运行时错误会引起 painc 异常。 一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（defer 机制）。随后，程序崩溃 并输出日志信息。
由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使 用 Go 提供的错误机制，而不是 panic，尽量避免程序的崩溃。
panic 函数 # panic 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 panic。
panic 详情中都有什么 # panic: runtime error: index out of range goroutine 1 [running]: main.main() /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d exit status 2 第一行是 panic: runtime error: index out of range。其中的 runtime error 的含义是，这是一个 runtime 代码包中 抛出的 panic。
goroutine 1 [running]，它表示有一个 ID 为1的 goroutine 在此 panic 被引发的时候正在运行。这里的 ID 其实并不重要。</description></item><item><title>make 和 new</title><link>https://shipengqi.github.io/golang-learn/docs/basic/14_make_new/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/14_make_new/</guid><description> make 和 new #</description></item><item><title>面向对象</title><link>https://shipengqi.github.io/golang-learn/docs/basic/15_oop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/15_oop/</guid><description>面向对象 # GO 支持面向对象编程。
方法 # 方法声明：
func (变量名 类型) 方法名() [返回类型]{ /* 函数体*/ } 实例：
/* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&amp;#34;Area of Circle(c1) = &amp;#34;, c1.getArea()) } // 该 method 属于 Circle 类型对象中的方法 // 这里的 c 叫作方法的接收器，类似 Javascript 的 this func (c Circle) getArea() float64 { // c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.</description></item></channel></rss>