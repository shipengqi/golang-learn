<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="io#io 是对输入输出设备的抽象。io 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。 最重要的是两个接口：Reader 和 Writer。
Reader#Reader 接口：
type Reader interface { Read(p []byte) (n int, err error) } Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)） 以及任何遇到的错误。 即使 Read 返回的 n &lt; len(p)，它也会在调用过程中占用 len(p) 个字节作为暂存空间。若可读取的数据不到 len(p) 个 字节，Read 会返回可用数据，而不是等待更多数据。
当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。它可能会同时在本次的调 用中返回一个 non-nil 错误,或在下一次的调用中返回这个错误（且 n 为 0）。 一般情况下, Reader 会返回一个 非 0 字节数 n, 若 n = len(p) 个字节从输入源的结尾处由 Read 返回，Read 可能返回 err == EOF 或者 err == nil。并且之后的 Read 都应该返回 (n:0, err:EOF)。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="io" />
<meta property="og:description" content="io#io 是对输入输出设备的抽象。io 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。 最重要的是两个接口：Reader 和 Writer。
Reader#Reader 接口：
type Reader interface { Read(p []byte) (n int, err error) } Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)） 以及任何遇到的错误。 即使 Read 返回的 n &lt; len(p)，它也会在调用过程中占用 len(p) 个字节作为暂存空间。若可读取的数据不到 len(p) 个 字节，Read 会返回可用数据，而不是等待更多数据。
当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。它可能会同时在本次的调 用中返回一个 non-nil 错误,或在下一次的调用中返回这个错误（且 n 为 0）。 一般情况下, Reader 会返回一个 非 0 字节数 n, 若 n = len(p) 个字节从输入源的结尾处由 Read 返回，Read 可能返回 err == EOF 或者 err == nil。并且之后的 Read 都应该返回 (n:0, err:EOF)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/golang-learn/docs/standards/io/io/" /><meta property="article:section" content="docs" />

<meta property="article:modified_time" content="2023-10-07T14:03:42+08:00" />
<title>io | Golang Learning</title>
<link rel="manifest" href="/golang-learn/manifest.json">
<link rel="icon" href="/golang-learn/favicon.png" >
<link rel="stylesheet" href="/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/golang-learn/flexsearch.min.js"></script>
  <script defer src="/golang-learn/en.search.min.9d19f3cf24b235d59b85d5a7e5dcdc41758b1caac59546ce7f048de6fd1ce8fd.js" integrity="sha256-nRnzzySyNdWbhdWn5dzcQXWLHKrFlUbOfwSN5v0c6P0=" crossorigin="anonymous"></script>

  <script defer src="/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js" integrity="sha256-6aVVKOAw5E7L4bWo2n3Y&#43;0C9KC0C3EV06BuZmmohvIQ=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/golang-learn/"><span>Golang Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>







  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/golang-learn"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/"  target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>语言基础</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/env_config/" class="">Go 环境配置</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/build/" class="">Golang 条件编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/map/" class="">map</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/slice/" class="">slice</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/scope/" class="">作用域</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/function/" class="">函数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/package/" class="">包</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/reflect/" class="">反射</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/var/" class="">变量</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/basic_data/" class="">基础据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/constant/" class="">常量</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/json/" class="">序列化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/pointer/" class="">指针</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/interface/" class="">接口</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/flow/" class="">控制语句</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/array/" class="">数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/test/" class="">测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/struct/" class="">结构体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/operator/" class="">运算符</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/error/" class="">错误</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/oop/" class="">面向对象</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>并发编程</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/channel/" class="">channel</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/goroutine/" class="">goroutine</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/sync_lock/" class="">同步和锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/concurrent/" class="">并发和并行</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>常用命令</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/build/" class="">build</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/doc/" class="">doc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/env/" class="">env</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/fmt/" class="">fmt</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/get/" class="">get</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/summary/" class="">Go 命令</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/golint/" class="">golint</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/install/" class="">install</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/mod/" class="">mod</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/run/" class="">run</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/test/" class="">test</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/tool/" class="">tool</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/vet/" class="">vet</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>常用标准库</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>Data</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/big/" class="">big</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/container/" class="">container</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/math/" class="">math</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/sort/" class="">sort</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Database</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/database/sql/" class="">sql</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Io</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/bufio/" class="">bufio</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/fmt/" class="">fmt 包</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/io/" class="active">io</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/ioutil/" class="">ioutil</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Net</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/net/http/" class="">http</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Os</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/os/filepath/" class="">filepath</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/os/os/" class="">os</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Text</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/text/strconv/" class="">strconv</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/text/strings/" class="">strings</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/text/unicode/" class="">unicode</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/unsafe/" class="">Unsafe</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/log/" class="">log</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/time/" class="">time</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>实践</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/errors/" class="">Errors</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/gin/" class="">Gin</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/ginkgo/" class="">Ginkgo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/pprof/" class="">Go PProf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/trace/" class="">Go trace</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/go-race/" class="">Go 数据竞争检测器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/go_relative_path/" class="">Go 的相对路径</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/json/" class="">Json Unmarshal</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>底层原理</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/advance/scheduler/" class="">Goroutine 调度器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/advance/mm/" class="">内存分配</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/advance/gc/" class="">垃圾回收</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/golang-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>io</strong>

  <label for="toc-control">
    
    <img src="/golang-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#io">io</a>
      <ul>
        <li><a href="#reader">Reader</a></li>
        <li><a href="#writer">Writer</a></li>
        <li><a href="#实现了-ioreader-接口或-iowriter-接口的类型">实现了 io.Reader 接口或 io.Writer 接口的类型</a></li>
        <li><a href="#readerat-和-writerat">ReaderAt 和 WriterAt</a></li>
        <li><a href="#readerfrom-和-writerto">ReaderFrom 和 WriterTo</a></li>
        <li><a href="#seeker">Seeker</a></li>
        <li><a href="#closer">Closer</a></li>
        <li><a href="#其他接口">其他接口</a>
          <ul>
            <li><a href="#bytereader-和-bytewriter">ByteReader 和 ByteWriter</a></li>
            <li><a href="#bytescannerrunereader-和-runescanner">ByteScanner、RuneReader 和 RuneScanner</a></li>
            <li><a href="#readcloserreadseekerreadwritecloserreadwriteseekerreadwriterwritecloser-和-writeseeker">ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker</a></li>
          </ul>
        </li>
        <li><a href="#sectionreader-类型">SectionReader 类型</a></li>
        <li><a href="#limitedreader-类型">LimitedReader 类型</a></li>
        <li><a href="#pipereader-和-pipewriter-类型">PipeReader 和 PipeWriter 类型</a></li>
        <li><a href="#copy-和-copyn-函数">Copy 和 CopyN 函数</a></li>
        <li><a href="#readatleast-和-readfull-函数">ReadAtLeast 和 ReadFull 函数</a></li>
        <li><a href="#writestring-函数">WriteString 函数</a></li>
        <li><a href="#multireader-和-multiwriter-函数">MultiReader 和 MultiWriter 函数</a></li>
        <li><a href="#teereader-函数">TeeReader 函数</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="io">
  io
  <a class="anchor" href="#io">#</a>
</h1>
<p><code>io</code> 是对输入输出设备的抽象。<code>io</code> 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。
最重要的是两个接口：<code>Reader</code> 和 <code>Writer</code>。</p>
<h2 id="reader">
  Reader
  <a class="anchor" href="#reader">#</a>
</h2>
<p>Reader 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Reader</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>Read</code> 将 <code>len(p)</code> 个字节读取到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>） 以及任何遇到的错误。
即使 <code>Read</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中占用 <code>len(p)</code> 个字节作为暂存空间。若可读取的数据不到 <code>len(p)</code> 个
字节，<code>Read</code> 会返回可用数据，而不是等待更多数据。</p>
</blockquote>
<blockquote>
<p>当 <code>Read</code> 在成功读取 <code>n &gt; 0</code> 个字节后遇到一个错误或 <code>EOF</code> (<code>end-of-file</code>)，它会返回读取的字节数。它可能会同时在本次的调
用中返回一个 <code>non-nil</code> 错误,或在下一次的调用中返回这个错误（且 <code>n</code> 为 0）。 一般情况下, <code>Reader</code> 会返回一个 非 0 字节数 <code>n</code>,
若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>Read</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code>。并且之后的 <code>Read</code>
都应该返回 (<code>n:0, err:EOF</code>)。</p>
</blockquote>
<blockquote>
<p>调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许 <code>EOF</code> 的出现。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">reader</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">num</span> <span style="color:#66d9ef">int</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">num</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>[:<span style="color:#a6e22e">n</span>], <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ReadFrom</code> 函数将 <code>io.Reader</code> 作为参数，也就是说，<code>ReadFrom</code> 可以从任意的地方读取数据，只要来源实现了 <code>io.Reader</code> 接口。
比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 从标准输入读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>, <span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从普通文件读取，其中 file 是 os.File 的实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">file</span>, <span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从字符串读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;from string&#34;</span>), <span style="color:#ae81ff">12</span>)
</span></span></code></pre></div><p><code>io.EOF</code> 变量的定义：<code>var EOF = errors.New(&quot;EOF&quot;)</code>，是 <code>error</code> 类型。根据 <code>reader</code> 接口的说明，在 <code>n &gt; 0</code> 且数据被读完了
的情况下，当次返回的 <code>error</code> 有可能是 <code>EOF</code> 也有可能是 <code>nil</code>。</p>
<h2 id="writer">
  Writer
  <a class="anchor" href="#writer">#</a>
</h2>
<p>Writer 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>Write</code> 将 <code>len(p)</code> 个字节从 <code>p</code> 中写入到基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任何遇到的引
起写入提前停止的错误。若 <code>Write</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>
</blockquote>
<p>以 <code>fmt.Fprintln</code> 为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fprintln</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看出 <code>fmt.Println</code> 会将内容输出到标准输出中。</p>
<h2 id="实现了-ioreader-接口或-iowriter-接口的类型">
  实现了 io.Reader 接口或 io.Writer 接口的类型
  <a class="anchor" href="#%e5%ae%9e%e7%8e%b0%e4%ba%86-ioreader-%e6%8e%a5%e5%8f%a3%e6%88%96-iowriter-%e6%8e%a5%e5%8f%a3%e7%9a%84%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p>标准库中有哪些类型实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口？</p>
<p>例如 <code>os.Stdin/Stdout</code>，它们分别实现了 <code>io.Reader/io.Writer</code> 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Stdin</span>  = <span style="color:#a6e22e">NewFile</span>(uintptr(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Stdin</span>), <span style="color:#e6db74">&#34;/dev/stdin&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Stdout</span> = <span style="color:#a6e22e">NewFile</span>(uintptr(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Stdout</span>), <span style="color:#e6db74">&#34;/dev/stdout&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Stderr</span> = <span style="color:#a6e22e">NewFile</span>(uintptr(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Stderr</span>), <span style="color:#e6db74">&#34;/dev/stderr&#34;</span>)
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>上面的代码可以看出，<code>Stdin/Stdout/Stderr</code> 只是三个特殊的文件类型的标识（都是 <code>os.File</code> 的实例），<code>os.File</code> 实现
了 <code>io.Reader</code> 和 <code>io.Writer</code>。</p>
<p>实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口的类型：</p>
<ul>
<li><code>os.File</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>strings.Reader</code> 实现了 <code>io.Reader</code></li>
<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>bytes.Buffer</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>bytes.Reader</code> 实现了 <code>io.Reader</code></li>
<li><code>compress/gzip.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>crypto/cipher.StreamReader/StreamWriter</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>crypto/tls.Conn</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>encoding/csv.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>mime/multipart.Part</code> 实现了 <code>io.Reader</code></li>
<li><code>net/conn</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code>(Conn接口定义了Read/Write)</li>
</ul>
<p><strong>io 包本身实现这两个接口的类型</strong>：</p>
<ul>
<li>实现了 <code>Reader</code> 的类型：<code>LimitedReader</code>、<code>PipeReader</code>、<code>SectionReader</code></li>
<li>实现了 <code>Writer</code> 的类型：<code>PipeWriter</code></li>
</ul>
<h2 id="readerat-和-writerat">
  ReaderAt 和 WriterAt
  <a class="anchor" href="#readerat-%e5%92%8c-writerat">#</a>
</h2>
<p><strong><code>ReaderAt</code> 接口</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ReaderAt</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ReadAt</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">off</span> <span style="color:#66d9ef">int64</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>ReadAt</code> 从基本输入源的偏移量 <code>off</code> 处开始，将 <code>len(p)</code> 个字节读到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任
何遇到的错误。</p>
</blockquote>
<blockquote>
<p>当 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code> 时，它就会返回一个 <strong>非 nil</strong> 的错误来解释为什么没有返回更多的字节。</p>
</blockquote>
<blockquote>
<p>即使 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中使用 <code>p</code> 的全部作为暂存空间。若可读取的数据不到 <code>len(p)</code> 字节，<code>ReadAt</code> 就会
阻塞,直到所有数据都可用或一个错误发生。</p>
</blockquote>
<blockquote>
<p>若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>ReadAt</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code></p>
</blockquote>
<blockquote>
<p>若 <code>ReadAt</code> 携带一个偏移量从输入源读取，<code>ReadAt</code> 应当既不影响偏移量也不被它所影响。</p>
</blockquote>
<blockquote>
<p>可对相同的输入源并行执行 <code>ReadAt</code> 调用。</p>
</blockquote>
<p>可见，<code>ReadAt</code> 接口使得可以从指定偏移量处开始读取数据。</p>
<p>简单示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Hello world&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">ReadAt</span>(<span style="color:#a6e22e">p</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s, %d\n&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">n</span>) <span style="color:#75715e">// llo wo, 6
</span></span></span></code></pre></div><p><strong><code>WriterAt</code> 接口</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WriterAt</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">WriteAt</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">off</span> <span style="color:#66d9ef">int64</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>WriteAt</code> 从 <code>p</code> 中将 <code>len(p)</code> 个字节写入到偏移量 <code>off</code> 处的基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）
以及任何遇到的引起写入提前停止的错误。若 <code>WriteAt</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>
</blockquote>
<blockquote>
<p>若 <code>WriteAt</code> 携带一个偏移量写入到目标中，<code>WriteAt</code> 应当既不影响偏移量也不被它所影响。</p>
</blockquote>
<blockquote>
<p>若被写区域没有重叠，可对相同的目标并行执行 <code>WriteAt</code> 调用。</p>
</blockquote>
<p>我们可以通过该接口将数据写入到数据流的特定偏移量之后。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Create</span>(<span style="color:#e6db74">&#34;writeAt.txt&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;Hello world----ignore&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">WriteAt</span>([]byte(<span style="color:#e6db74">&#34;Golang&#34;</span>), <span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">n</span>)
</span></span></code></pre></div><p>打开文件 <code>WriteAt.txt</code>，内容是：<code>Hello world----Golang</code>。</p>
<p>分析：</p>
<p><code>file.WriteString(&quot;Hello world----ignore&quot;)</code> 往文件中写入 <code>Hello world----ignore</code>，之后
<code>file.WriteAt([]byte(&quot;Golang&quot;), 15)</code> 在文件流的 <code>offset=15</code> 处写入 <code>Golang</code>（会覆盖该位置的内容）。</p>
<h2 id="readerfrom-和-writerto">
  ReaderFrom 和 WriterTo
  <a class="anchor" href="#readerfrom-%e5%92%8c-writerto">#</a>
</h2>
<p>这两个接口实现了<strong>一次性从某个地方读或写到某个地方去</strong>。
<strong>ReaderFrom</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ReaderFrom</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Reader</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>ReadFrom</code> 从 <code>r</code> 中读取数据，直到 <code>EOF</code> 或发生错误。其返回值 <code>n</code> 为读取的字节数。除 <code>io.EOF</code> 之外，在读取过程中遇到的任何错误也
将被返回。</p>
</blockquote>
<blockquote>
<p>如果 <code>ReaderFrom</code> 可用，<code>Copy</code> 函数就会使用它。</p>
</blockquote>
<p>注意：<code>ReadFrom</code> 方法不会返回 <code>err == EOF</code>。</p>
<p>将文件中的数据全部读取（显示在标准输出）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#e6db74">&#34;writeAt.txt&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">NewWriter</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">file</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">Flush</span>()
</span></span></code></pre></div><p>也可以通过 <code>ioutil</code> 包的 <code>ReadFile</code> 函数获取文件全部内容。其实，跟踪一下 <code>ioutil.ReadFile</code> 的源码，会发现其实也是通过 <code>ReadFrom</code> 方
法实现（用的是 <code>bytes.Buffer</code>，它实现了 <code>ReaderFrom</code> 接口）。</p>
<p><strong>WriterTo</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WriterTo</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">WriteTo</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">Writer</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>WriteTo</code> 将数据写入 <code>w</code> 中，直到没有数据可写或发生错误。其返回值 <code>n</code> 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。</p>
</blockquote>
<blockquote>
<p>如果 <code>WriterTo</code> 可用，<code>Copy</code> 函数就会使用它。</p>
</blockquote>
<p>将一段文本输出到标准输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">NewReader</span>([]byte(<span style="color:#e6db74">&#34;Hello world&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">WriteTo</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>)
</span></span></code></pre></div><h2 id="seeker">
  Seeker
  <a class="anchor" href="#seeker">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Seeker</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Seek</span>(<span style="color:#a6e22e">offset</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">whence</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">ret</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>Seek</code> 设置下一次 <code>Read</code> 或 <code>Write</code> 的偏移量为 <code>offset</code>，它的解释取决于 <code>whence</code>：  <strong>0 表示相对于文件的起始处，1 表示相对
于当前的偏移，而 2 表示相对于其结尾处</strong>。 <code>Seek</code> 返回新的偏移量和一个错误，如果有的话。</p>
</blockquote>
<p>也就是说，<code>Seek</code> 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 <code>ReaderAt/WriteAt</code> 接口有些类似，
不过 <code>Seeker</code> 接口更灵活，可以更好的控制读写数据流的位置。</p>
<p>获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Hello world&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Seek</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">6</span>, <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">SeekEnd</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">ReadRune</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%c\n&#34;</span>, <span style="color:#a6e22e">r</span>)
</span></span></code></pre></div><p><code>whence</code> 的值，在 io 包中定义了相应的常量，应该使用这些常量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SeekStart</span>   = <span style="color:#ae81ff">0</span> <span style="color:#75715e">// seek relative to the origin of the file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SeekCurrent</span> = <span style="color:#ae81ff">1</span> <span style="color:#75715e">// seek relative to the current offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SeekEnd</span>     = <span style="color:#ae81ff">2</span> <span style="color:#75715e">// seek relative to the end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><p>而原先 <code>os</code> 包中的常量已经被标注为 Deprecated</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SEEK_SET</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">0</span> <span style="color:#75715e">// seek relative to the origin of the file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SEEK_CUR</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">1</span> <span style="color:#75715e">// seek relative to the current offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SEEK_END</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">2</span> <span style="color:#75715e">// seek relative to the end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><h2 id="closer">
  Closer
  <a class="anchor" href="#closer">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Closer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Close</span>() <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该接口比较简单，只有一个 <code>Close()</code> 方法，用于关闭数据流。</p>
<p>文件 (<code>os.File</code>)、归档（压缩包）、数据库连接、<code>Socket</code> 等需要手动关闭的资源都实现了 <code>Closer</code> 接口。</p>
<p>实际编程中，经常将 <code>Close</code> 方法的调用放在 <code>defer</code> 语句中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#e6db74">&#34;studygolang.txt&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当文件 <code>studygolang.txt</code> 不存在或找不到时，<code>file.Close()</code> 会返回错误，因为 <code>file</code> 是 <code>nil</code>。
因此，应该<strong>将 <code>defer file.Close()</code> 放在错误检查之后</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">File</span>) <span style="color:#a6e22e">Close</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ErrInvalid</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">file</span>.close()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="其他接口">
  其他接口
  <a class="anchor" href="#%e5%85%b6%e4%bb%96%e6%8e%a5%e5%8f%a3">#</a>
</h2>
<h3 id="bytereader-和-bytewriter">
  ByteReader 和 ByteWriter
  <a class="anchor" href="#bytereader-%e5%92%8c-bytewriter">#</a>
</h3>
<p>读或写一个字节：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ByteReader</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ReadByte</span>() (<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ByteWriter</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">WriteByte</span>(<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面类型都实现了这两个接口:</p>
<ul>
<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>
<li><code>bytes.Buffer</code> 同时实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>
<li><code>bytes.Reader</code> 实现了 <code>io.ByteReader</code></li>
<li><code>strings.Reader</code> 实现了 <code>io.ByteReader</code></li>
</ul>
<p>通过 <code>bytes.Buffer</code> 来一次读取或写入一个字节：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Scanf</span>(<span style="color:#e6db74">&#34;%c\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buffer</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">WriteByte</span>(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;写入一个字节成功！准备读取该字节……&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">newCh</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">ReadByte</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;读取的字节：%c\n&#34;</span>, <span style="color:#a6e22e">newCh</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;写入错误&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>程序从标准输入接收一个字节（ASCII 字符），调用 <code>buffer</code> 的 <code>WriteByte</code> 将该字节写入 <code>buffer</code> 中，之后通过 <code>ReadByte</code> 读取该字节。</p>
<h3 id="bytescannerrunereader-和-runescanner">
  ByteScanner、RuneReader 和 RuneScanner
  <a class="anchor" href="#bytescannerrunereader-%e5%92%8c-runescanner">#</a>
</h3>
<p><code>ByteScanner</code> 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ByteScanner</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ByteReader</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">UnreadByte</span>() <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内嵌了 <code>ByteReader</code> 接口，<code>UnreadByte</code> 方法的意思是：将上一次 <code>ReadByte</code> 的字节还原，使得再次调用 <code>ReadByte</code> 返回的结果和上一次调
用相同，也就是说，<code>UnreadByte</code> 是重置上一次的 <code>ReadByte</code>。注意，<strong><code>UnreadByte</code> 调用之前必须调用了 <code>ReadByte</code>，且不能连续调
用 <code>UnreadByte</code></strong>。即：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">buffer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">NewBuffer</span>([]<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">UnreadByte</span>()
</span></span></code></pre></div><p>和</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">buffer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">NewBuffer</span>([]<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">ReadByte</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">UnreadByte</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">UnreadByte</span>()
</span></span></code></pre></div><p><code>err</code> 都 <strong>非 nil</strong>，错误为：<code>bytes.Buffer: UnreadByte: previous operation was not a read</code></p>
<p><code>RuneReader</code> 接口和 <code>ByteReader</code> 类似，只是 <code>ReadRune</code> 方法读取单个 UTF-8 字符，返回其 <code>rune</code> 和该字符占用的字节数。</p>
<p><code>RuneScanner</code> 接口和 <code>ByteScanner</code> 类似。</p>
<h3 id="readcloserreadseekerreadwritecloserreadwriteseekerreadwriterwritecloser-和-writeseeker">
  ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker
  <a class="anchor" href="#readcloserreadseekerreadwritecloserreadwriteseekerreadwriterwritecloser-%e5%92%8c-writeseeker">#</a>
</h3>
<p>这些接口是上面介绍的接口的两个或三个组合而成的新接口。<code>ReadWriter</code> 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ReadWriter</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Reader</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Reader</code> 和 <code>Writer</code> 接口的组合。</p>
<p>这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。</p>
<h2 id="sectionreader-类型">
  SectionReader 类型
  <a class="anchor" href="#sectionreader-%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p><code>SectionReader</code> 是一个 <code>struct</code>，实现了 <code>Read</code>, <code>Seek</code> 和 <code>ReadAt</code>，同时，内嵌了 <code>ReaderAt</code> 接口。结构定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SectionReader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>     <span style="color:#a6e22e">ReaderAt</span>	<span style="color:#75715e">// 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">base</span>  <span style="color:#66d9ef">int64</span>		<span style="color:#75715e">// NewSectionReader 会将 base 设置为 off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">off</span>   <span style="color:#66d9ef">int64</span>		<span style="color:#75715e">// 从 r 中的 off 偏移处开始读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">limit</span> <span style="color:#66d9ef">int64</span>		<span style="color:#75715e">// limit - off = SectionReader 流的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>该类型读取数据流中部分数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSectionReader</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">ReaderAt</span>, <span style="color:#a6e22e">off</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">SectionReader</span>
</span></span></code></pre></div><blockquote>
<p><code>NewSectionReader</code> 返回一个 <code>SectionReader</code>，它从 <code>r</code> 中的偏移量 <code>off</code> 处读取 <code>n</code> 个字节后以 <code>EOF</code> 停止。</p>
</blockquote>
<p>也就是说，SectionReader 只是内部 ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。</p>
<p>这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。</p>
<p>由于该类型所支持的操作，前面都有介绍，因此不提供示例代码了。</p>
<h2 id="limitedreader-类型">
  LimitedReader 类型
  <a class="anchor" href="#limitedreader-%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LimitedReader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">R</span> <span style="color:#a6e22e">Reader</span> <span style="color:#75715e">// underlying reader，最终的读取操作通过 R.Read 完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int64</span>  <span style="color:#75715e">// max bytes remaining
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p>从 <code>R</code> 读取但将返回的数据量限制为 <code>N</code> 字节。每调用一次 <code>Read</code> 都将更新 <code>N</code> 来反应新的剩余数量。</p>
</blockquote>
<p>也就是说，最多只能返回 <code>N</code> 字节数据。</p>
<p><code>LimitedReader</code> 只实现了 <code>Read</code> 方法。</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">content</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;This Is LimitReader Example&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">limitReader</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">LimitedReader</span>{<span style="color:#a6e22e">R</span>: <span style="color:#a6e22e">reader</span>, <span style="color:#a6e22e">N</span>: <span style="color:#ae81ff">8</span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">limitReader</span>.<span style="color:#a6e22e">N</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">limitReader</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">tmp</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s&#34;</span>, <span style="color:#a6e22e">tmp</span>) <span style="color:#75715e">// This Is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>通过该类型可以达到 <strong>只允许读取一定长度数据</strong> 的目的。</p>
<p>在 <code>io</code> 包中，<code>LimitReader</code> 函数的实现其实就是调用 <code>LimitedReader</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">LimitReader</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>) <span style="color:#a6e22e">Reader</span> { <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">LimitedReader</span>{<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">n</span>} }
</span></span></code></pre></div><h2 id="pipereader-和-pipewriter-类型">
  PipeReader 和 PipeWriter 类型
  <a class="anchor" href="#pipereader-%e5%92%8c-pipewriter-%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p><code>PipeReader</code> 是管道的读取端。它实现了 <code>io.Reader</code> 和 <code>io.Closer</code> 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PipeReader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipe</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），
该 <code>Read</code> 返回的 <code>err</code> 就是写入端传递的 <code>error</code>；否则 <code>err</code> 为 <code>EOF</code>。</p>
</blockquote>
<p><code>PipeWriter</code> 是管道的写入端。它实现了 <code>io.Writer</code> 和 <code>io.Closer</code> 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PipeWriter</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipe</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时
带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），该 <code>Write</code> 返回的 <code>err</code> 就是读取端传递的 <code>error</code>；否则 <code>err</code> 为 <code>ErrClosedPipe</code>。</p>
</blockquote>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pipeReader</span>, <span style="color:#a6e22e">pipeWriter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Pipe</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">PipeWrite</span>(<span style="color:#a6e22e">pipeWriter</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">PipeRead</span>(<span style="color:#a6e22e">pipeReader</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">30</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">PipeWrite</span>(<span style="color:#a6e22e">writer</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">PipeWriter</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">&#34;Go语言中文网&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;写入字节 %d\n&#34;</span>,<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">CloseWithError</span>(<span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;写入段已关闭&#34;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">PipeRead</span>(<span style="color:#a6e22e">reader</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">PipeReader</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">128</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;接口端开始阻塞5秒钟...&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;接收端开始接受&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;收到字节: %d\n buf内容: %s\n&#34;</span>,<span style="color:#a6e22e">n</span>,<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>io.Pipe()</code> 用于创建一个同步的内存管道：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Pipe</span>() (<span style="color:#f92672">*</span><span style="color:#a6e22e">PipeReader</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">PipeWriter</span>)
</span></span></code></pre></div><p>它将 <code>io.Reader</code> 连接到 <code>io.Writer</code>。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 <code>Read</code>
和 <code>Write</code> 以及其它函数或 <code>Close</code> 来说都是安全的。一旦等待的 I/O 结束，<code>Close</code> 就会完成。并行调用 <code>Read</code> 或并行调用 <code>Write</code> 也
同样安全：同种类的调用将按顺序进行控制。</p>
<p>正因为是<strong>同步</strong>的，因此不能在一个 goroutine 中进行读和写。</p>
<p>另外，对于管道的 <code>close</code> 方法（非 <code>CloseWithError</code> 时），<code>err</code> 会被置为 <code>EOF</code>。</p>
<h2 id="copy-和-copyn-函数">
  Copy 和 CopyN 函数
  <a class="anchor" href="#copy-%e5%92%8c-copyn-%e5%87%bd%e6%95%b0">#</a>
</h2>
<p><strong>Copy 函数</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">dst</span> <span style="color:#a6e22e">Writer</span>, <span style="color:#a6e22e">src</span> <span style="color:#a6e22e">Reader</span>) (<span style="color:#a6e22e">written</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p>函数文档：</p>
<blockquote>
<p><code>Copy</code> 将 <code>src</code> 复制到 <code>dst</code>，直到在 <code>src</code> 上到达 <code>EOF</code> 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一
个错误。</p>
</blockquote>
<blockquote>
<p>成功的 <code>Copy</code> 返回 <code>err == nil</code>，而非 <code>err == EOF</code>。由于 <code>Copy</code> 被定义为从 <code>src</code> 读取直到 <code>EOF</code> 为止，因此它不会将来
自 <code>Read</code> 的 <code>EOF</code> 当做错误来报告。</p>
</blockquote>
<blockquote>
<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，其复制操作可通过调用 <code>dst.ReadFrom(src)</code> 实现。此外，若 <code>src</code> 实现了 <code>WriterTo</code> 接口，其复
制操作可通过调用 <code>src.WriteTo(dst)</code> 实现。</p>
</blockquote>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>, <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Go语言中文网&#34;</span>))
</span></span></code></pre></div><p>直接将内容输出（写入 Stdout 中）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Got EOF -- bye&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>执行：<code>echo &quot;Hello, World&quot; | go run main.go</code></p>
<p><strong>CopyN 函数</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CopyN</span>(<span style="color:#a6e22e">dst</span> <span style="color:#a6e22e">Writer</span>, <span style="color:#a6e22e">src</span> <span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>) (<span style="color:#a6e22e">written</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><blockquote>
<p><code>CopyN</code> 将 <code>n</code> 个字节(或到一个 <code>error</code>)从 <code>src</code> 复制到 <code>dst</code>。 它返回复制的字节数以及在复制时遇到的最早的错误。
当且仅当 <code>err == nil</code> 时,<code>written == n</code> 。</p>
</blockquote>
<blockquote>
<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，复制操作也就会使用它来实现。</p>
</blockquote>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">CopyN</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>, <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Go语言中文网&#34;</span>), <span style="color:#ae81ff">8</span>) <span style="color:#75715e">// Go语言
</span></span></span></code></pre></div><h2 id="readatleast-和-readfull-函数">
  ReadAtLeast 和 ReadFull 函数
  <a class="anchor" href="#readatleast-%e5%92%8c-readfull-%e5%87%bd%e6%95%b0">#</a>
</h2>
<p><strong>ReadAtLeast 函数</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ReadAtLeast</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">min</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p>函数文档：</p>
<blockquote>
<p><code>ReadAtLeast</code> 将 <code>r</code> 读取到 <code>buf</code> 中，直到读了最少 <code>min</code> 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。
若没有读取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了少于 <code>min</code> 个字节之后，<code>ReadAtLeast</code> 就会返回 <code>ErrUnexpectedEOF</code>。
若 <code>min</code> 大于 <code>buf</code> 的长度，<code>ReadAtLeast</code> 就会返回 <code>ErrShortBuffer</code>。对于返回值，当且仅当 <code>err == nil</code> 时，才有 <code>n &gt;= min</code>。</p>
</blockquote>
<p><strong>ReadFull 函数</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ReadFull</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p>函数文档：</p>
<blockquote>
<p><code>ReadFull</code> 精确地从 <code>r</code> 中将 <code>len(buf)</code> 个字节读取到 <code>buf</code> 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读
取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了一些但不是所有的字节后，<code>ReadFull</code> 就会返回 <code>ErrUnexpectedEOF</code>。对于返回值，
当且仅当 <code>err == nil</code> 时，才有 <code>n == len(buf)</code>。</p>
</blockquote>
<p>注意该函数和 <code>ReadAtLeast</code> 的区别：</p>
<ul>
<li><code>ReadFull</code> 将 <code>buf</code> 读满</li>
<li><code>ReadAtLeast</code> 是最少读取 <code>min</code> 个字节。</li>
</ul>
<h2 id="writestring-函数">
  WriteString 函数
  <a class="anchor" href="#writestring-%e5%87%bd%e6%95%b0">#</a>
</h2>
<p>这是为了方便写入 <code>string</code> 类型提供的函数，函数签名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">Writer</span>, <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p>函数文档：</p>
<blockquote>
<p><code>WriteString</code> 将 ``s 的内容写入 <code>w</code> 中，当 <code>w</code> 实现了 <code>WriteString</code> 方法时，会直接调用该方法，否则执行 <code>w.Write([]byte(s))</code>。</p>
</blockquote>
<h2 id="multireader-和-multiwriter-函数">
  MultiReader 和 MultiWriter 函数
  <a class="anchor" href="#multireader-%e5%92%8c-multiwriter-%e5%87%bd%e6%95%b0">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MultiReader</span>(<span style="color:#a6e22e">readers</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">Reader</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MultiWriter</span>(<span style="color:#a6e22e">writers</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">Writer</span>
</span></span></code></pre></div><p>它们接收多个 <code>Reader</code> 或 <code>Writer</code>，返回一个 <code>Reader</code> 或 <code>Writer</code>。我们可以猜想到这两个函数就是操作多个 <code>Reader</code> 或 <code>Writer</code> 就像
操作一个。</p>
<p>事实上，在 <code>io</code> 包中定义了两个非导出类型：<code>mutilReader</code> 和 <code>multiWriter</code>，它们分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">multiReader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">readers</span> []<span style="color:#a6e22e">Reader</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">multiWriter</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">writers</span> []<span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于这两种类型对应的实现方法（<code>Read</code> 和 <code>Write</code> 方法）的使用，示例：</p>
<p><strong>MultiReader 的使用</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">readers</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;from strings reader&#34;</span>),
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">NewBufferString</span>(<span style="color:#e6db74">&#34;from bytes buffer&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">MultiReader</span>(<span style="color:#a6e22e">readers</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">128</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">buf</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span> ; <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">buf</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>		panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> = append(<span style="color:#a6e22e">data</span>,<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">n</span>]<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s\n&#34;</span>, <span style="color:#a6e22e">data</span>) <span style="color:#75715e">// from strings readerfrom bytes buffer
</span></span></span></code></pre></div><p>代码中首先构造了一个 <code>io.Reader</code> 的 <code>slice</code>，然后通过 <code>MultiReader</code> 得到新的 <code>Reader</code>，循环读取新 <code>Reader</code> 中的内容。从输出结果
可以看到，第一次调用 <code>Reader</code> 的 <code>Read</code> 方法获取到的是 <code>slice</code> 中第一个元素的内容……也就是说，<code>MultiReader</code> 只是逻辑上将多
个 <code>Reader</code> 组合起来，并不能通过调用一次 <code>Read</code> 方法获取所有 <code>Reader</code> 的内容。在所有的 <code>Reader</code> 内容都被读
完后，<code>Reader</code> 会返回 <code>EOF</code>。</p>
<p><strong>MultiWriter 的使用</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Create</span>(<span style="color:#e6db74">&#34;tmp.txt&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writers</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">file</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">MultiWriter</span>(<span style="color:#a6e22e">writers</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">Write</span>([]byte(<span style="color:#e6db74">&#34;Go语言中文网&#34;</span>))
</span></span></code></pre></div><p>这段程序执行后在生成 <code>tmp.txt</code> 文件，同时在文件和屏幕中都输出：<code>Go语言中文网</code>。这和 Unix 中的 tee 命令类似。</p>
<h2 id="teereader-函数">
  TeeReader 函数
  <a class="anchor" href="#teereader-%e5%87%bd%e6%95%b0">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TeeReader</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">w</span> <span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">Reader</span>
</span></span></code></pre></div><blockquote>
<p><code>TeeReader</code> 返回一个 <code>Reader</code>，它将从 <code>r</code> 中读到的数据写入 <code>w</code> 中。所有经由它处理的从 <code>r</code> 的读取都匹配于对应的对 <code>w</code> 的写入。它没
有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。</p>
</blockquote>
<p>也就是说，我们通过 <code>Reader</code> 读取内容后，会自动写入到 <code>Writer</code> 中去。例子代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">TeeReader</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Go语言中文网&#34;</span>), <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Read</span>(make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">20</span>)) <span style="color:#75715e">// Go语言中文网
</span></span></span></code></pre></div><p>这种功能的实现其实挺简单，无非是在 <code>Read</code> 完后执行 <code>Write</code>。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/shipengqi/golang-learn/commit/44c3ee763ef8b1ef68e8f73c9152c5aa565995fc" title='Last modified by shipengqi | October 7, 2023' target="_blank" rel="noopener">
      <img src="/golang-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>October 7, 2023</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/golang-learn/edit/master/content/content/docs/standards/io/io.md" target="_blank" rel="noopener">
      <img src="/golang-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#io">io</a>
      <ul>
        <li><a href="#reader">Reader</a></li>
        <li><a href="#writer">Writer</a></li>
        <li><a href="#实现了-ioreader-接口或-iowriter-接口的类型">实现了 io.Reader 接口或 io.Writer 接口的类型</a></li>
        <li><a href="#readerat-和-writerat">ReaderAt 和 WriterAt</a></li>
        <li><a href="#readerfrom-和-writerto">ReaderFrom 和 WriterTo</a></li>
        <li><a href="#seeker">Seeker</a></li>
        <li><a href="#closer">Closer</a></li>
        <li><a href="#其他接口">其他接口</a>
          <ul>
            <li><a href="#bytereader-和-bytewriter">ByteReader 和 ByteWriter</a></li>
            <li><a href="#bytescannerrunereader-和-runescanner">ByteScanner、RuneReader 和 RuneScanner</a></li>
            <li><a href="#readcloserreadseekerreadwritecloserreadwriteseekerreadwriterwritecloser-和-writeseeker">ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker</a></li>
          </ul>
        </li>
        <li><a href="#sectionreader-类型">SectionReader 类型</a></li>
        <li><a href="#limitedreader-类型">LimitedReader 类型</a></li>
        <li><a href="#pipereader-和-pipewriter-类型">PipeReader 和 PipeWriter 类型</a></li>
        <li><a href="#copy-和-copyn-函数">Copy 和 CopyN 函数</a></li>
        <li><a href="#readatleast-和-readfull-函数">ReadAtLeast 和 ReadFull 函数</a></li>
        <li><a href="#writestring-函数">WriteString 函数</a></li>
        <li><a href="#multireader-和-multiwriter-函数">MultiReader 和 MultiWriter 函数</a></li>
        <li><a href="#teereader-函数">TeeReader 函数</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












