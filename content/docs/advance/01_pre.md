---
title: 前置知识
weight: 1
---

## 计算机为什么需要内存

计算机是运行程序的载体，进程由可执行代码被执行后产生。那么计算机在运行程序的过程中为什么需要内存呢？

### 代码的本质

简单来看代码主要包含两部分：

- 指令部分：中央处理器 CPU 可执行的指令
- 数据部分：常量等

代码包含了指令，代码被转化为可执行二进制文件，被执行后加载到内存中，中央处理器 CPU 通过内存获取指令：

![code-in-memory](https://raw.gitcode.com/shipengqi/illustrations/files/main/go/code-in-memory.png)

### 程序的运行过程

可执行代码文件被执行之后，代码中的待执行指令被加载到了内存当中。

CPU 执行指令可以简单的分为三步：

1. 取指：CPU 控制单元从内存中获取指令
2. 译指：CPU 控制单元解析从内存中获取指令
3. 执行：CPU 运算单元负责执行具体的指令操作

### 内存的作用

- 暂存二进制可执行代码文件中的指令、预置数据(常量)等
- 暂存指令执行过程中的中间数据
- 等等

### 为什么需要栈内存

进程在运行过程中会产生很多临时数据，要关注两个问题：

- 内存的分配
- 内存的回收

最简单、高效地分配和回收方式**线性分配**。线性分配分配的内存是一段连续的区域。栈内存就是使用线性分配的方式进行内存管理的。

**栈内存**的简易管理过程：

1. 栈内存分配逻辑：current - alloc

![mem-alloc](https://raw.gitcode.com/shipengqi/illustrations/files/main/go/mem-alloc.png)

2. 栈内存释放逻辑：current + alloc

![mem-release](https://raw.gitcode.com/shipengqi/illustrations/files/main/go/mem-release.png)

通过利用**栈内存**，**CPU 在执行指令过程中可以高效的存储临时变量**。其次：

- 栈内存的分配过程：类似**栈**的**入栈**过程。
- 栈内存的释放过程：类似**栈**的**出栈**过程。

![mem-stack](https://raw.gitcode.com/shipengqi/illustrations/files/main/go/mem-stack.png)

**栈内存的分配和释放类似一个栈结构，所以叫做栈内存**。

### 为什么需要堆内存

如果函数 A 内的变量 `too` 是个指针且被函数外的代码依赖，如果 `too` 变量指向的内存被回收了，那么这个指针就成了野指针不安全。

**什么是野指针？**

**野指针就是指向一个已被释放的内存地址的指针**。野指针指向的内存地址**可能是其他变量的内存地址，也可能是无效的内存地址**。野指针指向的内存地址可能会被其他程序占用，也可能会被操作系统回收。如果程序继续访问野指针指向的内存地址，就会导致程序崩溃或者数据错误。

怎么解决这个问题？

这就是**堆内存**存在的意义，Go 语言会在代码编译期间通过**逃逸分析**把**分配在栈上的变量分配到堆上去**。**堆内存再通过垃圾回收器回收**。

![mem-escape](https://raw.gitcode.com/shipengqi/illustrations/files/main/go/mem-escape.png)


### 虚拟内存

程序实际操作的都是虚拟内存，最终由 CPU 通过内存管理单元 MMU (Memory Manage Unit) 把虚拟内存的地址转化为实际的物理内存地址。

虚拟内存是一种内存管理技术，它：

- 为**每个进程提供独立的、连续的地址空间**
- 防止了进程直接对物理内存的操作 (如果进程可以直接操作物理内存，那么存在某个进程篡改其他进程数据的可能)
- 提升物理内存的利用率，当进程真正要使用物理内存时再分配
- 通过分页机制将虚拟地址映射到物理地址
- 虚拟内存和物理内存是通过 MMU (管理单元内存 Memory Management Unit) 映射的

对于 **Go，不管是栈内存还是堆内存，都是对虚拟内存的操作**。

### 内存管理组成部分

内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）。

- **用户程序**：用户程序是指正在运行的程序，它可以是一个操作系统、一个数据库系统、一个 Web 浏览器等等。用户程序需要访问内存来存储数据和执行指令。
- **分配器**：分配器会负责从堆中初始化相应的内存区域（栈内存是由编译器自动分配回收的）。
- **收集器**：负责回收堆中不再使用的对象和内存空间。

## 寄存器

寄存器是 CPU 内部的存储单元，用于存放从**内存读取而来的数据（包括指令）和 CPU 运算的中间结果**。

之所以要使用寄存器来临时存放数据而不是直接操作内存，一是因为 CPU 的工作原理决定了**有些操作运算只能在 CPU 内部进行**，二是因为 **CPU 读写寄存器的速度比读写内存的速度快得多**。

{{< callout type="info" >}}
寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 **CPU 上下文**。
{{< /callout >}}

CPU 厂商为每个寄存器都取了一个名字，比如 AMD64 CPU 中的 rax, rbx, rcx, rdx 等等，这样就可以很方便的在汇编代码中使用寄存器的名字来进行编程。

示例，Go 代码：

```go
c = a + b
```

在 AMD64 Linux 平台下，使用 go 编译器编译它可得到如下 `AT&T` 格式的汇编代码：

```asm
mov (%rsp),%rdx     # 把变量 a 的值从内存中读取到寄存器 rdx 中
mov 0x8(%rsp),%rax  # 把变量 b 的值从内存中读取到寄存器 rax 中
add %rdx,%rax       # 把寄存器 rdx 和 rax 中的值相加，并把结果放回 rax 寄存器中
mov %rax,0x10(%rsp) # 把寄存器 rax 中的值写回变量 c 所在的内存
```

上面的一行 go 语言代码被编译成了 4 条汇编指令，指令中出现的 rax，rdx 和 rsp 都是寄存器的名字（`AT&T`格式的汇编代码中所有寄存器名字前面都有一个 `%`符号）。

**汇编代码**其实比较简单，它所做的工作不外乎就是**把数据在内存和寄存器中搬来搬去或做一些基础的数学和逻辑运算**。

不同体系结构的CPU，其内部寄存器的数量、种类以及名称可能大不相同。

以 AMD64 架构的 CPU 为例，常用的三类寄存器：

1. **通用寄存器**：用来存放一般性的数据，用途没有做特殊规定，程序员和编译器可以自定义其用途。

  16 个通用寄存器，分别是：

  - rax, rbx, rcx, rdx
  - rsp（栈顶寄存器）, rbp（栈基址寄存器）
  - rsi, rdi
  - r8, r9, r10, r11, r12, r13, r14, r15

2. **程序计数寄存器（rip）**：也叫做 PC 寄存器或者 IP 寄存器。**存放下一条即将执行的指令的地址**。
3. **段寄存器**：fs 和 gs 寄存器。**一般用它来实现线程本地存储（TLS）**

除了 fs 和 gs 段寄存器是 16 位的，其它都是 64 位的，也就是 8 个字节，其中的 16 个通用寄存器还可以作为 `32/16/8` 位寄存器使用。只是使用时需要换一个名字，比如可以用 eax 这个名字来表示一个 32 位的寄存器，它使用的是 rax 寄存器的低 32 位。

### 程序计数寄存器（rip）

rip 寄存器里面存放的是 CPU 即将执行的下一条指令在内存中的地址。例如下面的汇编代码：

```asm
0x0000000000400770:    add %rdx,%rax
0x0000000000400773:    mov $0x0,%ecx
```

假设当前 CPU 正在执行第一条指令，这条指令在内存中的地址是 `0x0000000000400770`，紧接它后面的下一条指令的地址是 `0x0000000000400773`，所以此时 rip 寄存器里面存放的值是 `0x0000000000400773`。

**rip 寄存器的值是 CPU 自动控制的，CPU 也提供了几条可以间接修改 rip 寄存器的指令**。

### 栈顶寄存器（rsp）和栈基址寄存器（rbp）

rsp 寄存器一般用来存放函数调用栈的栈顶地址，而 rbp 寄存器通常用来存放函数的栈帧起始地址，编译器一般**使用这两个寄存器加一定偏移的方式来访问函数局部变量或函数参数**。

#### 函数栈帧

1. 每个未运行完的函数都有对应的栈帧。
2. 栈帧保存了函数的额返回地址和局部变量。

#### 栈帧创建于销毁过程

假设代码：

```cpp
#include<stdio.h>
 
int add(int a, int b)
{
	int c = 0;
	c = a + b;
	return c;
}
 
int main()
{
	int a = 1;
	int b = 1;
	int sum;
	sum = add(a, b);
	return 0;
}
```

调用 `add(a, b)` 之前，栈的情况如下：

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/rbp-rsp.png" alt="rbp-rsp" width="280px">

1. 函数调用涉及到传参，因此**在调用函数之前，需要先将传入的参数保存**，以方便函数的调用，因此需要将 `add` 函数的 `a=1`，`b=2` 入栈保存。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-before.png" alt="add-before" width="280px">

2. 函数调用前，要创建新的栈帧，rsp 和 rbp 都要改变，为了**函数调用结束后，栈顶恢复到调用前的位置，因此需要先将 rbp 寄存器的值保存到栈中**。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-save-rbp.png" alt="add-save-rbp" width="280px">

3. 创建创建所需调用函数的栈帧，使 rbp 指向当前 rsp 的位置，根据 `add` 函数的参数个数，创建合适的栈帧大小。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-change-rbp.png" alt="add-change-rbp" width="280px">

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-create-stack.png" alt="add-create-stack" width="280px">

4. 保存局部变量。将 `add` 函数中创建的变量 `int c = 0` 放入刚刚开辟的栈帧空间中。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-save-var.png" alt="add-save-var" width="280px">

5. 参数运算。根据形参与局部变量，进行对应的运算，这里执行 `c = a + b`, 得到 `c = 2`,放入刚才 `c` 对应的位置。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-calc.png" alt="add-calc" width="280px">

6. 函数返回。`add` 函数执行完成，需要将 `add` 创建的函数栈销毁，以返回到 `main` 函数中继续执行。在销毁 `add` 函数栈之前，要先将 `add` 函数的返回值 `c = 2` 保存起来，存储到 rax 寄存器中。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-save-result.png" alt="add-save-result" width="380px">

7. 销毁 `add` 函数栈。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-destroy-stack.png" alt="add-destroy-stack" width="380px">

8. rbp 寄存器拿到之前存储的上一栈帧栈底的值，回到相应的位置，于此同时，栈空间内存储的 rbp 的值没有用了，也将被销毁。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-destroy-rbp.png" alt="add-destroy-rbp" width="380px">

9. 销毁形参。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/add-destroy-arg.png" alt="add-destroy-arg" width="380px">

10. `main` 函数拿到返回值。`main` 函数是一个函数，它有自己的栈帧。因此所谓的前一栈帧实际上就是调用 `add` 函数的 `main` 函数的栈帧。因此要让 `main` 函数拿到返回值，只需要把 rax 寄存器中的值放入 `main` 栈帧中 `sum` 对应的位置就行。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/main-stack.png" alt="main-stack" width="380px">

绿色部分就是 `main` 函数的栈帧。至此栈帧的创建与销毁结束，函数调用完成。

## 汇编

汇编语言也是一门计算机编程语言。汇编指令是汇编语言的一部分，**汇编指令和机器指令一一对应，每一条汇编指令都对应着一条机器指令**。机器指令是二进制格式的，汇编指令使用符号来表示机器指令。

不同的 CPU 所支持的机器指令不一样，所以其汇编指令也不同，即使是相同的 CPU，不同的汇编工具和平台所使用的汇编指令格式也有些差别。

汇编指令：

```asm
0x0000000000400770:    add %rdx,%rax
```

编译成机器指令：

```bash
(gdb) x/3xb 0x40054d
0x40054d: 0x48    0x01    0xd0 # 机器指令
(gdb)
```

### 汇编指令格式

每一条汇编指令通常都由两部分组成：

1. 操作码：作码指示 CPU 执行什么操作，比如是执行加法，减法还是读写内存。每条指令都必须要有操作码。
2. 操作数：操作数表示指令的操作对象。比如加法操作需要两个加数，这两个加数就是这条指令的操作数。操作数的个数一般是 0 个，1 个或 2 个。

### 汇编指令示例

1. `add %rdx,%rax`：将 `rdx` 寄存器中的值加到 `rax` 寄存器中。
  - `add`，表示执行加法操作，它有两个操作数，`rdx` 和 `rax`。
  - 如果一条指令有两个操作数，那么第一个操作数叫做**源操作数**，第二个操作数叫做**目的操作数**，目的操作数表示这条指令执行完后结果应该保存的地方。
  - 第二个操作数 `rax` 寄存器既是源操作数也是目的操作数，因为 `rax` 既是加法操作的两个加数之一，又得存放加法操作的结果。
  - 指令执行完后 `rax` 寄存器的值发生了改变，指令执行前的值被覆盖而丢失了，如果 `rax` 寄存器之前的值还有用，那么就得先用指令把它保存到其它寄存器或内存之中。
2. `callq 0x400526`：调用函数，只有一个操作数，操作数是 `0x400526`，它是被调用函数的地址。
3. `retq`：没有操作数，表示从被调用函数返回到调用函数继续执行。

### 常用指令

#### mov

复制源操作数到目的操作数。例：

```asm
mov %rsp,%rbp      # 直接寻址，把 rsp 的值拷贝给 rbp，相当于 rbp = rsp
```

#### add/sub 指令

加减运算指令。例：

```asm
sub $0x350,%rsp      # 源操作数是立即操作数，目的操作数直接寻址。rsp = rsp - 0x350
add %rdx,%rax        # 直接寻址。rax = rax + rdx
```

`$` 符号做前缀，这种操作数叫做**立即操作数**，表示它是一个常量。

#### call/ret 指令

- `call 目标地址` 指令执行函数调用，CPU 执行 `call` 指令时首先会把 rip 寄存器中的值入栈，然后设置 rip 值为目标地址，又因为 rip 寄存器决定了下一条需要执行的指令，所以当 CPU 执行完当前 `call` 指令后就会跳转到目标地址去执行（先把当前 rip 寄存器的值保存起来，因为要调用函数，所以把函数的目的地址放到 rip 寄存器中，这样 CPU 就可以跳转去执行目标地址的函数）。
- `ret` 指令从被调用的函数返回调用函数，它的实现原理是把 `call` 指令入栈的返回地址弹出给 rip 寄存器。

```
# 调用函数片段
0x0000000000400559: callq 0x400526 <sum>
0x000000000040055e: mov   %eax,-0x4(%rbp)
--------------------------------------------------
# 被调用函数片段
0x0000000000400526: push   %rbp
......
0x000000000040053f: retq  
```

##### 函数调用过程

调用函数使用 `callq  0x400526` 指令调用 `0x400526` 处的函数，`0x400526` 是被调用函数的第一条指令所在的地址。`0x40055e` 会先从 rip 寄存器中取出入栈，然后把 rip 寄存器的值更新为 `0x400526`。被调用函数在 `0x40053f` 处执行 `retq` 指令返回调用函数继续执行 `0x40055e` 地址处的指令。

#### jmp/je/jle/jg/jge 等等 j 开头的指令

这些都属于跳转指令，**操作码后面直接跟要跳转到的地址或存有地址的寄存器**，这些指令与高级编程语言中的 `goto` 和 `if` 等语句对应。用法示例：

```asm
jmp   0x4005f2
jle   0x4005ee
jl    0x4005b8
```

#### push/pop 指令

专用于函数调用栈的入栈出栈指令，**这两个指令都会自动修改 rsp 寄存器**。

```asm
push  源操作数
pop   目的操作数
```

`push` 入栈时 rsp 寄存器的值先减去 8 把栈位置留出来（移动栈顶指针，因为是由高位到低位，所以是减 8），然后把操作数复制到 rsp 所指位置。

`push` 指令相当于：

```asm
sub   $8,%rsp
mov  源操作数,(%rsp)
```

`pop` 指令相当于：

```asm
mov( %rsp), 目的操作数
add $8,%rsp
```

#### leave 指令

`leave` 指令没有操作数，它一般放在函数的尾部 `ret` 指令之前，用于调整 rsp 和 rbp，这条指令相当于：

```asm
mov %rbp,%rsp
pop %rbp
```

## Go 汇编

### Go 汇编寄存器

Go 汇编格式跟前面讨论过的 AT&T 汇编基本上差不多。

Go 汇编语言中使用的寄存器的名字与 AMD64 汇编中的寄存器的名字不一样，它们之间的对应关系如下：

| go 寄存器 | amd64 寄存器 |
| --------- | ------------ |
| AX        | rax         |
| BX        | rbx         |
| CX        | rcx         |
| DX        | rdx         |
| SI        | rsi         |
| DI        | rdi         |
| SP        | rsp         |
| BP        | rbp         |
| PC        | rip         |
| `R8 ~ R15`        | `r8 ~ r15`   |

Go 汇编还引入了几个没有任何硬件寄存器与之对应的**虚拟寄存器**。这些寄存器一般用来存放内存地址。

## 系统调用

Linux 按照特权等级，把进程的运行空间分为**内核空间**和**用户空间**，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。

![system-kernel]()

- **内核空间（Ring 0）具有最高权限，可以直接访问所有资源**；
- **用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源**。

**系统调用是指使用类似函数调用的方式调用操作系统提供的 API**。

本质是**用户程序通过特定机制（如软中断或专用指令）将控制权交给操作系统内核，由内核执行特权操作**。

系统调用的执行分为两部分：

1. 用户程序发起请求

通过软中断或专用指令（如 `syscall`）触发内核的介入。

不是直接执行内核代码，而是**通过中断/指令通知内核：“请帮我执行某个特权操作”**。


2. 内核执行实际操作

CPU 切换到内核态后，内核**根据系统调用号**（如 `SYS_read`）从系统调用表中**找到对应的内核函数（如 `sys_read`）**。

内核函数由操作系统实现，直接操作硬件或管理资源（例如从磁盘读取数据到内存）。

**执行完毕后，内核将结果返回给用户程序**。

### 系统调用的过程有没有发生 CPU 上下文的切换？

答案是肯定的。

1. CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。
2. 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。

所以，**一次系统调用的过程，其实是发生了两次 CPU 上下文切换（用户态切换到内核态，内核态切换回用户态）**。

**系统调用过程通常称为特权模式切换，而不是上下文切换**。系统调用过程中，CPU 的上下文切换还是无法避免的。

### Go 系统调用

Go 语言的标准库（如 `os`、`net`、`syscall`）封装了系统调用，但其底层实现涉及：

- 用户代码调用标准库（如 `os.Read`、`net.Dial`）。
- 标准库调用 `syscall` 包，封装系统调用号（如 `SYS_READ`、`SYS_WRITE`）。
- Go Runtime 介入，处理系统调用的阻塞和调度问题。

## 操作系统进程调度

Go goroutine 的调度系统是建立在操作系统线程之上的。

### 进程在什么时候才会被调度到 CPU 上运行？

1. 为了保证所有进程可以得到公平调度，**CPU 时间被划分为一段段的时间片**，这些时间片再被轮流分配给各个进程。这样，当**某个进程的时间片耗尽了，就会被系统挂起（就绪态，Ready），切换到其它正在等待 CPU 的进程运行**。

2. **进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行**，这个时候进程也会被挂起（**阻塞态，Blocked**），并由系统调度其他进程运行。

3. 当进程通过睡眠函数 `sleep` 这样的方法将自己主动挂起时（**可中断的阻塞态，Interruptible Sleep**），自然也会重新调度。

4. 当有优先级更高的进程运行时，**为了保证高优先级进程的运行，当前进程会被挂起（就绪态，Ready）**，由高优先级进程来运行。

5. 发生硬件中断时，CPU 上的进程会被中断挂起（**可能有两种状态，时间片耗尽了就是就绪态，如果在等待资源，就会进入阻塞态**），转而执行内核中的中断服务程序。

### 时钟中断与时间片

时钟中断（Timer Interrupt）是操作系统中的一个重要机制，它由硬件定时器定期触发。

时钟中断是实现时间片机制的基础：

- 每次时钟中断都会检查当前进程是否已用完时间片
- 如果用完，则触发进程切换（上下文切换）
- 否则，允许进程继续执行

### 进程上下文切换

进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。

进程的上下文切换比系统调用时多了一步：

1. 保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；
2. 加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

{{< callout type="info" >}}
**每次上下文切换都需要几十纳秒到数微秒的 CPU 时间**。这个时间还是相当可观的，特别是在**进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上**，进而大大缩短了真正运行进程的时间。
{{< /callout >}}

### 线程上下文切换

线程与进程最大的区别在于，**线程是调度的基本单位，而进程则是资源拥有的基本单位**。

所谓**内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源**。

- 当进程只有一个线程时，可以认为进程就等于线程。
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
- 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

线程的上下文切换其实就可以分为两种情况：

1. **两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样**。
2. **两个线程属于同一个进程**。此时，因为虚拟内存是共享的，所以在**切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**。

### 中断上下文切换

为了快速**响应硬件的事件，中断处理会打断进程的正常调度和执行**，转而调用中断处理程序，响应设备事件。而在**打断其他进程时，就需要将进程当前的状态保存下来**，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

**中断上下文切换并不涉及到进程的用户态**。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。**中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等**。


**对同一个 CPU 来说，中断处理比进程拥有更高的优先级**。所以中断上下文切换并不会与进程上下文切换同时发生。

跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。