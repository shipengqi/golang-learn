---
title: 内存分配
weight: 1
---

## 内存分配器

编程语言的内存分配器一般包含两种分配方法：

- **线性分配器**（Sequential Allocator，Bump Allocator）
- **空闲链表分配器**（Free-List Allocator）

### 线性分配器

线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。使用线性分配器时，只需要**在内存中维护一个指向内存特定位置的指针**，用户程序向分配器申请内存时，分配器只需要**检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置**。

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/bump-allocator.png" alt="bump-allocator" width="80%">

虽然**线性分配器实现为它带来了较快的执行速度以及较低的实现复杂**度，但是线性分配器**无法在内存被释放时重用内存**。

如下图，红色部分是已经被回收的内存，但是无法重新利用：

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/bump-allocator-reclaim-memory.png" alt="bump-allocator-reclaim-memory" width="80%">

所以线性分配器需要与合适的垃圾回收算法配合使用，例如：标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法。它们可以**通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并**，这样就能利用线性分配器的效率提升内存分配器的性能了。

因为线性分配器需要与具有**拷贝特性的垃圾回收算法**配合，所以 C 和 C++ 等需要**直接对外暴露指针的语言就无法使用线性分配器**。

### 空闲链表分配器

空闲链表分配器（Free-List Allocator）**可以重用已经被释放的内存**，它在内部会维护一个**类似链表的数据结构**。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表。

不同的内存块通过指针构成了链表，所以使用这种方式的分配器可以重新利用回收的资源，但是因为**分配内存时需要遍历链表，所以它的时间复杂度是 `O(n)`**。

空闲链表分配器选择内存块的策略：

- 首次适应（First-Fit）：**从链表头开始遍历**，选择第一个大小**大于申请内存**的内存块；
- 循环首次适应（Next-Fit）：**从上次遍历的结束位置开始遍历**，选择第一个大小**大于申请内存**的内存块；
- 最优适应（Best-Fit）：从链表头遍历整个链表，选择**最合适的**内存块；
- **隔离适应（Segregated-Fit）：将内存分割成多个链表，每个链表中的内存块大小相同，根据申请的内存大小选择不同的链表**。

**隔离适应策略**：

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/segregated-fit.png" alt="segregated-fit" width="80%">

该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当向内存分配器申请 8 字节的内存时，它找到满足条件的空闲内存块并返回。**隔离适应的分配策略减少了需要遍历的内存块数量**，提高了内存分配的效率。

### 分级分配 

Go 语言的内存分配器借鉴了线程缓存分配（Thread-Caching Malloc，TCMalloc）的设计。核心理念是**使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略**。

Go 运行时根据对象的大小将对象分成微对象、小对象和大对象三种：

| 类别 | 大小 |
| --- | --- |
| 微对象 | `(0, 16B)` |
| 小对象 | `[16B, 32KB]` |
| 大对象 | `(32KB, +∞)` |

**程序中的绝大多数对象的大小都在 32KB 以下**，所以**分别处理大对象和小对象**有利于**提高内存分配器的性能**。

#### 多级缓存 

内存分配器还会将内存分成不同的级别分别管理，TCMalloc 和 Go 运行时分配器都会引入**线程缓存**（Thread Cache）、**中心缓存**（Central Cache）和**页堆**（Page Heap）三个组件分级管理内存：

<img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/multi-level-cache.png" alt="multi-level-cache" width="50%">

- **线程缓存**：每个线程都有一个线程缓存，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。
- **中心缓存**：当线程缓存不能满足需求时，运行时会使用中心缓存作为**补充解决小对象的内存分配**。
- **页堆**：遇到 32KB 以上的对象时，内存分配器会选择页堆直接分配大内存。

### 虚拟内存布局

Go 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。

### Go 1.10 的线性内存

Go 在程序启动的时候，会先向操作系统申请一块内存（这只是一段虚拟的地址空间，并不会真正地分配内存），包括三个区域 `spans`、`bitmap` 和 `arena` 分别预留了 512MB、16GB 以及 512GB 的内存空间：

![go-heap-1.10]()

- `spans`：存储了 `runtime.mspan`（内存管理单元）的指针，**每个内存单元会管理几页的内存空间，每页大小为 8KB**；
- `bitmap`：用于标识 `arena` 区域中的那些地址保存了对象，**位图中的每个字节都会表示堆区中的 32 字节是否空闲**；
- `arena`：真正的堆区，运行时会将 8KB 看做一页，**这些内存页中存储了所有在堆上初始化的对象**；

找到任意一个地址对应的 ``runtime.mspan`：

1. 根据 `arena` 的基地址计算该地址所在的页号。
2. 通过 `mheap.spans` 数组获得管理该片内存的管理单元 `runtime.mspan`（`mheap_.spans[page]` 页号就是数组的索引）。

Go 在垃圾回收时会根据指针的地址判断对象是否在堆中，并通过上面的方式到管理该对象的 `runtime.mspan`。但是这种方式又一个前提，就是**堆区的内存必须是连续的**。

线性堆内存的问题：

1. 分配的内存地址会发生冲突，导致堆的初始化和扩容失败；
2. 没有被预留的大块内存可能会被分配给 C 语言的二进制，导致扩容后的堆不连续；

{{< callout type="info" >}}
- 线性的堆内存需要预留大块的内存空间，但是申请大块的内存空间而不使用太浪费了。
- 不预留内存空间的话在特殊场景下造成程序崩溃。
{{< /callout >}}

### Go 1.11 的稀疏内存方案

使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。但是基于稀疏内存的内存管理失去了内存的连续性这一特征，使内存管理变得更加复杂：

![go-heap-1.11]()

使用一个 `runtime.heapArena` 数组管理所有内存。每个 `runtime.heapArena` 管理 64MB 的内存。

```go
type heapArena struct {
	bitmap       [heapArenaBitmapBytes]byte
	spans        [pagesPerArena]*mspan
	pageInUse    [pagesPerArena / 8]uint8
	pageMarks    [pagesPerArena / 8]uint8
	pageSpecials [pagesPerArena / 8]uint8
	checkmarks   *checkmarksMap
	zeroedBase   uintptr
}
```

- `heapArena` 中的 `bitmap` 和 `spans` 和线性内存中的意思一样。
- `zeroedBase` 字段指向了该结构体管理的内存的基地址。

上述设计将原有**的连续大内存切分成稀疏的小内存，而用于管理这些内存的元信息也被切成了小块**。

### 地址空间

所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下四种状态：

- `None`：内存没有被保留或者映射，是地址空间的默认状态。
- `Reserved`：运行时持有该地址空间，但是访问该内存会导致错误。
- `Prepared`：可以快速转换到 `Ready` 状态。
- `Ready`：可以被安全访问。


## 内存管理器的数据结构

https://juejin.cn/post/7135670650353483783

### msapn

```go
type mspan struct {
	next *mspan
	prev *mspan
    
    // ...

    // 该 span 管理的页数
	npages uintptr
}
```

**`mspan` 是由 N 个且连续的 page 组成**，可以是一个 page，也可以是 2 个、3 个或者更多。`npages` 就代表了这个 `mspan` 是由几个连续的 page 组成。

#### mspan 链表

**只有 `npages` 的值相同的 `mspan` 互相才可以组成一个链表**。

#### Go 是按页 page 8KB 为最小单位分配内存的吗？

不是，如果这样的话会导致内存使用率不高。Go 内存管理器会把 `mspan` 再拆解为更小粒度的单位 object。















## Go 内存管理

函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。

## 基本策略

Go 的内存分配用的是 tcmalloc 架构，tcmalloc 是为并发而设计的高性能内存分配组件。

1. 每次从操作系统申请一大块内存（如 1MB），以减少系统调用。
2. 将申请到的大块内存按照特定大小切分成小块，够成链表。
3. 为对象分配内存时，只需从大小合适的链表提取一小块即可。
4. 回收对象内存时，将小块内存还给原链表，以便复用。
5. 如果闲置内存过多，则尝试把部分内存还给操作系统，降低开销。

> **内存分配器**只管理内存，不关心对象的状态，并且它不会主动回收内存，需要**垃圾回收器**在完成清理操作后，
触发内存分配器的回收操作。

## 内存块

内存分配器管理的内存分为两种：

- **span**：多个地址连续的**页**（page）组成的大块内存。
- **object**：将 span 按特定大小切分成多个小块，每个小块可存储一个对象。

分配器按页数区分大小不同的 span。例如，以页数为单位将 span 存放到管理数组中，需要时就以页数为索引进行查找。
span 的大小不是固定不变的。在获取闲置 span 时，如果没有找到大小合适的，那么会选择页数更多的 span，此时
就会引发**裁剪**，将 span 多余的部分构成一个新的小的 span 放回管理数组。另外，分配器还会把相邻的空闲的
 span 合并构建更大的内存块，减少碎片。

## tcmalloc

Go 的内存分配器采用的是 tcmalloc 架构。

由三种组件组成：

- **cache**：运行期的每个线程都会绑定一个 cache，用于给没有锁的 object 的分配。
- **central**：为所有 cache 提供切分好的后备 sapn 资源。
- **heap**：管理闲置的 span，需要的时候向操作系统申请新的内存。

## 回收

**内存回收的源头是垃圾清理操作**。**回收不是释放**，因为内存分配器的核心是**内存复用**。不再使用的内存，放到合适的位置等待再次
分配时使用。只有闲置内存过多时，才考虑释放。

回收操作以 span 为单位。

## 释放

监控线程 sysmon 每隔一段时间就会检查 heap 里的闲置内存块，如果闲置时间超过阈值，则释放其关联的物理内存。
