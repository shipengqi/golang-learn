[{"id":0,"href":"/golang-learn/docs/practice/01_build/","title":"Go ç¼–è¯‘","section":"ğŸ› ï¸ å®è·µ","content":" Go ç¼–è¯‘ # æ¡ä»¶ç¼–è¯‘ # Go æ”¯æŒä¸¤ç§æ¡ä»¶ç¼–è¯‘æ–¹å¼ï¼š\nç¼–è¯‘æ ‡ç­¾ï¼ˆbuild tagï¼‰ æ–‡ä»¶åç¼€ ç¼–è¯‘æ ‡ç­¾ # ç¼–è¯‘æ ‡ç­¾çš„è§„åˆ™ï¼š\nç©ºæ ¼è¡¨ç¤ºï¼šAND é€—å·è¡¨ç¤ºï¼šOR ! è¡¨ç¤ºï¼šNOT æ¢è¡Œè¡¨ç¤ºï¼šAND æ¯ä¸ªæ¡ä»¶é¡¹çš„åå­—ç”¨ \u0026ldquo;å­—æ¯+æ•°å­—\u0026rdquo; è¡¨ç¤ºã€‚ä¸»è¦æ”¯æŒä»¥ä¸‹å‡ ç§æ¡ä»¶ï¼š\næ“ä½œç³»ç»Ÿï¼Œä¾‹å¦‚ï¼šwindowsã€linux ç­‰ï¼Œå¯¹åº” runtime.GOOS çš„å€¼ã€‚ è®¡ç®—æœºæ¶æ„ï¼Œä¾‹å¦‚ï¼šamd64ã€386ï¼Œå¯¹åº” runtime.GOARCH çš„å€¼ã€‚ ç¼–è¯‘å™¨ï¼Œä¾‹å¦‚ï¼šgccgoã€gcï¼Œæ˜¯å¦å¼€å¯ CGO,cgoã€‚ Go ç‰ˆæœ¬ï¼Œä¾‹å¦‚ï¼šgo1.19ã€go1.20 ç­‰ã€‚ è‡ªå®šä¹‰çš„æ ‡ç­¾ï¼Œä¾‹å¦‚ï¼šç¼–è¯‘æ—¶é€šè¿‡æŒ‡å®š -tags ä¼ å…¥çš„å€¼ã€‚ //go:build ignoreï¼Œç¼–è¯‘æ—¶è‡ªåŠ¨å¿½ç•¥è¯¥æ–‡ä»¶ go:build ä¹‹åå¿…é¡»æœ‰ç©ºè¡Œï¼Œå¦åˆ™ä¼šè¢«ç¼–è¯‘å™¨å½“åšæ™®é€šæ³¨é‡Šã€‚\n//go:build linux,386 darwin,!cgo package testpkg è¿ç®—è¡¨è¾¾å¼ä¸ºï¼š(linux \u0026amp;\u0026amp; 386) || (darwin \u0026amp;\u0026amp; !cgo)ã€‚\nè‡ªå®šä¹‰ tag åªéœ€è¦åœ¨ go build æŒ‡ä»¤åç”¨ -tags æŒ‡å®šç¼–è¯‘æ¡ä»¶å³å¯\ngo build -tags mytag1 mytag2 å¯¹äº -tagsï¼Œå¤šä¸ªæ ‡ç­¾æ—¢å¯ä»¥ç”¨é€—å·åˆ†éš”ï¼Œä¹Ÿå¯ä»¥ç”¨ç©ºæ ¼åˆ†éš”ï¼Œä½†å®ƒä»¬éƒ½è¡¨ç¤º\u0026quot;ä¸\u0026quot;çš„å…³ç³»ã€‚æ—©æœŸ go ç‰ˆæœ¬ç”¨ç©ºæ ¼åˆ†éš”ï¼Œåæ¥æ”¹æˆäº†ç”¨é€—å·åˆ†éš”ï¼Œä½†ç©ºæ ¼ä¾ç„¶å¯ä»¥è¯†åˆ«ã€‚\n-tags ä¹Ÿæœ‰ ! è§„åˆ™ï¼Œå®ƒè¡¨ç¤ºçš„æ˜¯æ²¡æœ‰è¿™ä¸ªæ ‡ç­¾ã€‚\n//go:build !hello go build -tags=!hello æ–‡ä»¶åç¼€ # è¿™ä¸ªæ–¹æ³•é€šè¿‡æ”¹å˜æ–‡ä»¶åçš„åç¼€æ¥æä¾›æ¡ä»¶ç¼–è¯‘ï¼Œå¦‚æœä½ çš„æºæ–‡ä»¶åŒ…å«åç¼€ï¼š_GOOS.goï¼Œé‚£ä¹ˆè¿™ä¸ªæºæ–‡ä»¶åªä¼šåœ¨è¿™ä¸ªå¹³å°ä¸‹ç¼–è¯‘ï¼Œ_GOARCH.go ä¹Ÿæ˜¯å¦‚æ­¤ã€‚è¿™ä¸¤ä¸ªåç¼€å¯ä»¥ç»“åˆåœ¨ä¸€èµ·ä½¿ç”¨ï¼Œä½†æ˜¯è¦æ³¨æ„é¡ºåºï¼š_GOOS_GOARCH.goï¼Œ ä¸èƒ½åè¿‡æ¥ç”¨ã€‚ ä¾‹å¦‚ï¼š\nmypkg_freebsd_arm.go // only builds on freebsd/arm systems mypkg_plan9.go // only builds on plan9 æ–‡ä»¶åå¿…é¡»æä¾›ï¼Œå¦‚æœåªç”±åç¼€çš„æ–‡ä»¶åä¼šè¢«ç¼–è¯‘å™¨å¿½ç•¥ï¼š\n# è¿™ä¸ªæ–‡ä»¶ä¼šè¢«ç¼–è¯‘å™¨å¿½ç•¥ _linux.go å¦‚ä½•é€‰æ‹©ç¼–è¯‘æ ‡ç­¾å’Œæ–‡ä»¶åç¼€ # ç¼–è¯‘æ ‡ç­¾å’Œæ–‡ä»¶åç¼€çš„åŠŸèƒ½ä¸Šæœ‰é‡å ï¼Œä¾‹å¦‚ä¸€ä¸ªæ–‡ä»¶åï¼šmypkg_linux.go åŒ…å«äº† //go:build linux å°†ä¼šå‡ºç°å†—ä½™\né€šå¸¸æƒ…å†µä¸‹ï¼Œå¦‚æœæºæ–‡ä»¶ä¸å¹³å°æˆ–è€… cpu æ¶æ„å®Œå…¨åŒ¹é…ï¼Œé‚£ä¹ˆä½¿ç”¨æ–‡ä»¶åç¼€å°±å¯ä»¥æ»¡è¶³ï¼Œä¾‹å¦‚ï¼š\nmypkg_linux.go // only builds on linux systems mypkg_windows_amd64.go // only builds on windows 64bit platforms ä¸‹é¢çš„æƒ…å†µï¼Œå°±å¯ä»¥ä½¿ç”¨ç¼–è¯‘æ ‡ç­¾ï¼š\nè¿™ä¸ªæºæ–‡ä»¶å¯ä»¥åœ¨è¶…è¿‡ä¸€ä¸ªå¹³å°æˆ–è€…è¶…è¿‡ä¸€ä¸ª cpu æ¶æ„ éœ€è¦æ’é™¤æŸä¸ªå¹³å°æˆ–æ¶æ„ æœ‰ä¸€äº›è‡ªå®šä¹‰çš„ç¼–è¯‘æ¡ä»¶ +build # // +build åŠŸèƒ½å’Œ //go:build ä¸€æ ·ã€‚åªä¸è¿‡ //go:build æ˜¯åœ¨ go 1.17 æ‰å¼•å…¥çš„ã€‚ä¸å…¶ä»–ç°æœ‰ Go æŒ‡ä»¤ä¿æŒä¸€è‡´ï¼Œä¾‹å¦‚ //go:generateã€‚\näº¤å‰ç¼–è¯‘ # Go å¯ä»¥é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡æ¥å®ç°äº¤å‰ç¼–è¯‘ï¼Œç”¨æ¥åœ¨ä¸€ä¸ªå¹³å°ä¸Šç”Ÿæˆå¦ä¸€ä¸ªå¹³å°çš„å¯æ‰§è¡Œç¨‹åºã€‚ï¼š\n# linux amd64 GOOS=linux GOARCH=amd64 go build main.go # windows amd64 GOOS=windows GOARCH=amd64 go build main.go ç¯å¢ƒå˜é‡ GOOS è®¾ç½®å¹³å°, GOARCH è®¾ç½®æ¶æ„ã€‚\nç¼–è¯‘é€‰é¡¹ # go build [-o output] [-i] [build flags] [packages] -a å¼ºåˆ¶é‡æ–°ç¼–è¯‘æ‰€æœ‰åŒ… -n æŠŠéœ€è¦æ‰§è¡Œçš„ç¼–è¯‘å‘½ä»¤æ‰“å°å‡ºæ¥ï¼Œä½†æ˜¯ä¸æ‰§è¡Œï¼Œè¿™æ ·å°±å¯ä»¥å¾ˆå®¹æ˜“çš„çŸ¥é“åº•å±‚æ˜¯å¦‚ä½•è¿è¡Œçš„ -p n æŒ‡å®šå¯ä»¥å¹¶è¡Œå¯è¿è¡Œçš„ç¼–è¯‘æ•°ç›®ï¼Œé»˜è®¤æ˜¯ CPU çš„æ•°ç›® -o æŒ‡å®šè¾“å‡ºçš„å¯æ‰§è¡Œæ–‡ä»¶çš„æ–‡ä»¶åï¼Œå¯ä»¥å¸¦è·¯å¾„ï¼Œä¾‹å¦‚ go build -o a/b/c -i å®‰è£…ç›¸åº”çš„åŒ…ï¼Œç¼–è¯‘å¹¶ä¸” go install -race å¼€å¯ç¼–è¯‘çš„æ—¶å€™è‡ªåŠ¨æ£€æµ‹æ•°æ®ç«äº‰çš„æƒ…å†µï¼Œç›®å‰åªæ”¯æŒ 64 ä½çš„æœºå™¨ -v æ‰“å°å‡ºæ¥æˆ‘ä»¬æ­£åœ¨ç¼–è¯‘çš„åŒ…å -work æ‰“å°å‡ºæ¥ç¼–è¯‘æ—¶å€™çš„ä¸´æ—¶æ–‡ä»¶å¤¹åç§°ï¼Œå¹¶ä¸”å¦‚æœå·²ç»å­˜åœ¨çš„è¯å°±ä¸è¦åˆ é™¤ -x æ‰“å°å‡ºæ¥æ‰§è¡Œçš„å‘½ä»¤ï¼Œå…¶å®å°±æ˜¯å’Œ-nçš„ç»“æœç±»ä¼¼ï¼Œåªæ˜¯è¿™ä¸ªä¼šæ‰§è¡Œ -ccflags 'arg list' ä¼ é€’å‚æ•°ç»™ 5c, 6c, 8c è°ƒç”¨ -compiler name æŒ‡å®šç›¸åº”çš„ç¼–è¯‘å™¨ï¼Œgccgo è¿˜æ˜¯ gc -gccgoflags 'arg list' ä¼ é€’å‚æ•°ç»™ gccgo ç¼–è¯‘è¿æ¥è°ƒç”¨ -gcflags 'arg list' ç¼–è¯‘å™¨å‚æ•° -installsuffix suffix ä¸ºäº†å’Œé»˜è®¤çš„å®‰è£…åŒ…åŒºåˆ«å¼€æ¥ï¼Œé‡‡ç”¨è¿™ä¸ªå‰ç¼€æ¥é‡æ–°å®‰è£…é‚£äº›ä¾èµ–çš„åŒ…ï¼Œ-raceçš„æ—¶å€™é»˜è®¤å·²ç»æ˜¯ -installsuffix race,å¤§å®¶å¯ä»¥é€šè¿‡ -n å‘½ä»¤æ¥éªŒè¯ -ldflags 'arg list' é“¾æ¥å™¨å‚æ•° -tags 'tag list' è®¾ç½®åœ¨ç¼–è¯‘çš„æ—¶å€™å¯ä»¥é€‚é…çš„é‚£äº›tagï¼Œè¯¦ç»†çš„tagé™åˆ¶å‚è€ƒé‡Œé¢çš„ Build Constraints gcflags # -gcflags å‚æ•°çš„æ ¼å¼æ˜¯\n-gcflags=\u0026#34;pattern=arg list\u0026#34; pattern # pattern æ˜¯é€‰æ‹©åŒ…çš„æ¨¡å¼ï¼Œå®ƒå¯ä»¥æœ‰ä»¥ä¸‹å‡ ç§å®šä¹‰:\nmain: è¡¨ç¤º main å‡½æ•°æ‰€åœ¨çš„é¡¶çº§åŒ…è·¯å¾„ all: è¡¨ç¤º GOPATH ä¸­çš„æ‰€æœ‰åŒ…ã€‚å¦‚æœæ˜¯ go modules æ¨¡å¼ï¼Œåˆ™è¡¨ç¤ºä¸»æ¨¡å—å’Œå®ƒæ‰€æœ‰çš„ä¾èµ–ï¼ŒåŒ…æ‹¬ test æ–‡ä»¶çš„ä¾èµ– std: è¡¨ç¤º Go æ ‡å‡†åº“ä¸­çš„æ‰€æœ‰åŒ… ...: ... æ˜¯ä¸€ä¸ªé€šé…ç¬¦ï¼Œå¯ä»¥åŒ¹é…ä»»æ„å­—ç¬¦ä¸²(åŒ…æ‹¬ç©ºå­—ç¬¦ä¸²)ã€‚ net/... è¡¨ç¤º net æ¨¡å—å’Œå®ƒçš„æ‰€æœ‰å­æ¨¡å— ./... è¡¨ç¤ºå½“å‰ä¸»æ¨¡å—å’Œæ‰€æœ‰å­æ¨¡å— å¦‚æœ pattern ä¸­åŒ…å«äº† / å’Œ ...ï¼Œé‚£ä¹ˆå°±ä¸ä¼šåŒ¹é… vendor ç›®å½• ä¾‹å¦‚: ./... ä¸ä¼šåŒ¹é… ./vendor ç›®å½•ã€‚å¯ä»¥ä½¿ç”¨ ./vendor/... åŒ¹é… vendor ç›®å½•å’Œå®ƒçš„å­æ¨¡å— go help packages æŸ¥çœ‹æ¨¡å¼è¯´æ˜ã€‚\narg list # ç©ºæ ¼åˆ†éš”ï¼Œå¦‚æœç¼–è¯‘é€‰é¡¹ä¸­å«æœ‰ç©ºæ ¼ï¼Œå¯ä»¥ä½¿ç”¨å¼•å·åŒ…èµ·æ¥ã€‚\n-N: ç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ– -l: å…³é—­å†…è” (inline) -c: int ç¼–è¯‘è¿‡ç¨‹ä¸­çš„å¹¶å‘æ•°ï¼Œé»˜è®¤æ˜¯ 1 -B ç¦ç”¨è¶Šç•Œæ£€æŸ¥ -u ç¦ç”¨ unsafe -S è¾“å‡ºæ±‡ç¼–ä»£ç  -m è¾“å‡ºä¼˜åŒ–ä¿¡æ¯ ldflags # -s ç¦ç”¨ç¬¦å·è¡¨ -w ç¦ç”¨ DRAWF è°ƒè¯•ä¿¡æ¯ -X è®¾ç½®å­—ç¬¦ä¸²å…¨å±€å˜é‡å€¼ -X ver=\u0026quot;0.99\u0026quot; -H è®¾ç½®å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼ -H windowsgui å†…è”ä¼˜åŒ–ï¼ˆinlineï¼‰ # å†…è”ä¼˜åŒ–å°±æ˜¯åœ¨ç¼–è¯‘æœŸé—´ï¼Œç›´æ¥å°†è°ƒç”¨å‡½æ•°çš„åœ°æ–¹æ›¿æ¢ä¸ºå‡½æ•°çš„å®ç°ï¼Œå®ƒå¯ä»¥å‡å°‘å‡½æ•°è°ƒç”¨çš„å¼€é”€ï¼ˆåˆ›å»ºæ ˆå¸§ï¼Œè¯»å†™å¯„å­˜å™¨ï¼Œæ ˆæº¢å‡ºæ£€æµ‹ç­‰ï¼‰ä»¥æé«˜ç¨‹åºçš„æ€§èƒ½ã€‚å› ä¸ºä¼˜åŒ–çš„å¯¹è±¡ä¸ºå‡½æ•°ï¼Œæ‰€ä»¥ä¹Ÿå«å‡½æ•°å†…è”ã€‚\nå†…è”æ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹ï¼Œä¸€æ—¦ä¸€ä¸ªå‡½æ•°è¢«å†…è”åˆ°å®ƒçš„è°ƒç”¨è€…ä¸­ï¼Œç¼–è¯‘å™¨å°±å¯èƒ½å°†äº§ç”Ÿçš„ä»£ç å†…è”åˆ°å®ƒçš„è°ƒç”¨è€…ä¸­ï¼Œä¾æ­¤ç±»æ¨ã€‚\nå†…è”ä¼˜åŒ–ç¤ºä¾‹ï¼š\nfunc f() { fmt.Println(\u0026#34;inline\u0026#34;) } func a() { f() } func b() { f() } å†…è”ä¼˜åŒ–åï¼š\nfunc a() { fmt.Println(\u0026#34;inline\u0026#34;) } func b() { fmt.Println(\u0026#34;inline\u0026#34;) } å†…è”ä¼˜åŒ–çš„æ•ˆæœ # package inlinetest //go:noinline func max(a, b int) int { if a \u0026gt; b { return a } return b } max_test.goï¼š\npackage inlinetest import \u0026#34;testing\u0026#34; var Result int func BenchmarkMax(b *testing.B) { var r int for i := 0; i \u0026lt; b.N; i++ { r = max(-1, i) } Result = r } ç°åœ¨æ˜¯åœ¨ç¦ç”¨å†…è”ä¼˜åŒ–çš„æƒ…å†µä¸‹è¿è¡ŒåŸºå‡†æµ‹è¯•ï¼š\n$ go test -bench=. cpu: Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz BenchmarkMax-12 871122506 1.353 ns/op å»æ‰ //go:noinline åï¼ˆå¯ä»¥ä½¿ç”¨ go build -gcflags=\u0026quot;-m -m\u0026quot; main.go æ¥æŸ¥çœ‹ç¼–è¯‘å™¨çš„ä¼˜åŒ–ï¼‰å†æ¬¡è¿è¡ŒåŸºå‡†æµ‹è¯•ï¼š\n$ go test -bench=. cpu: Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz BenchmarkMax-12 1000000000 0.3534 ns/op å¯¹æ¯”ä¸¤æ¬¡åŸºå‡†æµ‹è¯•çš„ç»“æœï¼Œ1.353ns å’Œ 0.3534nsã€‚æ‰“å¼€å†…è”ä¼˜åŒ–çš„æƒ…å†µä¸‹ï¼Œæ€§èƒ½æé«˜äº† 75%ã€‚\nç¦ç”¨å†…è” # Go ç¼–è¯‘å™¨é»˜è®¤å¼€å¯å†…è”ä¼˜åŒ–ï¼Œå¯ä»¥ä½¿ç”¨ -gcflags=\u0026quot;-l\u0026quot; æ¥å…³é—­ã€‚ä½†æ˜¯å¦‚æœä¼ é€’ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„ -l åˆ™ä¼šæ‰“å¼€å†…è”ï¼Œå¹¶å¯ç”¨æ›´æ¿€è¿›çš„å†…è”ç­–ç•¥ï¼š\n-gcflags=\u0026quot;-l -l\u0026quot; 2 çº§å†…è” -gcflags=\u0026quot;-l -l -l\u0026quot; 3 çº§å†…è” gcflags=-l=4 4 çº§åˆ«å†…è” //go:noinline ç¼–è¯‘æŒ‡ä»¤ï¼Œå¯ä»¥ç¦ç”¨å•ä¸ªå‡½æ•°çš„å†…è”ï¼š\n//go:noinline func max(x, y int) int { if x \u0026gt; y { return x } return y } å‡å°ç¼–è¯‘ä½“ç§¯ # Go ç¼–è¯‘å™¨é»˜è®¤ç¼–è¯‘å‡ºæ¥çš„ç¨‹åºä¼šå¸¦æœ‰ç¬¦å·è¡¨å’Œè°ƒè¯•ä¿¡æ¯ï¼Œä¸€èˆ¬æ¥è¯´ release ç‰ˆæœ¬å¯ä»¥å»é™¤è°ƒè¯•ä¿¡æ¯ä»¥å‡å°äºŒè¿›åˆ¶ä½“ç§¯ã€‚\nä½¿ç”¨ -w å’Œ -s æ¥å‡å°‘å¯æ‰§è¡Œæ–‡ä»¶çš„ä½“ç§¯ã€‚ä½†åˆ é™¤äº†è°ƒè¯•ä¿¡æ¯åï¼Œå¯æ‰§è¡Œæ–‡ä»¶å°†æ— æ³•ä½¿ç”¨ gdb/dlv è°ƒè¯•ï¼š\ngo build -ldflags=\u0026#34;-w -s\u0026#34; ./abc.go ä½¿ç”¨ upx # upx æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å‹ç¼©åŠ¨æ€åº“å’Œå¯æ‰§è¡Œæ–‡ä»¶çš„å·¥å…·ï¼Œé€šå¸¸å¯å‡å°‘ 50-70% çš„ä½“ç§¯ã€‚\nä¸‹è½½ upx åè§£å‹å°±å¯ä»¥ä½¿ç”¨äº†ã€‚\n# ä½¿ç”¨ upx $ go build -o server main.go \u0026amp;\u0026amp; upx -9 server # ç»“åˆç¼–è¯‘é€‰é¡¹ go build -ldflags=\u0026#34;-s -w\u0026#34; -o server main.go \u0026amp;\u0026amp; upx -9 server upx çš„å‚æ•° -9 æŒ‡çš„æ˜¯å‹ç¼©ç‡ï¼Œ1 ä»£è¡¨æœ€ä½å‹ç¼©ç‡ï¼Œ9 ä»£è¡¨æœ€é«˜å‹ç¼©ç‡ã€‚\nupx å‹ç¼©åçš„ç¨‹åºå’Œå‹ç¼©å‰çš„ç¨‹åºä¸€æ ·ï¼Œæ— éœ€è§£å‹ä»ç„¶èƒ½å¤Ÿæ­£å¸¸åœ°è¿è¡Œï¼Œè¿™ç§å‹ç¼©æ–¹æ³•ç§°ä¹‹ä¸ºå¸¦å£³å‹ç¼©ã€‚\nå‹ç¼©åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š\nåœ¨ç¨‹åºå¼€å¤´æˆ–å…¶ä»–åˆé€‚çš„åœ°æ–¹æ’å…¥è§£å‹ä»£ç  å°†ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†å‹ç¼© æ‰§è¡Œæ—¶ï¼Œä¹ŸåŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š\né¦–å…ˆæ‰§è¡Œçš„æ˜¯ç¨‹åºå¼€å¤´çš„æ’å…¥çš„è§£å‹ä»£ç ï¼Œå°†åŸæ¥çš„ç¨‹åºåœ¨å†…å­˜ä¸­è§£å‹å‡ºæ¥ å†æ‰§è¡Œè§£å‹åçš„ç¨‹åºã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œupx åœ¨ç¨‹åºæ‰§è¡Œæ—¶ï¼Œä¼šæœ‰é¢å¤–çš„è§£å‹åŠ¨ä½œï¼Œä¸è¿‡è¿™ä¸ªè€—æ—¶å‡ ä¹å¯ä»¥å¿½ç•¥ã€‚\n"},{"id":1,"href":"/golang-learn/docs/concurrency/01_mutex/","title":"äº’æ–¥é”","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" äº’æ–¥é” # Go çš„æ ‡å‡†åº“ sync æä¾›äº†ä¸¤ç§é”ç±»å‹ï¼šsync.Mutex å’Œ sync.RWMutexï¼Œå‰è€…æ˜¯äº’æ–¥é”ï¼ˆæ’ä»–é”ï¼‰ï¼Œåè€…æ˜¯è¯»å†™é”ã€‚\näº’æ–¥é”æ˜¯å¹¶å‘æ§åˆ¶çš„ä¸€ä¸ªåŸºæœ¬æ‰‹æ®µï¼Œæ˜¯ä¸ºäº†é¿å…ç«äº‰è€Œå»ºç«‹çš„ä¸€ç§å¹¶å‘æ§åˆ¶æœºåˆ¶ã€‚\nGo å®šä¹‰çš„é”æ¥å£åªæœ‰ä¸¤ä¸ªæ–¹æ³•ï¼š\ntype Locker interface { Lock() // è¯·æ±‚é” Unlock() // é‡Šæ”¾é” } ä½¿ç”¨ # import \u0026#34;sync\u0026#34; var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() defer mu.Unlock() balance = balance + amount } func Balance() int { mu.Lock() defer mu.Unlock() b := balance return b } å½“å·²ç»æœ‰ goroutine è°ƒç”¨ Lock æ–¹æ³•è·å¾—äº†è¿™ä¸ªé”ï¼Œå†æœ‰ goroutine è¯·æ±‚è¿™ä¸ªé”å°±ä¼šé˜»å¡åœ¨ Lock æ–¹æ³•çš„è°ƒç”¨ä¸Šï¼Œ ç›´åˆ°æŒæœ‰è¿™ä¸ªé”çš„ goroutine è°ƒç”¨ UnLock é‡Šæ”¾è¿™ä¸ªé”ã€‚\nä½¿ç”¨ defer æ¥ UnLock é”ï¼Œç¡®ä¿åœ¨å‡½æ•°è¿”å›ä¹‹åæˆ–è€…å‘ç”Ÿé”™è¯¯è¿”å›æ—¶ä¸€å®šä¼šæ‰§è¡Œ UnLockã€‚\nä¸ºä»€ä¹ˆä¸€å®šè¦åŠ é”ï¼Ÿ # import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var count = 0 // ä½¿ç”¨ WaitGroup ç­‰å¾… 10 ä¸ª goroutine å®Œæˆ var wg sync.WaitGroup wg.Add(10) for i := 0; i \u0026lt; 10; i++ { go func() { defer wg.Done() // å¯¹å˜é‡ count æ‰§è¡Œ 10 æ¬¡åŠ  1 for j := 0; j \u0026lt; 1000; j++ { count++ } }() } // ç­‰å¾… 10 ä¸ª goroutine å®Œæˆ wg.Wait() fmt.Println(count) } ä¸Šé¢çš„ä¾‹å­ä¸­æœŸæœ›çš„æœ€åè®¡æ•°çš„ç»“æœæ˜¯ 10 * 1000 = 10000ã€‚ä½†æ˜¯æ¯æ¬¡è¿è¡Œéƒ½å¯èƒ½å¾—åˆ°ä¸åŒçš„ç»“æœï¼ŒåŸºæœ¬ä¸Šä¸ä¼šå¾—åˆ°çš„ä¸€ä¸‡çš„ç»“æœã€‚\nè¿™æ˜¯å› ä¸ºï¼Œcount++ ä¸æ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œå®ƒè‡³å°‘åŒ…å« 3 ä¸ªæ­¥éª¤\nè¯»å–å˜é‡ count çš„å½“å‰å€¼ï¼Œ å¯¹è¿™ä¸ªå€¼åŠ  1ï¼Œ æŠŠç»“æœä¿å­˜åˆ° count ä¸­ã€‚ å› ä¸ºä¸æ˜¯åŸå­æ“ä½œï¼Œå°±ä¼šæœ‰æ•°æ®ç«äº‰çš„é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œä¸¤ä¸ª goroutine åŒæ—¶è¯»å–åˆ° count çš„å€¼ä¸º 8888ï¼Œæ¥ç€å„è‡ªæŒ‰ç…§è‡ªå·±çš„é€»è¾‘åŠ  1ï¼Œå€¼å˜æˆäº† 8889ï¼ŒæŠŠè¿™ä¸ªç»“æœå†å†™å›åˆ° count å˜é‡ã€‚ æ­¤æ—¶æ€»æ•°åªå¢åŠ äº† 1ï¼Œä½†æ˜¯åº”è¯¥æ˜¯å¢åŠ  2 æ‰å¯¹ã€‚è¿™æ˜¯å¹¶å‘è®¿é—®å…±äº«æ•°æ®çš„å¸¸è§é—®é¢˜ã€‚\næ•°æ®ç«äº‰çš„é—®é¢˜å¯ä»¥å†ç¼–è¯‘æ—¶é€šè¿‡æ•°æ®ç«äº‰æ£€æµ‹å™¨ï¼ˆrace detectorï¼‰å·¥å…·å‘ç°è®¡æ•°å™¨ç¨‹åºçš„é—®é¢˜ä»¥åŠä¿®å¤æ–¹æ³•ã€‚\nåŸç† # sync.Mutex çš„ç»“æ„ä½“ï¼š\n// src/sync/mutex.go#L34 type Mutex struct { state int32 sema uint32 } state å’Œ sema åŠ èµ·æ¥å ç”¨ 8 ä¸ªå­—èŠ‚ã€‚\nstate æ˜¯ä¸€ä¸ªå¤åˆå‹çš„å­—æ®µï¼ŒåŒ…å«å¤šä¸ªæ„ä¹‰ï¼š\nåœ¨é»˜è®¤çŠ¶æ€ä¸‹ï¼Œäº’æ–¥é”çš„æ‰€æœ‰çŠ¶æ€ä½éƒ½æ˜¯ 0ï¼Œint32 ä¸­çš„ä¸åŒä½åˆ†åˆ«è¡¨ç¤ºäº†ä¸åŒçš„çŠ¶æ€ï¼š\nlockedï¼šè¡¨ç¤ºè¿™ä¸ªé”æ˜¯å¦è¢«æŒæœ‰ wokenï¼šè¡¨ç¤ºæ˜¯å¦ä»æœ‰å”¤é†’çš„ goroutine starvingï¼šè¡¨ç¤ºæ­¤é”æ˜¯å¦è¿›å…¥é¥¥é¥¿çŠ¶æ€ waitersCountï¼šè¡¨ç¤ºç­‰å¾…æ­¤é”çš„ goroutine çš„æ•°é‡ é¥¥é¥¿æ¨¡å¼ # è¯·æ±‚é”çš„ goroutine æœ‰ä¸¤ç±»ï¼Œä¸€ç±»æ˜¯æ–°æ¥è¯·æ±‚é”çš„ goroutineï¼Œå¦ä¸€ç±»æ˜¯è¢«å”¤é†’çš„ç­‰å¾…è¯·æ±‚é”çš„ goroutineã€‚\nç”±äºæ–°æ¥çš„ goroutine ä¹Ÿå‚ä¸ç«äº‰é”ï¼Œæç«¯æƒ…å†µä¸‹ï¼Œç­‰å¾…ä¸­çš„ goroutine å¯èƒ½ä¸€ç›´è·å–ä¸åˆ°é”ï¼Œè¿™å°±æ˜¯é¥¥é¥¿é—®é¢˜ã€‚\nä¸ºäº†è§£å†³é¥¥é¥¿ï¼ŒGo 1.9 ä¸­ä¸º mutex å¢åŠ äº†é¥¥é¥¿æ¨¡å¼ã€‚\nåœ¨æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œç­‰å¾…ä¸­çš„ goroutine ä¼šæŒ‰ç…§å…ˆè¿›å…ˆå‡ºçš„é¡ºåºè·å–é”ã€‚ä½†æ˜¯å¦‚æœæ–°æ¥çš„ goroutine ç«äº‰é”ï¼Œç­‰å¾…ä¸­çš„ goroutine å¤§æ¦‚ç‡æ˜¯è·å–ä¸åˆ°é”çš„ã€‚ä¸€æ—¦ goroutine è¶… è¿‡ 1ms æ²¡æœ‰è·å–åˆ°é”ï¼Œå®ƒå°±ä¼šå°†å½“å‰äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ï¼Œä¿è¯é”çš„å…¬å¹³æ€§ã€‚\nåœ¨é¥¥é¥¿æ¨¡å¼ä¸­ï¼Œäº’æ–¥é”ä¼šç›´æ¥äº¤ç»™ç­‰å¾…é˜Ÿåˆ—æœ€å‰é¢çš„ goroutineã€‚æ–°æ¥çš„ goroutine åœ¨è¯¥çŠ¶æ€ä¸‹ä¸èƒ½è·å–é”ã€ä¹Ÿä¸ä¼šè¿›å…¥è‡ªæ—‹çŠ¶æ€ï¼Œåªä¼šåœ¨é˜Ÿåˆ—çš„æœ«å°¾ç­‰å¾…ã€‚\nä¸‹é¢ä¸¤ç§æƒ…å†µï¼Œmutex ä¼šåˆ‡æ¢ä¸ºæ­£å¸¸æ¨¡å¼:\nä¸€ä¸ª goroutine è·å¾—äº†é”å¹¶ä¸”å®ƒåœ¨é˜Ÿåˆ—çš„æœ«å°¾ ä¸€ä¸ª goroutine ç­‰å¾…çš„æ—¶é—´å°‘äº 1ms Lock # Lock çš„å®ç°ï¼š\nconst ( mutexLocked = 1 \u0026lt;\u0026lt; iota // 1 mutexWoken // 2 mutexStarving // 4 mutexWaiterShift = iota // 3 starvationThresholdNs = 1e6 // 1000000 ) func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. // æ²¡æœ‰ goroutine æŒæœ‰é”ï¼Œä¹Ÿæ²¡æœ‰ç­‰å¾…çš„ goroutineï¼Œå½“å‰ goroutine å¯ä»¥ç›´æ¥è·å¾—é” if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // Slow path (outlined so that the fast path can be inlined) // é€šè¿‡è‡ªæ—‹ç­‰æ–¹å¼ç«äº‰é” m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // å½“å‰ goroutine çš„é¥¥é¥¿æ ‡è®° awoke := false // å”¤é†’æ ‡è®° iter := 0 // è‡ªæ—‹æ¬¡æ•° old := m.state // å½“å‰é”çš„çŠ¶æ€ for { // é”æ˜¯éé¥¥é¥¿æ¨¡å¼å¹¶ä¸”è¿˜æ²¡è¢«é‡Šæ”¾ï¼Œå°è¯•è‡ªæ—‹ if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { // å°è¯•è®¾ç½® mutexWoken æ ‡å¿—æ¥é€šçŸ¥è§£é”ï¼Œä»¥é¿å…å”¤é†’å…¶ä»–é˜»å¡çš„ goroutine if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state // å†æ¬¡è·å–é”çš„çŠ¶æ€ï¼Œåé¢ä¼šæ£€æŸ¥é”æ˜¯å¦è¢«é‡Šæ”¾äº† continue } new := old if old\u0026amp;mutexStarving == 0 { new |= mutexLocked // éé¥¥é¥¿çŠ¶æ€ï¼ŒåŠ é” } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1 \u0026lt;\u0026lt; mutexWaiterShift // waiter æ•°é‡åŠ  1 } if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving // è®¾ç½®é¥¥é¥¿çŠ¶æ€ } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026amp;mutexWoken == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡è®° } // è®¾ç½®æ–°çŠ¶æ€ if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // å†æ¬¡æ£€æŸ¥ï¼ŒåŸæ¥é”çš„çŠ¶æ€å·²é‡Šæ”¾ï¼Œå¹¶ä¸”ä¸æ˜¯é¥¥é¥¿çŠ¶æ€ï¼Œæ­£å¸¸è¯·æ±‚åˆ°äº†é”ï¼Œè¿”å› if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // å¤„ç†é¥¥é¥¿çŠ¶æ€ // å¦‚æœä¹‹å‰å°±åœ¨è¯¥é˜Ÿåˆ—é‡Œé¢ï¼Œå°±åŠ å…¥åˆ°é˜Ÿåˆ—å¤´ queueLifo : waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // runtime_SemacquireMutex é€šè¿‡ä¿¡å·é‡ä¿è¯èµ„æºä¸ä¼šè¢«ä¸¤ä¸ª goroutine è·å– // runtime_SemacquireMutex ä¼šåœ¨æ–¹æ³•ä¸­ä¸æ–­å°è¯•è·å–é”å¹¶é™·å…¥ä¼‘çœ ç­‰å¾…ä¿¡å·é‡çš„é‡Šæ”¾ // ä¹Ÿå°±æ˜¯è¿™é‡Œä¼šé˜»å¡ç­‰å¾… // ä¸€æ—¦å½“å‰ goroutine å¯ä»¥è·å–ä¿¡å·é‡ï¼Œå®ƒå°±ä¼šç«‹åˆ»è¿”å›ï¼Œå‰©ä½™ä»£ç ä¹Ÿä¼šç»§ç»­æ‰§è¡Œ runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // åœ¨æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œè¿™æ®µä»£ç ä¼šè®¾ç½®å”¤é†’å’Œé¥¥é¥¿æ ‡è®°ã€é‡ç½®è¿­ä»£æ¬¡æ•°å¹¶é‡æ–°æ‰§è¡Œè·å–é”çš„å¾ªç¯ // åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œå½“å‰ goroutine ä¼šè·å¾—é”ï¼Œå¦‚æœç­‰å¾…é˜Ÿåˆ—ä¸­åªå­˜åœ¨å½“å‰ goroutineï¼Œé”è¿˜ä¼šä»é¥¥é¥¿æ¨¡å¼ä¸­é€€å‡º starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving } atomic.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) }\t} è‡ªæ—‹ # è‡ªæ—‹æ˜¯ä¸€ç§å¤šçº¿ç¨‹åŒæ­¥æœºåˆ¶ï¼Œå½“å‰çš„è¿›ç¨‹åœ¨è¿›å…¥è‡ªæ—‹çš„è¿‡ç¨‹ä¸­ä¼šä¸€ç›´ä¿æŒ CPU çš„å ç”¨ï¼ŒæŒç»­æ£€æŸ¥æŸä¸ªæ¡ä»¶æ˜¯å¦ä¸ºçœŸã€‚åœ¨å¤šæ ¸çš„ CPU ä¸Šï¼Œè‡ªæ—‹å¯ä»¥é¿å… goroutine çš„åˆ‡æ¢ï¼Œä½¿ç”¨æ°å½“ ä¼šå¯¹æ€§èƒ½å¸¦æ¥å¾ˆå¤§çš„å¢ç›Šï¼Œä½†æ˜¯ä½¿ç”¨çš„ä¸æ°å½“å°±ä¼šæ‹–æ…¢æ•´ä¸ªç¨‹åºï¼Œæ‰€ä»¥ goroutine è¿›å…¥è‡ªæ—‹çš„æ¡ä»¶éå¸¸è‹›åˆ»ï¼š\nold\u0026amp;(mutexLocked|mutexStarving) == mutexLocked åªæœ‰åœ¨æ™®é€šæ¨¡å¼ runtime_canSpin(iter) ä¸ºçœŸï¼š è¿è¡Œåœ¨å¤š CPU çš„æœºå™¨ä¸Š è‡ªæ—‹çš„æ¬¡æ•°å°äºå››æ¬¡ å½“å‰æœºå™¨ä¸Šè‡³å°‘å­˜åœ¨ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„å¤„ç†å™¨ P å¹¶ä¸”å¤„ç†çš„è¿è¡Œé˜Ÿåˆ—ä¸ºç©º è¿›å…¥è‡ªæ—‹ä¼šè°ƒç”¨ runtime_doSpin()ï¼Œå¹¶æ‰§è¡Œ 30 æ¬¡çš„ PAUSE æŒ‡ä»¤ï¼Œè¯¥æŒ‡ä»¤åªä¼šå ç”¨ CPU å¹¶æ¶ˆè€— CPU æ—¶é—´ï¼š\n//go:linkname sync_runtime_doSpin sync.runtime_doSpin //go:nosplit func sync_runtime_doSpin() { procyield(active_spin_cnt) } TEXT runtimeÂ·procyield(SB),NOSPLIT,$0-0 MOVL\tcycles+0(FP), AX again: PAUSE SUBL\t$1, AX JNZ\tagain RET Unlock # func (m *Mutex) Unlock() { if race.Enabled { _ = m.state race.Release(unsafe.Pointer(m)) } // Fast path: drop lock bit. // new == 0 æˆåŠŸé‡Šæ”¾é” new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) if new != 0 { // Outlined slow path to allow inlining the fast path. // To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock. m.unlockSlow(new) } } func (m *Mutex) unlockSlow(new int32) { if (new+mutexLocked)\u0026amp;mutexLocked == 0 { // unlock ä¸€ä¸ªæœªåŠ é”çš„é” fatal(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } if new\u0026amp;mutexStarving == 0 { // æ­£å¸¸æ¨¡å¼ old := new for { // ä¸å­˜åœ¨ç­‰å¾…è€… æˆ–è€… mutexLockedã€mutexStarvingã€mutexWoken çŠ¶æ€ä¸éƒ½ä¸º 0 // åˆ™ä¸éœ€è¦å”¤é†’å…¶ä»–ç­‰å¾…è€… if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return } // å­˜åœ¨ç­‰å¾…è€…ï¼Œé€šè¿‡ runtime_Semrelease å”¤é†’ç­‰å¾…è€…å¹¶ç§»äº¤é”çš„æ‰€æœ‰æƒ new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime_Semrelease(\u0026amp;m.sema, false, 1) return } old = m.state } } else { // é¥¥é¥¿æ¨¡å¼ // ç›´æ¥è°ƒç”¨ runtime_Semrelease å°†å½“å‰é”äº¤ç»™ä¸‹ä¸€ä¸ªæ­£åœ¨å°è¯•è·å–é”çš„ç­‰å¾…è€…ï¼Œç­‰å¾…è€…è¢«å”¤é†’åä¼šå¾—åˆ°é”ï¼Œåœ¨è¿™æ—¶è¿˜ä¸ä¼šé€€å‡ºé¥¥é¥¿çŠ¶æ€ runtime_Semrelease(\u0026amp;m.sema, true, 1) } } "},{"id":2,"href":"/golang-learn/docs/basic/01_basic_type/","title":"åŸºç¡€æ•°æ®ç±»å‹","section":"ğŸš è¯­è¨€åŸºç¡€","content":" æ•°å€¼ç±»å‹ # æ•´å‹ # uintï¼Œæ— ç¬¦å· 32 æˆ– 64 ä½æ•´å‹ uint8ï¼Œæ— ç¬¦å· 8 ä½æ•´å‹ (0 åˆ° 255) uint16ï¼Œæ— ç¬¦å· 16 ä½æ•´å‹ (0 åˆ° 65535) uint32ï¼Œæ— ç¬¦å· 32 ä½æ•´å‹ (0 åˆ° 4294967295) uint64ï¼Œæ— ç¬¦å· 64 ä½æ•´å‹ (0 åˆ° 18446744073709551615) intï¼Œæœ‰ç¬¦å· 32 æˆ– 64 ä½æ•´å‹ int8ï¼Œæœ‰ç¬¦å· 8 ä½æ•´å‹ (-128 åˆ° 127) int16ï¼Œæœ‰ç¬¦å· 16 ä½æ•´å‹ (-32768 åˆ° 32767) int32ï¼Œæœ‰ç¬¦å· 32 ä½æ•´å‹ (-2147483648 åˆ° 2147483647) int64ï¼Œæœ‰ç¬¦å· 64 ä½æ•´å‹ (-9223372036854775808 åˆ° 9223372036854775807) int å’Œ uint å¯¹åº”çš„æ˜¯ CPU å¹³å°æœºå™¨çš„å­—å¤§å°ã€‚\næµ®ç‚¹æ•° # float32 å’Œ float64 çš„ç®—æœ¯è§„èŒƒç”± IEEE-754 æµ®ç‚¹æ•°å›½é™…æ ‡å‡†å®šä¹‰ã€‚\nfloat32ï¼Œ32 ä½æµ®ç‚¹å‹æ•°ï¼Œmath.MaxFloat32 è¡¨ç¤º float32 èƒ½è¡¨ç¤ºçš„æœ€å¤§æ•°å€¼ï¼Œå¤§çº¦æ˜¯ 3.4e38ã€‚ float64ï¼Œ64 ä½æµ®ç‚¹å‹æ•°ï¼Œmath.MaxFloat64 è¡¨ç¤º float64 èƒ½è¡¨ç¤ºçš„æœ€å¤§æ•°å€¼ï¼Œå¤§çº¦æ˜¯ 1.8e308ã€‚ å¤æ•° # complex64ï¼Œå¯¹åº” float32 æµ®ç‚¹æ•°ç²¾åº¦ã€‚ complex128ï¼Œå¯¹åº” float64 æµ®ç‚¹æ•°ç²¾åº¦ã€‚ å†…ç½® complex å‡½æ•°åˆ›å»ºå¤æ•°ã€‚æ ‡å‡†åº“ math/cmplx æä¾›äº†å¤„ç†å¤æ•°çš„å‡½æ•°ã€‚\nå…¶ä»–æ•°å€¼ç±»å‹ # byteï¼Œuint8çš„åˆ«åï¼Œä¸€èˆ¬ç”¨äºå¼ºè°ƒæ•°å€¼æ˜¯ä¸€ä¸ªåŸå§‹çš„æ•°æ®è€Œä¸æ˜¯ä¸€ä¸ªå°çš„æ•´æ•°ã€‚ runeï¼Œint32çš„åˆ«åï¼Œé€šå¸¸ç”¨äºè¡¨ç¤ºä¸€ä¸ª Unicode ç ç‚¹ã€‚ uintptrï¼Œæ— ç¬¦å·æ•´å‹ï¼Œæ²¡æœ‰æŒ‡å®šå…·ä½“çš„ bit å¤§å°ï¼Œç”¨äºå­˜æ”¾ä¸€ä¸ªæŒ‡é’ˆã€‚ å¸ƒå°”ç±»å‹ # å¸ƒå°”ç±»å‹çš„å€¼åªæœ‰ä¸¤ç§ï¼štrue å’Œ falseã€‚\nå­—ç¬¦ä¸² # å­—ç¬¦ä¸²å®é™…ä¸Šæ˜¯ç”±å­—ç¬¦ç»„æˆçš„æ•°ç»„ï¼ŒC è¯­è¨€ä¸­çš„å­—ç¬¦ä¸²ä½¿ç”¨å­—ç¬¦æ•°ç»„ char[] è¡¨ç¤ºã€‚æ•°ç»„ä¼šå ç”¨ä¸€ç‰‡è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œè€Œå†…å­˜ç©ºé—´å­˜å‚¨çš„å­—èŠ‚å…±åŒç»„æˆäº†å­—ç¬¦ä¸²ï¼ŒGo ä¸­çš„å­—ç¬¦ä¸²åªæ˜¯ä¸€ä¸ªåªè¯»çš„å­—èŠ‚æ•°ç»„ã€‚\nå­—ç¬¦ä¸²çš„ç»“æ„ä½“ï¼š\n// src/reflect/value.go#L1983 type StringHeader struct { Data uintptr Len int } ä¸åˆ‡ç‰‡çš„ç»“æ„ä½“å¾ˆåƒï¼Œåªä¸è¿‡å°‘äº†ä¸€ä¸ªå®¹é‡ Capã€‚\nå› ä¸ºå­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªåªè¯»çš„ç±»å‹ï¼Œä¸å¯ä»¥ç›´æ¥å‘å­—ç¬¦ä¸²ç›´æ¥è¿½åŠ å…ƒç´ æ”¹å˜å…¶æœ¬èº«çš„å†…å­˜ç©ºé—´ï¼Œæ‰€æœ‰åœ¨å­—ç¬¦ä¸²ä¸Šçš„å†™å…¥æ“ä½œéƒ½æ˜¯é€šè¿‡æ‹·è´å®ç°çš„ã€‚\nå­—ç¬¦ä¸²æ‹¼æ¥ # æ‹¼æ¥å­—ç¬¦ä¸²çš„å‡ ç§æ–¹å¼ï¼š\n+ æ‹¼æ¥å­—ç¬¦ä¸² # ä¾‹å¦‚ fmt.Println(\u0026quot;hello\u0026quot; + s[5:]) è¾“å‡º \u0026quot;hello, world\u0026quot;ã€‚ä½¿ç”¨ + æ¥æ‹¼æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²æ—¶ï¼Œå®ƒä¼šç”³è¯·ä¸€å—æ–°çš„å†…å­˜ç©ºé—´ï¼Œå¤§å°æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å¤§å°ä¹‹å’Œã€‚æ‹¼æ¥ç¬¬ä¸‰ä¸ªå­—ç¬¦ä¸²æ—¶ï¼Œå†ç”³è¯·ä¸€å—æ–°çš„å†…å­˜ç©ºé—´ï¼Œå¤§å°æ˜¯ä¸‰ä¸ªå­—ç¬¦ä¸²å¤§å°ä¹‹å’Œã€‚è¿™ç§æ–¹å¼æ¯æ¬¡è¿ç®—éƒ½éœ€è¦é‡æ–°åˆ†é…å†…å­˜ï¼Œä¼šç»™å†…å­˜åˆ†é…å’Œ GC å¸¦æ¥é¢å¤–çš„è´Ÿæ‹…ï¼Œæ‰€ä»¥æ€§èƒ½æ¯”è¾ƒå·®ã€‚\nfmt.Sprintf # fmt.Sprintf() æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œå†…éƒ¨ä½¿ç”¨ []byte å®ç°ï¼Œä¸åƒç›´æ¥è¿ç®—ç¬¦è¿™ç§ä¼šäº§ç”Ÿå¾ˆå¤šä¸´æ—¶çš„å­—ç¬¦ä¸²ï¼Œä½†æ˜¯å†…éƒ¨çš„é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œæœ‰å¾ˆå¤šé¢å¤–çš„åˆ¤æ–­ï¼Œè¿˜ç”¨åˆ°äº† interfaceï¼Œæ‰€ä»¥æ€§èƒ½ä¸€èˆ¬ã€‚\nbytes.Buffer # åˆ©ç”¨ bytes.Buffer æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œæ˜¯æ¯”è¾ƒç†æƒ³çš„ä¸€ç§æ–¹å¼ã€‚å¯¹å†…å­˜çš„å¢é•¿æœ‰ä¼˜åŒ–ï¼Œå¦‚æœèƒ½é¢„ä¼°å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œè¿˜å¯ä»¥ç”¨ buffer.Grow æ¥å£æ¥è®¾ç½® capacityã€‚\nvar buffer bytes.Buffer buffer.WriteString(\u0026#34;hello\u0026#34;) buffer.WriteString(\u0026#34;, \u0026#34;) buffer.WriteString(\u0026#34;world\u0026#34;) fmt.Print(buffer.String()) strings.Builder # strings.Builder å†…éƒ¨é€šè¿‡ slice æ¥ä¿å­˜å’Œç®¡ç†å†…å®¹ã€‚strings.Builder æ˜¯éçº¿ç¨‹å®‰å…¨ï¼Œæ€§èƒ½ä¸Šå’Œ bytes.Buffer ç›¸å·®æ— å‡ ã€‚\nvar b1 strings.Builder b1.WriteString(\u0026#34;ABC\u0026#34;) b1.WriteString(\u0026#34;DEF\u0026#34;) fmt.Print(b1.String()) Builder.Grow æ–¹æ³•å¯ä»¥é¢„åˆ†é…å†…å­˜ã€‚\næ¨èä½¿ç”¨ strings.Builder æ¥æ‹¼æ¥å­—ç¬¦ä¸²ã€‚\nstrings.Builder æ€§èƒ½ä¸Šæ¯” bytes.Buffer ç•¥å¿«ï¼Œä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„åŒºåˆ«åœ¨äºï¼Œbytes.Buffer è½¬åŒ–ä¸ºå­—ç¬¦ä¸²æ—¶é‡æ–°ç”³è¯·äº†ä¸€å—ç©ºé—´ï¼Œå­˜æ”¾ç”Ÿæˆçš„å­—ç¬¦ä¸²å˜é‡ï¼Œè€Œ strings.Builder ç›´æ¥å°†åº•å±‚çš„ []byte è½¬æ¢æˆäº†å­—ç¬¦ä¸²ç±»å‹å¹¶è¿”å›ã€‚\nbytes.Bufferï¼š\nfunc (b *Buffer) String() string { if b == nil { // Special case, useful in debugging. return \u0026#34;\u0026lt;nil\u0026gt;\u0026#34; } return string(b.buf[b.off:]) } strings.Builderï¼š\nfunc (b *Builder) String() string { return unsafe.String(unsafe.SliceData(b.buf), len(b.buf)) } ç±»å‹è½¬æ¢ # åœ¨æ—¥å¸¸å¼€å‘ä¸­ï¼Œstring å’Œ []byte ä¹‹é—´çš„è½¬æ¢æ˜¯å¾ˆå¸¸è§çš„ï¼Œä¸ç®¡æ˜¯ string è½¬ []byte è¿˜æ˜¯ []byte è½¬ string éƒ½éœ€è¦æ‹·è´æ•°æ®ï¼Œè€Œå†…å­˜æ‹·è´å¸¦æ¥çš„æ€§èƒ½æŸè€—ä¼šéšç€å­—ç¬¦ä¸²å’Œ []byte é•¿åº¦çš„å¢é•¿è€Œå¢é•¿ã€‚\n"},{"id":3,"href":"/golang-learn/docs/project/01_structure/","title":"é¡¹ç›®çš„ç›®å½•ç»“æ„","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" é¡¹ç›®çš„ç›®å½•ç»“æ„ # å¹³é“ºå¼ç»“æ„ # project-layout # "},{"id":4,"href":"/golang-learn/docs/concurrency/","title":"âš¡ å¹¶å‘ç¼–ç¨‹","section":"Docs","content":" âš¡ å¹¶å‘ç¼–ç¨‹ # å¹¶å‘å’Œå¹¶è¡Œçš„åŒºåˆ«ï¼š\nå¹¶å‘ï¼šé€»è¾‘ä¸Šå…·å¤‡åŒæ—¶å¤„ç†å¤šä¸ªä»»åŠ¡çš„èƒ½åŠ› å¹¶è¡Œï¼šç‰©ç†ä¸ŠåŒæ—¶å¤„ç†å¤šä¸ªå¹¶å‘ä»»åŠ¡çš„èƒ½åŠ› å¹¶å‘ # ä¸€ä¸ª CPU ä¸Šèƒ½åŒæ—¶æ‰§è¡Œå¤šé¡¹ä»»åŠ¡ï¼Œåœ¨å¾ˆçŸ­æ—¶é—´å†…ï¼ŒCPU æ¥å›åˆ‡æ¢ä»»åŠ¡æ‰§è¡Œ(åœ¨æŸæ®µå¾ˆçŸ­æ—¶é—´å†…æ‰§è¡Œç¨‹åº aï¼Œç„¶ååˆè¿…é€Ÿå¾—åˆ‡æ¢åˆ°ç¨‹åº b å»æ‰§è¡Œ)ï¼Œ æœ‰æ—¶é—´ä¸Šçš„é‡å ï¼ˆå®è§‚ä¸Šæ˜¯åŒæ—¶çš„ï¼Œå¾®è§‚ä»æ˜¯é¡ºåºæ‰§è¡Œï¼‰,è¿™æ ·çœ‹èµ·æ¥å¤šä¸ªä»»åŠ¡åƒæ˜¯åŒæ—¶æ‰§è¡Œï¼Œè¿™å°±æ˜¯å¹¶å‘ã€‚\nå¹¶è¡Œ # å½“ç³»ç»Ÿæœ‰å¤šä¸ª CPU æ—¶,æ¯ä¸ª CPU åŒä¸€æ—¶åˆ»éƒ½è¿è¡Œä»»åŠ¡ï¼Œäº’ä¸æŠ¢å è‡ªå·±æ‰€åœ¨çš„ CPU èµ„æºï¼ŒåŒæ—¶è¿›è¡Œï¼Œç§°ä¸ºå¹¶è¡Œã€‚å¹¶è¡Œæ˜¯å¹¶å‘è®¾è®¡çš„ç†æƒ³æ¨¡å¼ã€‚\nè¿›ç¨‹ # cpu åœ¨åˆ‡æ¢ç¨‹åºçš„æ—¶å€™ï¼Œå¦‚æœä¸ä¿å­˜ä¸Šä¸€ä¸ªç¨‹åºçš„çŠ¶æ€ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„ context \u0026ndash;ä¸Šä¸‹æ–‡ï¼‰ï¼Œç›´æ¥åˆ‡æ¢ä¸‹ä¸€ä¸ªç¨‹åºï¼Œå°±ä¼šä¸¢å¤±ä¸Šä¸€ä¸ªç¨‹åºçš„ä¸€ç³»åˆ—çŠ¶æ€ï¼Œäºæ˜¯å¼•å…¥äº†è¿›ç¨‹è¿™ä¸ªæ¦‚å¿µï¼Œç”¨ä»¥åˆ’åˆ†å¥½ç¨‹åºè¿è¡Œæ—¶æ‰€éœ€è¦çš„èµ„æºã€‚å› æ­¤è¿›ç¨‹å°±æ˜¯ä¸€ä¸ªç¨‹åºè¿è¡Œæ—¶å€™çš„æ‰€éœ€è¦çš„åŸºæœ¬èµ„æºå•ä½ï¼ˆä¹Ÿå¯ä»¥è¯´æ˜¯ç¨‹åºè¿è¡Œçš„ä¸€ä¸ªå®ä½“ï¼‰ã€‚\nçº¿ç¨‹ # CPU åˆ‡æ¢å¤šä¸ªè¿›ç¨‹çš„æ—¶å€™ï¼Œä¼šèŠ±è´¹ä¸å°‘çš„æ—¶é—´ï¼Œå› ä¸ºåˆ‡æ¢è¿›ç¨‹éœ€è¦åˆ‡æ¢åˆ°å†…æ ¸æ€ï¼Œè€Œæ¯æ¬¡è°ƒåº¦éœ€è¦å†…æ ¸æ€éƒ½éœ€è¦è¯»å–ç”¨æˆ·æ€çš„æ•°æ®ï¼Œè¿›ç¨‹ä¸€æ—¦å¤šèµ·æ¥ï¼ŒCPU è°ƒåº¦ä¼šæ¶ˆè€—ä¸€å¤§å †èµ„æºï¼Œå› æ­¤å¼•å…¥äº†çº¿ç¨‹çš„æ¦‚å¿µï¼Œçº¿ç¨‹æœ¬èº«å‡ ä¹ä¸å æœ‰èµ„æºï¼Œä»–ä»¬å…±äº«è¿›ç¨‹é‡Œçš„èµ„æºï¼Œå†…æ ¸è°ƒåº¦èµ·æ¥ä¸ä¼šé‚£ä¹ˆåƒè¿›ç¨‹åˆ‡æ¢é‚£ä¹ˆè€—è´¹èµ„æºã€‚\nåç¨‹ # å¤šçº¿ç¨‹å’Œå¤šè¿›ç¨‹æ˜¯å¹¶è¡Œçš„åŸºæœ¬æ¡ä»¶ï¼Œä½†æ˜¯å•çº¿ç¨‹å¯ä»¥åˆ©ç”¨åç¨‹åšåˆ°å¹¶å‘ã€‚åç¨‹æ‹¥æœ‰è‡ªå·±çš„å¯„å­˜å™¨ä¸Šä¸‹æ–‡å’Œæ ˆã€‚åç¨‹åœ¨çº¿ç¨‹ä¸Šé€šè¿‡ä¸»åŠ¨åˆ‡æ¢æ¥å®ç°å¹¶å‘ï¼Œå‡å°‘äº†é˜»å¡æ—¶é—´ï¼Œè¿˜é¿å…äº†çº¿ç¨‹åˆ‡æ¢çš„å¼€é”€ã€‚ä½†åç¨‹è¿è¡Œçš„å¹¶å‘æœ¬è´¨ä¸Šè¿˜æ˜¯ä¸²è¡Œçš„ã€‚çº¿ç¨‹å’Œè¿›ç¨‹çš„æ“ä½œæ˜¯ç”±ç¨‹åºè§¦å‘ç³»ç»Ÿæ¥å£ï¼Œæœ€åçš„æ‰§è¡Œè€…æ˜¯ç³»ç»Ÿï¼›åç¨‹çš„æ“ä½œæ‰§è¡Œè€…åˆ™æ˜¯ç”¨æˆ·è‡ªèº«ç¨‹åºã€‚\nGo å¹¶å‘åŸè¯­ # Go çš„æ ‡å‡†åº“æä¾›äº†åŸºæœ¬çš„å¹¶å‘åŸè¯­ï¼šMutexã€RWMutexã€WaitGroupã€Condã€Context ç­‰ã€‚\nåœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œå¦‚æœç¨‹åºä¸­çš„ä¸€éƒ¨åˆ†ä¼šè¢«å¹¶å‘è®¿é—®æˆ–ä¿®æ”¹ï¼Œé‚£ä¹ˆï¼Œä¸ºäº†é¿å…å¹¶å‘è®¿é—®å¯¼è‡´çš„æ„æƒ³ä¸åˆ°çš„ç»“æœï¼Œè¿™éƒ¨åˆ†ç¨‹åºéœ€è¦è¢«ä¿æŠ¤èµ·æ¥ï¼Œè¿™éƒ¨åˆ†è¢«ä¿æŠ¤èµ·æ¥çš„ç¨‹åºï¼Œå°±å«åšä¸´ç•ŒåŒºã€‚\nä¸´ç•ŒåŒºå°±æ˜¯ä¸€ä¸ªè¢«å…±äº«çš„èµ„æºï¼Œæˆ–è€…è¯´æ˜¯ä¸€ä¸ªæ•´ä½“çš„ä¸€ç»„å…±äº«èµ„æºï¼Œæ¯”å¦‚å¯¹æ•°æ®åº“çš„è®¿é—®ã€å¯¹æŸä¸€ä¸ªå…±äº«æ•°æ®ç»“æ„çš„æ“ä½œã€å¯¹ä¸€ä¸ª I/O è®¾å¤‡çš„ä½¿ç”¨ã€å¯¹ä¸€ä¸ªè¿æ¥æ± ä¸­çš„è¿æ¥çš„è°ƒç”¨ï¼Œç­‰ç­‰ã€‚\né¿å…æ•°æ®ç«äº‰çš„ä¸‰ç§æ–¹å¼ï¼š\nä¸å»å†™å˜é‡ã€‚è¯»å–ä¸å¯èƒ½å‡ºç°æ•°æ®ç«äº‰ã€‚ é¿å…ä»å¤šä¸ª goroutine è®¿é—®å˜é‡ï¼Œå°½é‡æŠŠå˜é‡é™å®šåœ¨äº†ä¸€ä¸ªå•ç‹¬çš„ goroutine ä¸­ã€‚(ä½¿ç”¨ channel æ¥å…±äº«æ•°æ®) äº’æ–¥é” åŒæ­¥åŸè¯­çš„é€‚ç”¨åœºæ™¯ï¼š\nå…±äº«èµ„æºã€‚å¹¶å‘åœ°è¯»å†™å…±äº«èµ„æºï¼Œä¼šå‡ºç°æ•°æ®ç«äº‰ï¼ˆdata raceï¼‰çš„é—®é¢˜ï¼Œæ‰€ä»¥éœ€è¦ Mutexã€RWMutex è¿™æ ·çš„å¹¶å‘åŸè¯­æ¥ä¿æŠ¤ã€‚ ä»»åŠ¡ç¼–æ’ã€‚éœ€è¦ goroutine æŒ‰ç…§ä¸€å®šçš„è§„å¾‹æ‰§è¡Œï¼Œè€Œ goroutine ä¹‹é—´æœ‰ç›¸äº’ç­‰å¾…æˆ–è€…ä¾èµ–çš„é¡ºåºå…³ç³»ï¼Œå¸¸å¸¸ä½¿ç”¨ WaitGroup æˆ–è€… channel æ¥å®ç°ã€‚ æ¶ˆæ¯ä¼ é€’ã€‚ä¿¡æ¯äº¤æµä»¥åŠä¸åŒçš„ goroutine ä¹‹é—´çš„çº¿ç¨‹å®‰å…¨çš„æ•°æ®äº¤æµï¼Œå¸¸å¸¸ä½¿ç”¨ channel æ¥å®ç°ã€‚ æ ‡å‡†åº“ sync æä¾›çš„åŒæ­¥åŸè¯­éƒ½æ˜¯ä¸èƒ½å¤åˆ¶çš„ã€‚\n"},{"id":5,"href":"/golang-learn/docs/project/02_commitizen/","title":"Commit è§„èŒƒ","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" Commit è§„èŒƒ # "},{"id":6,"href":"/golang-learn/docs/practice/02_go_race/","title":"Go æ•°æ®ç«äº‰æ£€æµ‹å™¨","section":"ğŸ› ï¸ å®è·µ","content":" Go æ•°æ®ç«äº‰æ£€æµ‹å™¨ # æ•°æ®ç«äº‰æ˜¯å¹¶å‘ç³»ç»Ÿä¸­æœ€å¸¸è§ï¼ŒåŒæ—¶ä¹Ÿæœ€éš¾å¤„ç†çš„ Bug ç±»å‹ä¹‹ä¸€ã€‚æ•°æ®ç«äº‰ä¼šåœ¨ä¸¤ä¸ª goroutine å¹¶å‘è®¿é—®åŒä¸€ä¸ªå˜é‡ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªè®¿é—®ä¸ºå†™å…¥æ—¶äº§ç”Ÿã€‚\nè¿™ä¸ªæ•°æ®ç«äº‰çš„ä¾‹å­å¯å¯¼è‡´ç¨‹åºå´©æºƒå’Œå†…å­˜æ•°æ®æŸåï¼ˆmemory corruptionï¼‰ã€‚\npackage main import \u0026#34;fmt\u0026#34; func main() { c := make(chan bool) m := make(map[string]string) go func() { m[\u0026#34;1\u0026#34;] = \u0026#34;a\u0026#34; // ç¬¬ä¸€ä¸ªå†²çªçš„è®¿é—® c \u0026lt;- true }() m[\u0026#34;2\u0026#34;] = \u0026#34;b\u0026#34; // ç¬¬äºŒä¸ªå†²çªçš„è®¿é—® \u0026lt;-c for k, v := range m { fmt.Println(k, v) } } è¿è¡Œ go run -race ./main.go æˆ–è€… go build -race ./main.go ç¼–è¯‘åå†è¿è¡Œä¼šæŠ›å‡ºç±»ä¼¼çš„é”™è¯¯ï¼š\n================== WARNING: DATA RACE Write at 0x00c00010a090 by goroutine 7: runtime.mapassign_faststr() /usr/local/go/src/runtime/map_faststr.go:203 +0x0 main.main.func1() /root/workspace/main.go:9 +0x4a Previous write at 0x00c00010a090 by main goroutine: runtime.mapassign_faststr() /usr/local/go/src/runtime/map_faststr.go:203 +0x0 main.main() /root/workspace/main.go:12 +0x108 Goroutine 7 (running) created at: main.main() /root/workspace/main.go:8 +0xeb ================== 2 b 1 a Found 1 data race(s) æ•°æ®ç«äº‰æ£€æµ‹å™¨ # Go å†…å»ºäº†æ•°æ®ç«äº‰æ£€æµ‹å™¨ã€‚è¦ä½¿ç”¨å®ƒï¼Œè¯·å°† -race æ ‡è®°æ·»åŠ åˆ° go å‘½ä»¤ä¹‹åï¼š\ngo test -race mypkg // æµ‹è¯•è¯¥åŒ… go run -race mysrc.go // è¿è¡Œå…¶æºæ–‡ä»¶ go build -race mycmd // æ„å»ºè¯¥å‘½ä»¤ go install -race mypkg // å®‰è£…è¯¥åŒ… é€‰é¡¹ # GORACE ç¯å¢ƒå˜é‡å¯ä»¥è®¾ç½®ç«äº‰æ£€æµ‹çš„é€‰é¡¹ï¼š\nGORACE=\u0026#34;option1=val1 option2=val2\u0026#34; é€‰é¡¹ï¼š\nlog_pathï¼ˆé»˜è®¤ä¸º stderrï¼‰ï¼šç«äº‰æ£€æµ‹å™¨ä¼šå°†å…¶æŠ¥å‘Šå†™å…¥åä¸º log_path.pid çš„æ–‡ä»¶ä¸­ã€‚ç‰¹æ®Šçš„åå­— stdout å’Œ stderr ä¼šå°†æŠ¥å‘Šåˆ†åˆ«å†™å…¥åˆ°æ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯ä¸­ã€‚ exitcodeï¼ˆé»˜è®¤ä¸º 66ï¼‰ï¼šå½“æ£€æµ‹åˆ°ç«äº‰åä½¿ç”¨çš„é€€å‡ºçŠ¶æ€ã€‚ strip_path_prefixï¼ˆé»˜è®¤ä¸º \u0026ldquo;\u0026quot;ï¼‰ï¼šä»æ‰€æœ‰æŠ¥å‘Šæ–‡ä»¶çš„è·¯å¾„ä¸­å»é™¤æ­¤å‰ç¼€ï¼Œ è®©æŠ¥å‘Šæ›´åŠ ç®€æ´ã€‚ history_sizeï¼ˆé»˜è®¤ä¸º 1ï¼‰ï¼šæ¯ä¸ª Go ç¨‹çš„å†…å­˜è®¿é—®å†å²ä¸º 32K * 2**history_size ä¸ªå…ƒç´ ã€‚å¢åŠ è¯¥å€¼å¯é¿å…åœ¨æŠ¥å‘Šä¸­é¿å… \u0026ldquo;failed to restore the stack\u0026rdquo;ï¼ˆæ ˆæ¢å¤å¤±è´¥ï¼‰çš„æç¤ºï¼Œä½†ä»£ä»·æ˜¯ä¼šå¢åŠ å†…å­˜çš„ä½¿ç”¨ã€‚ halt_on_errorï¼ˆé»˜è®¤ä¸º 0ï¼‰ï¼šæ§åˆ¶ç¨‹åºåœ¨æŠ¥å‘Šç¬¬ä¸€æ¬¡æ•°æ®ç«äº‰åæ˜¯å¦é€€å‡ºã€‚ ä¾‹å¦‚ï¼š\nGORACE=\u0026#34;log_path=/tmp/race/report strip_path_prefix=/my/go/sources/\u0026#34; go test -race ç¼–è¯‘æ ‡ç­¾ # å¯ä»¥é€šè¿‡ç¼–è¯‘æ ‡ç­¾æ¥æ’é™¤æŸäº›ç«äº‰æ£€æµ‹å™¨ä¸‹çš„ä»£ç /æµ‹è¯•ï¼š\n//go:build !race package foo // æ­¤æµ‹è¯•åŒ…å«äº†æ•°æ®ç«äº‰ã€‚è§123å·é—®é¢˜ã€‚ func TestFoo(t *testing.T) { // ... } // æ­¤æµ‹è¯•ä¼šå› ä¸ºç«äº‰æ£€æµ‹å™¨çš„è¶…æ—¶è€Œå¤±è´¥ã€‚ func TestBar(t *testing.T) { // ... } // æ­¤æµ‹è¯•ä¼šåœ¨ç«äº‰æ£€æµ‹å™¨ä¸‹èŠ±è´¹å¤ªé•¿æ—¶é—´ã€‚ func TestBaz(t *testing.T) { // ... } è¿è¡Œæ—¶å¼€é”€ # ç«äº‰æ£€æµ‹å™¨åªä¼šå¯»æ‰¾åœ¨è¿è¡Œæ—¶å‘ç”Ÿçš„ç«äº‰ï¼Œå› æ­¤å®ƒä¸èƒ½åœ¨æœªæ‰§è¡Œçš„ä»£ç è·¯å¾„ä¸­å¯»æ‰¾ç«äº‰ã€‚è‹¥ä½ çš„æµ‹è¯•å¹¶æœªå®Œå…¨è¦†ç›–ï¼Œä½ å¯ä»¥è¿è¡Œé€šè¿‡ -race ç¼–è¯‘çš„äºŒè¿›åˆ¶ç¨‹åºï¼Œä»¥æ­¤å¯»æ‰¾æ›´å¤šçš„ç«äº‰ã€‚\nç«äº‰æ£€æµ‹çš„ä»£ä»·å› ç¨‹åºè€Œå¼‚ï¼Œä½†å¯¹äºå…¸å‹çš„ç¨‹åºï¼Œå†…å­˜çš„ä½¿ç”¨ä¼šå¢åŠ  5 åˆ° 10 å€ï¼Œ è€Œæ‰§è¡Œæ—¶é—´ä¼šå¢åŠ  2 åˆ° 20 å€ã€‚\n"},{"id":7,"href":"/golang-learn/docs/basic/02_array/","title":"æ•°ç»„","section":"ğŸš è¯­è¨€åŸºç¡€","content":" æ•°ç»„ # æ•°ç»„æ˜¯ä¸€ä¸ªç”±å›ºå®šé•¿åº¦ï¼Œç›¸åŒç±»å‹çš„å…ƒç´ ç»„æˆçš„æ•°æ®ç»“æ„ã€‚è®¡ç®—æœºä¼šä¸ºæ•°ç»„åˆ†é…ä¸€å—è¿ç»­çš„å†…å­˜æ¥ä¿å­˜å…¶ä¸­çš„å…ƒç´ ï¼Œå¹¶ä¸”å¯ä»¥åˆ©ç”¨ç´¢å¼•å¿«é€Ÿè®¿é—®æ•°ç»„ä¸­çš„å…ƒç´ ã€‚\nåˆå§‹åŒ– # arr1 := [3]int{1, 2, 3} arr2 := [...]int{1, 2, 3} // `...` çœç•¥å·ï¼Œè¡¨ç¤ºæ•°ç»„çš„é•¿åº¦æ˜¯æ ¹æ®åˆå§‹åŒ–å€¼çš„ä¸ªæ•°æ¥è®¡ç®— æ•°ç»„çš„é•¿åº¦åœ¨ç¼–è¯‘é˜¶æ®µç¡®å®šï¼Œåˆå§‹åŒ–ä¹‹åå¤§å°å°±æ— æ³•æ”¹å˜ã€‚\næ•°ç»„æ˜¯å¦åº”è¯¥åœ¨å †æ ˆä¸­åˆå§‹åŒ–åœ¨ç¼–è¯‘æœŸå°±ç¡®å®šäº†ã€‚\næ ¹æ®æ•°ç»„å¤§å°ï¼š\nå½“å…ƒç´ æ•°é‡å°äºæˆ–è€…ç­‰äº 4 ä¸ªæ—¶ï¼Œä¼šç›´æ¥å°†æ•°ç»„ä¸­çš„å…ƒç´ æ”¾ç½®åœ¨æ ˆä¸Šã€‚ å½“å…ƒç´ æ•°é‡å¤§äº 4 ä¸ªæ—¶ï¼Œä¼šå°†æ•°ç»„ä¸­çš„å…ƒç´ æ”¾ç½®åˆ°é™æ€åŒºï¼Œå¹¶åœ¨è¿è¡Œæ—¶å–å‡ºã€‚ "},{"id":8,"href":"/golang-learn/docs/concurrency/02_rwmutex/","title":"è¯»å†™é”","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" è¯»å†™é” # è¯»å†™äº’æ–¥é” sync.RWMutex æ˜¯ç»†ç²’åº¦çš„äº’æ–¥é”ï¼Œä¸€èˆ¬æ¥è¯´æœ‰å‡ ç§æƒ…å†µï¼š\nè¯»é”ä¹‹é—´ä¸äº’æ–¥ å†™é”ä¹‹é—´æ˜¯äº’æ–¥çš„ å†™é”ä¸è¯»é”æ˜¯äº’æ–¥çš„ sync.RWMutex ç±»å‹ä¸­çš„ Lock æ–¹æ³•å’Œ Unlock æ–¹æ³•ç”¨äºå¯¹å†™é”è¿›è¡Œé”å®šå’Œè§£é”ï¼ŒRLock æ–¹æ³•å’Œ RUnlock æ–¹æ³•åˆ™åˆ†åˆ«ç”¨äºå¯¹è¯»é”è¿›è¡Œé”å®šå’Œè§£é”ã€‚\nåŸç† # type RWMutex struct { w Mutex // å¤ç”¨äº’æ–¥é”æä¾›çš„èƒ½åŠ›ï¼Œè§£å†³å¤šä¸ª writer çš„ç«äº‰ writerSem uint32 // writer çš„ä¿¡å·é‡ readerSem uint32 // reader çš„ä¿¡å·é‡ readerCount atomic.Int32 // æ­£åœ¨æ‰§è¡Œçš„ reader çš„æ•°é‡ readerWait atomic.Int32 // å½“å†™æ“ä½œè¢«é˜»å¡æ—¶éœ€è¦ç­‰å¾… read å®Œæˆçš„ reader çš„æ•°é‡ } const rwmutexMaxReaders = 1 \u0026lt;\u0026lt; 30 rwmutexMaxReadersï¼šå®šä¹‰äº†æœ€å¤§çš„ reader æ•°é‡ã€‚\nRLock å’Œ RUnlock # ç§»é™¤äº† race ç­‰æ— å…³ç´§è¦çš„ä»£ç ï¼š\nfunc (rw *RWMutex) RLock() { if rw.readerCount.Add(1) \u0026lt; 0 { // rw.readerCount æ˜¯è´Ÿå€¼ï¼Œæ„å‘³ç€æ­¤æ—¶æœ‰å…¶ä»– goroutine è·å¾—äº†å†™é” // å½“å‰ goroutine å°±ä¼šè°ƒç”¨ runtime_SemacquireRWMutexR é™·å…¥ä¼‘çœ ç­‰å¾…é”çš„é‡Šæ”¾ runtime_SemacquireRWMutexR(\u0026amp;rw.readerSem, false, 0) } } func (rw *RWMutex) RUnlock() { // å…ˆå‡å°‘æ­£åœ¨è¯»èµ„æºçš„ readerCount æ•´æ•° // å¦‚æœè¿”å›å€¼å¤§äºç­‰äºé›¶ï¼Œè¯»é”ç›´æ¥è§£é”æˆåŠŸ if r := rw.readerCount.Add(-1); r \u0026lt; 0 { // å¦‚æœè¿”å›å€¼å°äºé›¶ï¼Œæœ‰ä¸€ä¸ªæ­£åœ¨æ‰§è¡Œçš„å†™æ“ä½œ rw.rUnlockSlow(r) } } func (rw *RWMutex) rUnlockSlow(r int32) { // å‡å°‘ readerWait if rw.readerWait.Add(-1) == 0 { // åœ¨æ‰€æœ‰è¯»æ“ä½œéƒ½è¢«é‡Šæ”¾ä¹‹åè§¦å‘å†™æ“ä½œçš„ä¿¡å·é‡ writerSemï¼Œ // è¯¥ä¿¡å·é‡è¢«è§¦å‘æ—¶ï¼Œè°ƒåº¦å™¨å°±ä¼šå”¤é†’å°è¯•è·å–å†™é”çš„ goroutineã€‚ runtime_Semrelease(\u0026amp;rw.writerSem, false, 1) } } Lock å’Œ Unlock # ç§»é™¤äº† race ç­‰æ— å…³ç´§è¦çš„ä»£ç ï¼š\nfunc (rw *RWMutex) Lock() { // å†™é”åŠ é”ï¼Œå…¶ä»– goroutine åœ¨è·å–å†™é”æ—¶ä¼šè¿›å…¥è‡ªæ—‹æˆ–è€…ä¼‘çœ  rw.w.Lock() // å°† readerCount å˜ä¸ºè´Ÿæ•°ï¼Œé˜»å¡åç»­çš„è¯»æ“ä½œ r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders // å¦‚æœä»ç„¶æœ‰å…¶ä»– goroutine æŒæœ‰äº’æ–¥é”çš„è¯»é”ï¼Œå½“å‰ goroutine ä¼šè°ƒç”¨ runtime_SemacquireRWMutex è¿›å…¥ä¼‘çœ çŠ¶æ€ç­‰å¾…æ‰€æœ‰è¯»é”æ‰€æœ‰è€…æ‰§ // è¡Œç»“æŸåé‡Šæ”¾ writerSem ä¿¡å·é‡å°†å½“å‰åç¨‹å”¤é†’ if r != 0 \u0026amp;\u0026amp; rw.readerWait.Add(r) != 0 { runtime_SemacquireRWMutex(\u0026amp;rw.writerSem, false, 0) } } func (rw *RWMutex) Unlock() { // å°† readerCount å˜å›æ­£æ•°ï¼Œé‡Šæ”¾è¯»é” r := rw.readerCount.Add(rwmutexMaxReaders) if r \u0026gt;= rwmutexMaxReaders { race.Enable() fatal(\u0026#34;sync: Unlock of unlocked RWMutex\u0026#34;) } // é€šè¿‡ for å¾ªç¯é‡Šæ”¾æ‰€æœ‰å› ä¸ºè·å–è¯»é”è€Œé™·å…¥ç­‰å¾…çš„ goroutine for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0) } // é‡Šæ”¾å†™é” rw.w.Unlock() } è·å–å†™é”æ—¶ä¼šå…ˆé˜»å¡å†™é”çš„è·å–ï¼Œåé˜»å¡è¯»é”çš„è·å–ï¼Œè¿™ç§ç­–ç•¥èƒ½å¤Ÿä¿è¯è¯»æ“ä½œä¸ä¼šè¢«è¿ç»­çš„å†™æ“ä½œé¥¿æ­»ã€‚\n"},{"id":9,"href":"/golang-learn/docs/concurrency/03_waitgroup/","title":"WaitGroup","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" WaitGroup # sync.WaitGroup å¯ä»¥ç­‰å¾…ä¸€ç»„ goroutine çš„è¿”å›ï¼Œå¸¸ç”¨äºå¤„ç†æ‰¹é‡çš„å¹¶å‘ä»»åŠ¡ã€‚å®ƒæ˜¯å¹¶å‘å®‰å…¨çš„ã€‚\nä½¿ç”¨ # å¹¶å‘å‘é€ HTTP è¯·æ±‚çš„ç¤ºä¾‹ï¼š\nrequests := []*Request{...} wg := \u0026amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r) }(request) } wg.Wait() WaitGroup æä¾›äº†ä¸‰ä¸ªæ–¹æ³•ï¼š\nAddï¼šç”¨æ¥è®¾ç½® WaitGroup çš„è®¡æ•°å€¼ã€‚ Doneï¼šç”¨æ¥å°† WaitGroup çš„è®¡æ•°å€¼å‡ 1ï¼Œå…¶å®å°±æ˜¯è°ƒç”¨äº† Add(-1)ã€‚ Waitï¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•çš„ goroutine ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ° WaitGroup çš„è®¡æ•°å€¼å˜ä¸º 0ã€‚ ä¸è¦æŠŠ Add å’Œ Wait æ–¹æ³•çš„è°ƒç”¨æ”¾åœ¨ä¸åŒçš„ goroutine ä¸­æ‰§è¡Œï¼Œä»¥å… Add è¿˜æœªæ‰§è¡Œï¼ŒWait å·²ç»é€€å‡ºï¼š\nvar wg sync.WaitGroup go func(){ wg.Add(1) fmt.Println(\u0026#34;test\u0026#34;) }() wg.Wait() fmt.Println(\u0026#34;exit.\u0026#34;) sync.WaitGroup ç±»å‹å€¼ä¸­è®¡æ•°å™¨çš„å€¼å¯ä»¥å°äº 0 ä¹ˆï¼Ÿ # ä¸å¯ä»¥ã€‚å°äº 0ï¼Œä¼šå¼•å‘ panicã€‚æ‰€ä»¥å°½é‡ä¸è¦ä¼ é€’è´Ÿæ•°ç»™ Add æ–¹æ³•ï¼Œåªé€šè¿‡ Done æ¥ç»™è®¡æ•°å€¼å‡ 1ã€‚\nsync.WaitGroup å¯ä»¥å¤ç”¨ä¹ˆï¼Ÿ # å¯ä»¥ã€‚ä½†æ˜¯å¿…é¡»åœ¨ Wait æ–¹æ³•è¿”å›ä¹‹åæ‰èƒ½è¢«é‡æ–°ä½¿ç”¨ã€‚å¦åˆ™ä¼šå¼•å‘ panicã€‚æ‰€ä»¥å°½é‡ä¸è¦é‡ç”¨ WaitGroupã€‚æ–°å»ºä¸€ä¸ª WaitGroup ä¸ä¼šå¸¦æ¥å¤šå¤§çš„èµ„æº å¼€é”€ï¼Œé‡ç”¨åè€Œæ›´å®¹æ˜“å‡ºé”™ã€‚\nWait å¯ä»¥åœ¨å¤šä¸ª goroutine è°ƒç”¨å¤šæ¬¡ä¹ˆï¼Ÿ # å¯ä»¥ã€‚å½“å‰ sync.WaitGroup è®¡æ•°å™¨çš„å½’é›¶æ—¶ï¼Œè¿™äº› goroutine ä¼šè¢«åŒæ—¶å”¤é†’ã€‚\nåŸç† # sync.WaitGroup ç»“æ„ä½“ï¼š\n// src/sync/waitgroup.go#L20 type WaitGroup struct { noCopy noCopy state1 [3]uint32 } noCopy æ˜¯ go 1.7 å¼€å§‹å¼•å…¥çš„ä¸€ä¸ªé™æ€æ£€æŸ¥æœºåˆ¶ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªè¾…åŠ©ç±»å‹ï¼š\n// src/sync/cond.go#L117 type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. func (*noCopy) Lock() {} func (*noCopy) Unlock() {} tools/go/analysis/passes/copylock åŒ…ä¸­çš„åˆ†æå™¨ä¼šåœ¨ç¼–è¯‘æœŸé—´æ£€æŸ¥è¢«æ‹·è´çš„å˜é‡ä¸­æ˜¯å¦åŒ…å« noCopy æˆ–è€…å®ç°äº† Lock å’Œ Unlock æ–¹æ³•ï¼Œå¦‚æœåŒ…å«è¯¥ç»“æ„ä½“æˆ–è€…å®ç°äº†å¯¹åº”çš„æ–¹æ³•å°±ä¼šæŠ¥é”™ï¼š\n$ go vet proc.go ./prog.go:10:10: assignment copies lock value to yawg: sync.WaitGroup ./prog.go:11:14: call of fmt.Println copies lock value: sync.WaitGroup ./prog.go:11:18: call of fmt.Println copies lock value: sync.WaitGroup state1 åŒ…å«ä¸€ä¸ªæ€»å…±å ç”¨ 12 å­—èŠ‚çš„æ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„ä¼šå­˜å‚¨å½“å‰ç»“æ„ä½“çš„çŠ¶æ€ï¼Œåœ¨ 64 ä½ä¸ 32 ä½çš„æœºå™¨ä¸Šè¡¨ç°ä¹Ÿéå¸¸ä¸åŒã€‚\nstate æ–¹æ³•ç”¨æ¥ä» state1 å­—æ®µä¸­å–å‡ºå®ƒçš„çŠ¶æ€å’Œä¿¡å·é‡ã€‚\n// å¾—åˆ° state çš„åœ°å€å’Œä¿¡å·é‡çš„åœ°å€ func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // å¦‚æœåœ°å€æ˜¯ 64bit å¯¹é½çš„ï¼Œæ•°ç»„å‰ä¸¤ä¸ªå…ƒç´ åš stateï¼Œåä¸€ä¸ªå…ƒç´ åšä¿¡å·é‡ return (*uint64)(unsafe.Pointer(\u0026amp;wg.state1)), \u0026amp;wg.state1[2] } else { // å¦‚æœåœ°å€æ˜¯ 32bit å¯¹é½çš„ï¼Œæ•°ç»„åä¸¤ä¸ªå…ƒç´ ç”¨æ¥åš stateï¼Œå®ƒå¯ä»¥ç”¨æ¥åš 64bit çš„åŸå­æ“ä½œï¼Œç¬¬ä¸€ä¸ªå…ƒç´  32bit ç”¨æ¥åšä¿¡å·é‡ return (*uint64)(unsafe.Pointer(\u0026amp;wg.state1[1])), \u0026amp;wg.state1[0] } } Add çš„å®ç°ï¼š\nfunc (wg *WaitGroup) Add(delta int) { statep, semap := wg.state() // é«˜ 32bit æ˜¯è®¡æ•°å€¼ vï¼Œæ‰€ä»¥æŠŠ delta å·¦ç§» 32ï¼Œæ›´æ–°è®¡æ•°å™¨ counter state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) v := int32(state \u0026gt;\u0026gt; 32) // å½“å‰è®¡æ•°å€¼ w := uint32(state) // waiter count if v \u0026lt; 0 { panic(\u0026#34;sync: negative WaitGroup counter\u0026#34;) } // å¹¶å‘çš„ Add ä¼šå¯¼è‡´ panic if w != 0 \u0026amp;\u0026amp; delta \u0026gt; 0 \u0026amp;\u0026amp; v == int32(delta) { panic(\u0026#34;sync: WaitGroup misuse: Add called concurrently with Wait\u0026#34;) } if v \u0026gt; 0 || w == 0 { return } // å°† waiter è°ƒç”¨è®¡æ•°å™¨å½’é›¶ï¼Œä¹Ÿå°±æ˜¯ *statep ç›´æ¥è®¾ç½®ä¸º 0 å³å¯ã€‚ // é€šè¿‡ sync.runtime_Semrelease å”¤é†’å¤„äºç­‰å¾…çŠ¶æ€çš„ goroutineã€‚ *statep = 0 for ; w != 0; w-- { runtime_Semrelease(semap, false, 0) } } // Done æ–¹æ³•å®é™…å°±æ˜¯è®¡æ•°å™¨å‡ 1 func (wg *WaitGroup) Done() { wg.Add(-1) } Wait æ–¹æ³•çš„å®ç°é€»è¾‘ï¼šä¸æ–­æ£€æŸ¥ state çš„å€¼ã€‚å¦‚æœå…¶ä¸­çš„è®¡æ•°å€¼å˜ä¸ºäº† 0ï¼Œé‚£ä¹ˆè¯´æ˜æ‰€æœ‰çš„ä»»åŠ¡å·²å®Œæˆï¼Œè°ƒç”¨è€…ä¸å¿…å†ç­‰å¾…ï¼Œç›´æ¥è¿”å›ã€‚å¦‚æœè®¡æ•°å€¼å¤§äº 0ï¼Œè¯´æ˜æ­¤æ—¶è¿˜æœ‰ä»» åŠ¡æ²¡å®Œæˆï¼Œé‚£ä¹ˆè°ƒç”¨è€…å°±å˜æˆäº†ç­‰å¾…è€…ï¼Œéœ€è¦åŠ å…¥ waiter é˜Ÿåˆ—ï¼Œå¹¶ä¸”é˜»å¡ä½è‡ªå·±ã€‚\nfunc (wg *WaitGroup) Wait() { statep, semap := wg.state() for { state := atomic.LoadUint64(statep) v := int32(state \u0026gt;\u0026gt; 32) // å½“å‰è®¡æ•°å€¼ w := uint32(state) // waiter çš„æ•°é‡ if v == 0 { // å¦‚æœè®¡æ•°å€¼ä¸º 0, è°ƒç”¨è¿™ä¸ªæ–¹æ³•çš„ goroutine ä¸å¿…å†ç­‰å¾…ï¼Œç»§ç»­æ‰§è¡Œå®ƒåé¢çš„é€»è¾‘å³å¯ return } // å¦åˆ™æŠŠ waiter æ•°é‡åŠ  1ã€‚æœŸé—´å¯èƒ½æœ‰å¹¶å‘è°ƒç”¨ Wait çš„æƒ…å†µï¼Œæ‰€ä»¥æœ€å¤–å±‚ä½¿ç”¨äº†ä¸€ä¸ª for å¾ªç¯ if atomic.CompareAndSwapUint64(statep, state, state+1) { // é˜»å¡ä¼‘çœ ç­‰å¾… runtime_Semacquire(semap) // è¢«å”¤é†’ï¼Œä¸å†é˜»å¡ï¼Œè¿”å› return } } } "},{"id":10,"href":"/golang-learn/docs/basic/03_slice/","title":"åˆ‡ç‰‡","section":"ğŸš è¯­è¨€åŸºç¡€","content":" åˆ‡ç‰‡ # åˆ‡ç‰‡ (slice) åœ¨ä½¿ç”¨ä¸Šå’Œæ•°ç»„å·®ä¸å¤šï¼ŒåŒºåˆ«æ˜¯åˆ‡ç‰‡æ˜¯å¯å˜é•¿çš„ï¼Œå®šä¹‰çš„æ—¶å€™ä¸éœ€è¦æŒ‡å®š sizeã€‚\nåˆ‡ç‰‡å¯ä»¥çœ‹åšæ˜¯å¯¹æ•°ç»„çš„ä¸€å±‚ç®€å•çš„å°è£…ï¼Œåˆ‡ç‰‡çš„åº•å±‚æ•°æ®ç»“æ„ä¸­ï¼ŒåŒ…å«äº†ä¸€ä¸ªæ•°ç»„ã€‚\nåˆ‡ç‰‡çš„ç»“æ„ä½“ï¼š\n// src/reflect/value.go type SliceHeader struct { Data uintptr // æŒ‡å‘åº•å±‚æ•°ç»„ Len int // å½“å‰åˆ‡ç‰‡é•¿åº¦ Cap int // å½“å‰åˆ‡ç‰‡å®¹é‡ } æ³¨æ„ Cap ä¹Ÿæ˜¯åº•å±‚æ•°ç»„çš„é•¿åº¦ã€‚Data æ˜¯ä¸€å—è¿ç»­çš„å†…å­˜ï¼Œå¯ä»¥å­˜å‚¨åˆ‡ç‰‡ Cap å¤§å°çš„æ‰€æœ‰å…ƒç´ ã€‚\nå¦‚å›¾ï¼Œè™½ç„¶ slice çš„ Len æ˜¯ 5ï¼Œä½†æ˜¯åº•å±‚æ•°ç»„çš„é•¿åº¦æ˜¯ 10ï¼Œä¹Ÿå°±æ˜¯ Capã€‚\nåˆå§‹åŒ– # åˆå§‹åŒ–åˆ‡ç‰‡æœ‰ä¸‰ç§æ–¹å¼ï¼š\nä½¿ç”¨ make // len æ˜¯åˆ‡ç‰‡çš„åˆå§‹é•¿åº¦ // capacity ä¸ºå¯é€‰å‚æ•°, æŒ‡å®šå®¹é‡ s := make([]int, len, capacity) ä½¿ç”¨å­—é¢é‡ arr :=[]int{1,2,3} ä½¿ç”¨ä¸‹æ ‡æˆªå–æ•°ç»„æˆ–è€…åˆ‡ç‰‡çš„ä¸€éƒ¨åˆ†ï¼Œè¿™é‡Œå¯ä»¥ä¼ å…¥ä¸‰ä¸ªå‚æ•° [low:high:max]ï¼Œmax - low æ˜¯æ–°çš„åˆ‡ç‰‡çš„å®¹é‡ capã€‚ numbers := []int{0,1,2,3,4,5,6,7,8} s := numbers[1:4] // [1 2 3] s := numbers[4:] // [4 5 6 7 8] s := numbers[:3]) // [0 1 2] ã€ŠGo å­¦ä¹ ç¬”è®°ã€‹ ç¬¬å››ç‰ˆ ä¸­çš„ç¤ºä¾‹ï¼š\npackage main import \u0026#34;fmt\u0026#34; func main() { slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := slice[2:5] s2 := s1[2:6:7] s2 = append(s2, 100) s2 = append(s2, 200) s1[2] = 20 fmt.Println(s1) fmt.Println(s2) fmt.Println(slice) } è¾“å‡ºï¼š\n[2 3 20] [4 5 6 7 100 200] [0 1 2 3 20 5 6 7 100 9] ç¤ºä¾‹ä¸­ï¼š\ns1 := slice[2:5] å¾—åˆ°çš„ s1 çš„å®¹é‡ä¸º 8ï¼Œå› ä¸ºæ²¡æœ‰ä¼ å…¥ maxï¼Œå®¹é‡é»˜è®¤æ˜¯åˆ°åº•å±‚æ•°ç»„çš„ç»“å°¾ã€‚ s2 := s1[2:6:7] å¾—åˆ°çš„ s2 çš„å®¹é‡ä¸º 5ï¼ˆmax - lowï¼‰ã€‚s2ï¼Œs1 å’Œ slice åº•å±‚æ•°ç»„æ˜¯åŒä¸€ä¸ªï¼Œæ‰€ä»¥ s2 ä¸­çš„å…ƒç´ æ˜¯ [4,5,6,7]ã€‚ ä¸‹é¢çš„ s2 = append(s2, 100) è¿½åŠ ä¸€ä¸ªå…ƒç´ ï¼Œå®¹é‡å¤Ÿç”¨ï¼Œä¸éœ€è¦æ‰©å®¹ï¼Œä½†æ˜¯è¿™ä¸ªä¿®æ”¹ä¼šå½±å“æ‰€æœ‰æŒ‡å‘è¿™ä¸ªåº•å±‚æ•°ç»„çš„åˆ‡ç‰‡ã€‚\nå†æ¬¡è¿½åŠ ä¸€ä¸ªå…ƒç´  s2 = append(s2, 200)ï¼Œs2 çš„å®¹é‡ä¸å¤Ÿäº†ï¼Œéœ€è¦æ‰©å®¹ï¼Œäºæ˜¯ s2 ç”³è¯·ä¸€å—æ–°çš„è¿ç»­å†…å­˜ï¼Œå¹¶å°†æ•°æ®æ‹·è´è¿‡å»ï¼Œæ‰©å®¹åçš„å®¹é‡æ˜¯åŸæ¥çš„ 2 å€ã€‚ è¿™æ—¶å€™ s2 çš„ Data æŒ‡å‘äº†æ–°çš„åº•å±‚æ•°ç»„ï¼Œå·²ç»å’Œ s1 slice æ²¡æœ‰å…³ç³»äº†ï¼Œå¯¹ s2 çš„ä¿®æ”¹ä¸ä¼šå†å½±å“ s1 sliceã€‚\næœ€å s1[2] = 20 ä¹Ÿä¸ä¼šå†å½±å“ s2ã€‚\nåˆ‡ç‰‡æ˜¯å¦‚ä½•æ‰©å®¹çš„ï¼Ÿ # append æ˜¯ç”¨æ¥å‘ slice è¿½åŠ å…ƒç´ çš„ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°çš„ sliceã€‚\nappend å®é™…ä¸Šå°±æ˜¯å‘åº•å±‚æ•°ç»„æ·»åŠ å…ƒç´ ï¼Œä½†æ˜¯æ•°ç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼š\nå½“è¿½åŠ å…ƒç´ ååˆ‡ç‰‡çš„å¤§å°å¤§äºå®¹é‡ï¼Œruntime ä¼šå¯¹åˆ‡ç‰‡è¿›è¡Œæ‰©å®¹ï¼Œè¿™æ—¶ä¼šç”³è¯·ä¸€å—æ–°çš„è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œç„¶åå°†åŸæ•°æ®æ‹·è´åˆ°æ–°çš„å†…å­˜ç©ºé—´ï¼Œå¹¶ä¸”å°† append çš„å…ƒç´ æ·»åŠ åˆ°æ–°çš„åº•å±‚æ•°ç»„ä¸­ï¼Œå¹¶è¿”å›è¿™ä¸ªæ–°çš„åˆ‡ç‰‡ã€‚\nGo 1.18 ååˆ‡ç‰‡çš„æ‰©å®¹ç­–ç•¥ï¼š\nå¦‚æœå½“å‰åˆ‡ç‰‡çš„å®¹é‡ï¼ˆoldcapï¼‰å°äº 256ï¼Œæ–°åˆ‡ç‰‡çš„å®¹é‡ï¼ˆnewcapï¼‰ä¸ºåŸæ¥çš„ 2 å€. å¦‚æœå½“å‰åˆ‡ç‰‡çš„å®¹é‡å¤§äº 256ï¼Œè®¡ç®—æ–°åˆ‡ç‰‡çš„å®¹é‡çš„å…¬å¼ newcap = oldcap+(oldcap+3*256)/4 åˆ‡ç‰‡ä¼ å…¥å‡½æ•° # Go æ˜¯å€¼ä¼ é€’ã€‚é‚£ä¹ˆä¼ å…¥ä¸€ä¸ªåˆ‡ç‰‡ï¼Œåˆ‡ç‰‡ä¼šä¸ä¼šè¢«å‡½æ•°ä¸­çš„æ“ä½œæ”¹å˜ï¼Ÿ\nä¸ç®¡ä¼ å…¥çš„æ˜¯åˆ‡ç‰‡è¿˜æ˜¯åˆ‡ç‰‡æŒ‡é’ˆï¼Œå¦‚æœæ”¹å˜äº†åº•å±‚æ•°ç»„ï¼ŒåŸåˆ‡ç‰‡çš„åº•å±‚æ•°ç»„ä¹Ÿä¼šè¢«æ”¹å˜ã€‚\nç¤ºä¾‹ï¼š\npackage main import \u0026#34;fmt\u0026#34; func appendFunc(s []int) { s = append(s, 10, 20, 30) } func appendPtrFunc(s *[]int) { *s = append(*s, 10, 20, 30) } func main() { sl := make([]int, 0, 10) appendFunc(sl) // appendFunc ä¿®æ”¹çš„æ˜¯ sl çš„å‰¯æœ¬ï¼Œlen å’Œ cap å¹¶æ²¡æœ‰è¢«ä¿®æ”¹ï¼Œä¸‹é¢çš„è¾“å‡ºæ˜¯ [] fmt.Println(sl) // [] // appendFuncï¼Œè™½ç„¶æ²¡æœ‰ä¿®æ”¹ len å’Œ capï¼Œä½†æ˜¯åº•å±‚æ•°ç»„æ˜¯è¢«ä¿®æ”¹äº†çš„ï¼Œæ‰€ä»¥ä¸‹é¢çš„è¾“å‡ºä¼šåŒ…å« 10 20 30 fmt.Println(sl[:10]) // [10 20 30 0 0 0 0 0 0 0] // ä¸ºä»€ä¹ˆ sl[:10] å’Œ sl[:] çš„è¾“å‡ºä¸åŒï¼Œæ˜¯å› ä¸º go çš„åˆ‡ç‰‡çš„ä¸€ä¸ªä¼˜åŒ– // slice[low:high] ä¸­çš„ highï¼Œæœ€å¤§çš„å–å€¼èŒƒå›´å¯¹åº”ç€åˆ‡ç‰‡çš„å®¹é‡ï¼ˆcapï¼‰ï¼Œä¸æ˜¯å•çº¯çš„é•¿åº¦ï¼ˆlenï¼‰ã€‚ // sl[:10] å¯ä»¥è¾“å‡ºå®¹é‡èŒƒå›´å†…çš„å€¼ï¼Œå¹¶ä¸”æ²¡æœ‰è¶Šç•Œã€‚ // sl[:] ç”±äº len ä¸º 0ï¼Œå¹¶ä¸”æ²¡æœ‰æŒ‡å®šæœ€å¤§ç´¢å¼•ã€‚high åˆ™ä¼šå– len çš„å€¼ï¼Œæ‰€ä»¥è¾“å‡ºä¸º [] fmt.Println(sl[:]) // [] slptr := make([]int, 0, 10) appendPtrFunc(\u0026amp;slptr) // è¿™é‡Œä¼ å…¥çš„æ˜¯åˆ‡ç‰‡çš„æŒ‡é’ˆï¼Œä¼šæ”¹å˜å¤–å±‚çš„ slptr fmt.Println(slptr) // [10 20 30] } "},{"id":11,"href":"/golang-learn/docs/project/03_gsemver/","title":"ç‰ˆæœ¬è§„èŒƒ","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" ç‰ˆæœ¬è§„èŒƒ # gsemver æ˜¯ä¸€ä¸ªç”¨ Goï¼ˆGolangï¼‰å¼€å‘çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œå®ƒä½¿ç”¨ git commit æ¥è‡ªåŠ¨ç”Ÿæˆç¬¦åˆ semver 2.0.0 è§„èŒƒçš„ä¸‹ä¸€ä¸ªç‰ˆæœ¬ã€‚\nå®‰è£… # $ go install github.com/arnaud-deprez/gsemver@latest ä½¿ç”¨ # ä¸‹é¢çš„å‘½ä»¤ä¼šä½¿ç”¨ git commit ç”Ÿæˆä¸‹ä¸€ä¸ª versionï¼š\ngsemver bump é…ç½® # ä½ å¯ä»¥ä½¿ç”¨ä¸€ä¸ªé…ç½®æ–‡ä»¶æ¥å®šä¹‰ä½ è‡ªå·±çš„è§„åˆ™ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼šå¯»æ‰¾ .gsemver.yaml æˆ– $HOME/.gsemver.yamlï¼Œå¯ä»¥é€šè¿‡ --configï¼ˆæˆ– -cï¼‰é€‰é¡¹æ¥æŒ‡å®šä½ è‡ªå·±çš„é…ç½®æ–‡ä»¶ã€‚\n"},{"id":12,"href":"/golang-learn/docs/project/04_flow/","title":"Git å·¥ä½œæµç¨‹","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" Git å·¥ä½œæµç¨‹ # "},{"id":13,"href":"/golang-learn/docs/practice/04_pprof/","title":"Go æ€§èƒ½åˆ†æ","section":"ğŸ› ï¸ å®è·µ","content":" Go æ€§èƒ½åˆ†æ # PProf æ˜¯ Go æä¾›çš„ç”¨äºå¯è§†åŒ–å’Œåˆ†ææ€§èƒ½åˆ†ææ•°æ®çš„å·¥å…·ã€‚\nruntime/pprofï¼šé‡‡é›†ç¨‹åºï¼ˆé Serverï¼‰çš„è¿è¡Œæ•°æ®è¿›è¡Œåˆ†æ net/http/pprofï¼šé‡‡é›† HTTP Server çš„è¿è¡Œæ—¶æ•°æ®è¿›è¡Œåˆ†æ ä¸»è¦å¯ä»¥ç”¨äºï¼š\nCPU Profilingï¼šCPU åˆ†æï¼ŒæŒ‰ç…§ä¸€å®šçš„é¢‘ç‡é‡‡é›†æ‰€ç›‘å¬çš„åº”ç”¨ç¨‹åº CPUï¼ˆå«å¯„å­˜å™¨ï¼‰çš„ä½¿ç”¨æƒ…å†µï¼Œå¯ç¡®å®šåº”ç”¨ç¨‹åºåœ¨ä¸»åŠ¨æ¶ˆè€— CPU å‘¨æœŸ æ—¶èŠ±è´¹æ—¶é—´çš„ä½ç½®ã€‚ Memory Profilingï¼šå†…å­˜åˆ†æï¼Œåœ¨åº”ç”¨ç¨‹åºè¿›è¡Œå †åˆ†é…æ—¶è®°å½•å †æ ˆè·Ÿè¸ªï¼Œç”¨äºç›‘è§†å½“å‰å’Œå†å²å†…å­˜ä½¿ç”¨æƒ…å†µï¼Œä»¥åŠæ£€æŸ¥å†…å­˜æ³„æ¼ã€‚ Block Profilingï¼šé˜»å¡åˆ†æï¼Œè®°å½• goroutine é˜»å¡ç­‰å¾…åŒæ­¥ï¼ˆåŒ…æ‹¬å®šæ—¶å™¨é€šé“ï¼‰çš„ä½ç½®ã€‚ Mutex Profilingï¼šäº’æ–¥é”åˆ†æï¼ŒæŠ¥å‘Šäº’æ–¥é”çš„ç«äº‰æƒ…å†µã€‚ æ€§èƒ½åˆ†æ # åˆ†æ HTTP Server # Web # import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; _ \u0026#34;net/http/pprof\u0026#34; ) var datas []string func Add(str string) string { data := []byte(str) sData := string(data) datas = append(datas, sData) return sData } func main() { go func() { for { log.Println(Add(\u0026#34;https://github.com/shipengqi\u0026#34;)) } }() _ = http.ListenAndServe(\u0026#34;0.0.0.0:8080\u0026#34;, nil) } æ³¨æ„è¦å¼•å…¥ _ \u0026quot;net/http/pprof\u0026quot;ï¼Œè¿™æ ·ç¨‹åºè¿è¡Œä»¥åï¼Œå°±ä¼šè‡ªåŠ¨æ·»åŠ  /debug/pprof çš„è·¯ç”±ï¼Œå¯ä»¥ è®¿é—® ttp://127.0.0.1:8080/debug/pprof/ã€‚\nalloc: æŸ¥çœ‹æ‰€æœ‰å†…å­˜åˆ†é…çš„æƒ…å†µ blockï¼ˆBlock Profilingï¼‰ï¼š$HOST/debug/pprof/blockï¼ŒæŸ¥çœ‹å¯¼è‡´é˜»å¡åŒæ­¥çš„å †æ ˆè·Ÿè¸ª cmdline : å½“å‰ç¨‹åºçš„å‘½ä»¤è¡Œè°ƒç”¨ goroutineï¼š$HOST/debug/pprof/goroutineï¼ŒæŸ¥çœ‹å½“å‰æ‰€æœ‰è¿è¡Œçš„ goroutines å †æ ˆè·Ÿè¸ª heapï¼ˆMemory Profilingï¼‰: $HOST/debug/pprof/heapï¼ŒæŸ¥çœ‹æ´»åŠ¨å¯¹è±¡çš„å†…å­˜åˆ†é…æƒ…å†µï¼Œåœ¨è·å–å †æ ·æœ¬ä¹‹å‰ï¼Œå¯ä»¥æŒ‡å®š gc GET å‚æ•°æ¥è¿è¡Œ gcã€‚ mutexï¼ˆMutex Profilingï¼‰: $HOST/debug/pprof/mutexï¼ŒæŸ¥çœ‹å¯¼è‡´äº’æ–¥é”çš„ç«äº‰æŒæœ‰è€…çš„å †æ ˆè·Ÿè¸ª profile: $HOST/debug/pprof/profileï¼Œ é»˜è®¤è¿›è¡Œ 30s çš„ CPU Profilingï¼Œå¯ä»¥ GET å‚æ•° seconds ä¸­æŒ‡å®šæŒç»­æ—¶é—´ã€‚ è·å¾— profile æ–‡ä»¶ä¹‹åï¼Œä½¿ç”¨ go tool pprof å‘½ä»¤åˆ†æ profile æ–‡ä»¶ã€‚ threadcreateï¼š$HOST/debug/pprof/threadcreateï¼ŒæŸ¥çœ‹åˆ›å»ºæ–° OS çº¿ç¨‹çš„å †æ ˆè·Ÿè¸ª trace: å½“å‰ç¨‹åºçš„æ‰§è¡Œè½¨è¿¹ã€‚å¯ä»¥åœ¨ GET å‚æ•° seconds ä¸­æŒ‡å®šæŒç»­æ—¶é—´ã€‚è·å–è·Ÿè¸ªæ–‡ä»¶ä¹‹åï¼Œä½¿ç”¨ go tool trace å‘½ä»¤æ¥åˆ†æã€‚ äº¤äº’å¼ç»ˆç«¯ # # seconds å¯ä»¥è°ƒæ•´ç­‰å¾…çš„æ—¶é—´ï¼Œå½“å‰å‘½ä»¤è®¾ç½®ç­‰å¾… 60 ç§’åä¼šè¿›è¡Œ CPU Profiling go tool pprof http://localhost:8080/debug/pprof/profile?seconds=60 Fetching profile over HTTP from http://localhost:6060/debug/pprof/profile?seconds=10 Saved profile in C:\\Users\\shipeng.CORPDOM\\pprof\\pprof.samples.cpu.001.pb.gz Type: cpu Time: Nov 18, 2019 at 11:08am (CST) Duration: 10.20s, Total samples = 10.03s (98.38%) Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) # è¿›å…¥äº¤äº’å¼å‘½ä»¤æ¨¡å¼ (pprof) top 10 Showing nodes accounting for 9.54s, 95.11% of 10.03s total Dropped 73 nodes (cum \u0026lt;= 0.05s) Showing top 10 nodes out of 14 flat flat% sum% cum cum% 9.42s 93.92% 93.92% 9.46s 94.32% runtime.cgocall 0.02s 0.2% 94.12% 9.62s 95.91% internal/poll.(*FD).writeConsole 0.02s 0.2% 94.32% 9.81s 97.81% log.(*Logger).Output 0.02s 0.2% 94.52% 0.10s 1% log.(*Logger).formatHeader 0.02s 0.2% 94.72% 0.06s 0.6% main.Add 0.02s 0.2% 94.92% 9.50s 94.72% syscall.Syscall6 0.01s 0.1% 95.01% 0.07s 0.7% runtime.systemstack 0.01s 0.1% 95.11% 9.51s 94.82% syscall.WriteConsole 0 0% 95.11% 0.07s 0.7% fmt.Sprintln 0 0% 95.11% 9.69s 96.61% internal/poll.(*FD).Write ä¸Šé¢çš„è¾“å‡ºï¼š\nflatï¼šç»™å®šå‡½æ•°ä¸Šè¿è¡Œè€—æ—¶ flat%ï¼šåŒä¸Šçš„ CPU è¿è¡Œè€—æ—¶æ€»æ¯”ä¾‹ sum%ï¼šç»™å®šå‡½æ•°ç´¯ç§¯ä½¿ç”¨ CPU æ€»æ¯”ä¾‹ cumï¼šå½“å‰å‡½æ•°åŠ ä¸Šå®ƒä¹‹ä¸Šçš„è°ƒç”¨è¿è¡Œæ€»è€—æ—¶ cum%ï¼šåŒä¸Šçš„ CPU è¿è¡Œè€—æ—¶æ€»æ¯”ä¾‹ æœ€åä¸€åˆ—ä¸ºå‡½æ•°åç§° go tool pprof http://localhost:6060/debug/pprof/heap Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap Saved profile in C:\\Users\\shipeng.CORPDOM\\pprof\\pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.008.pb.gz Type: inuse_space Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) (pprof) top Showing nodes accounting for 837.48MB, 100% of 837.48MB total flat flat% sum% cum cum% 837.48MB 100% 100% 837.48MB 100% main.main.func1 # å…¶ä»–åˆ†æ go tool pprof http://localhost:6060/debug/pprof/block go tool pprof http://localhost:6060/debug/pprof/mutex -inuse_spaceï¼šåˆ†æåº”ç”¨ç¨‹åºçš„å¸¸é©»å†…å­˜å ç”¨æƒ…å†µ -alloc_objectsï¼šåˆ†æåº”ç”¨ç¨‹åºçš„å†…å­˜ä¸´æ—¶åˆ†é…æƒ…å†µ PProf å¯è§†åŒ–ç•Œé¢ # data.goï¼š\npackage pdata var datas []string func Add(str string) string { data := []byte(str) sData := string(data) datas = append(datas, sData) return sData } data_test.goï¼š\npackage pdata import \u0026#34;testing\u0026#34; const url = \u0026#34;https://github.com/\u0026#34; func TestAdd(t *testing.T) { s := Add(url) if s == \u0026#34;\u0026#34; { t.Errorf(\u0026#34;Test.Add error!\u0026#34;) } } func BenchmarkAdd(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { Add(url) } } è¿è¡ŒåŸºå‡†æµ‹è¯•ï¼š\n# ä¸‹é¢çš„å‘½ä»¤ä¼šç”Ÿæˆ cprof æ–‡ä»¶, ä½¿ç”¨ go tool pprof åˆ†æ go test -bench . -cpuprofile=cprof goos: windows goarch: amd64 pkg: github.com/shipengqi/golang-learn/demos/pprof/pdata BenchmarkAdd-8 10084636 143 ns/op PASS ok github.com/shipengqi/golang-learn/demos/pprof/pdata 2.960s å¯åŠ¨å¯è§†åŒ–ç•Œé¢ï¼š\n$ go tool pprof -http=:8080 cpu.prof # æˆ–è€… $ go tool pprof cpu.prof $ (pprof) web å¦‚æœå‡ºç° Could not execute dot; may need to install graphviz.ï¼Œå‚è€ƒ \u0026ldquo;å®‰è£ Graphviz\u0026rdquo;\nä¸Šå›¾ä¸­çš„æ¡†è¶Šå¤§ï¼Œçº¿è¶Šç²—ä»£è¡¨å®ƒæ¶ˆè€—çš„æ—¶é—´è¶Šé•¿ã€‚\nPProf çš„å¯è§†åŒ–ç•Œé¢èƒ½å¤Ÿæ›´æ–¹ä¾¿ã€æ›´ç›´è§‚çš„çœ‹åˆ° Go åº”ç”¨ç¨‹åºçš„è°ƒç”¨é“¾ã€ä½¿ç”¨æƒ…å†µç­‰ã€‚\nç«ç„°å›¾ï¼š å®‰è£ Graphviz # å®˜ç½‘ ä¸‹è½½åœ°å€\né…ç½®ç¯å¢ƒå˜é‡ # å°† bin ç›®å½•æ·»åŠ åˆ° Path ç¯å¢ƒå˜é‡ä¸­ï¼Œå¦‚ C:\\Program Files (x86)\\Graphviz2.38\\binã€‚\néªŒè¯ # dot -version éƒ¨åˆ†å†…å®¹æ¥è‡ª Go å¤§æ€å™¨ä¹‹æ€§èƒ½å‰–æ PProf\n"},{"id":14,"href":"/golang-learn/docs/basic/04_map/","title":"å“ˆå¸Œè¡¨","section":"ğŸš è¯­è¨€åŸºç¡€","content":" å“ˆå¸Œè¡¨ # map æ˜¯ä¸€ä¸ªæ— åºçš„ key/value å¯¹çš„é›†åˆï¼ŒåŒä¸€ä¸ª key åªä¼šå‡ºç°ä¸€æ¬¡ã€‚\nå“ˆå¸Œè¡¨çš„è®¾è®¡åŸç† # å“ˆå¸Œè¡¨å…¶å®æ˜¯æ•°ç»„çš„æ‰©å±•ã€‚å“ˆå¸Œè¡¨æ˜¯åˆ©ç”¨æ•°ç»„å¯ä»¥æ ¹æ®ä¸‹æ ‡éšæœºè®¿é—®ï¼ˆæ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼‰è¿™ä¸€ç‰¹æ€§æ¥å®ç°å¿«é€ŸæŸ¥æ‰¾çš„ã€‚\nå“ˆå¸Œå‡½æ•° # å“ˆå¸Œè¡¨æ˜¯é€šè¿‡å“ˆå¸Œå‡½æ•°å°† key è½¬åŒ–ä¸ºæ•°ç»„çš„ä¸‹æ ‡ï¼Œç„¶åå°†æ•°æ®å­˜å‚¨åœ¨æ•°ç»„ä¸‹æ ‡å¯¹åº”çš„ä½ç½®ã€‚æŸ¥è¯¢æ—¶ï¼Œä¹Ÿæ˜¯åŒæ ·çš„ä½¿ç”¨å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ•°ç»„ä¸‹æ ‡ï¼Œä»ä¸‹æ ‡å¯¹åº”çš„ä½ç½®å–å‡ºæ•°æ®ã€‚\nå“ˆå¸Œå‡½æ•°çš„åŸºæœ¬è¦æ±‚ï¼š\nå“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ¥çš„å€¼æ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ã€‚ å¦‚æœ key1 == key2 é‚£ä¹ˆ hash(key1) == hash(key2) å¦‚æœ key1 != key2 é‚£ä¹ˆ hash(key1) != hash(key2) ç¬¬ä¸‰ç‚¹ï¼Œæƒ³è¦å®ç°ä¸€ä¸ªä¸åŒçš„ key å¯¹åº”çš„å“ˆå¸Œå€¼ç»å¯¹ä¸ä¸€æ ·çš„å“ˆå¸Œå‡½æ•°ï¼Œå‡ ä¹æ˜¯ä¸å¯èƒ½çš„ï¼Œä¹Ÿå°±è¯´æ— æ³•é¿å…å“ˆå¸Œå†²çªã€‚\nå¸¸ç”¨çš„å¤„ç†å“ˆå¸Œå†²çªçš„æ–¹æ³•æœ‰ä¸¤ç§ï¼šå¼€æ”¾å¯»å€æ³•å’Œé“¾è¡¨æ³•ã€‚\nå¼€æ”¾å¯»å€æ³• # å¼€æ”¾å¯»å€æ³•æ ¸å¿ƒæ€æƒ³æ˜¯ï¼Œå¦‚æœå‡ºç°äº†å“ˆå¸Œå†²çªï¼Œå°±é‡æ–°æ¢æµ‹ä¸€ä¸ªç©ºé—²ä½ç½®ï¼Œå°†å…¶æ’å…¥ã€‚\nä¸Šå›¾è“è‰²è¡¨ç¤ºå·²ç»æ’å…¥çš„å…ƒç´ ï¼Œkey9 å“ˆå¸Œåå¾—åˆ°çš„æ•°ç»„ä¸‹æ ‡ä¸º 6ï¼Œä½†æ˜¯å·²ç»æœ‰æ•°æ®äº†ï¼Œäº§ç”Ÿäº†å†²çªã€‚é‚£ä¹ˆå°±æŒ‰é¡ºåºå‘åæŸ¥æ‰¾ç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªç©ºé—²çš„ä½ç½®ï¼Œå¦‚æœåˆ°æ•°ç»„çš„å°¾éƒ¨éƒ½æ²¡æœ‰æ‰¾åˆ°ç©ºé—²çš„ä½ç½®ï¼Œå°±ä»å¤´å¼€å§‹ç»§ç»­æ‰¾ã€‚ ä¸Šå›¾æœ€ç»ˆæ‰¾åˆ°ä½ç½® 1 å¹¶æ’å…¥å…ƒç´ ã€‚\næŸ¥æ‰¾çš„é€»è¾‘å’Œæ’å…¥ç±»ä¼¼ï¼Œä»å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ¥çš„ä¸‹æ ‡ä½ç½®å¼€å§‹æŸ¥æ‰¾ï¼Œæ¯”è¾ƒæ•°ç»„ä¸­ä¸‹æ ‡ä½ç½®çš„å…ƒç´ å’Œè¦æŸ¥æ‰¾çš„å…ƒç´ ã€‚å¦‚æœç›¸ç­‰ï¼Œåˆ™è¯´æ˜å°±æ˜¯è¦æ‰¾çš„å…ƒç´ ï¼›å¦åˆ™å°±é¡ºåºå¾€åä¾æ¬¡æŸ¥æ‰¾ã€‚ç›´åˆ°æ‰¾åˆ°æ•°ç»„ä¸­çš„ç©ºé—²ä½ç½®ï¼Œè¿˜æ²¡æœ‰æ‰¾åˆ°ï¼Œå°±è¯´æ˜è¦æŸ¥æ‰¾çš„å…ƒç´ å¹¶æ²¡æœ‰åœ¨å“ˆå¸Œè¡¨ä¸­ã€‚\nå¯ä»¥çœ‹å‡ºå½“æ•°ç»„ä¸­ç©ºé—²ä½ç½®ä¸å¤šçš„æ—¶å€™ï¼Œå“ˆå¸Œå†²çªçš„æ¦‚ç‡å°±ä¼šå¤§å¤§æé«˜ã€‚è£…è½½å› å­ï¼ˆload factorï¼‰å°±æ˜¯ç”¨æ¥è¡¨ç¤ºç©ºä½çš„å¤šå°‘ã€‚\nè£…è½½å› å­=å·²æ’å…¥çš„å…ƒç´ ä¸ªæ•°/å“ˆå¸Œè¡¨çš„é•¿åº¦ è£…è½½å› å­è¶Šå¤§ï¼Œè¯´æ˜ç©ºé—²ä½ç½®è¶Šå°‘ï¼Œå†²çªè¶Šå¤šï¼Œå“ˆå¸Œè¡¨çš„æ€§èƒ½ä¼šä¸‹é™ã€‚\né“¾è¡¨æ³• # é“¾è¡¨æ³•æ˜¯æœ€å¸¸è§çš„å“ˆå¸Œå†²çªçš„è§£å†³åŠæ³•ã€‚åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œæ¯ä¸ªæ¡¶ï¼ˆbucketï¼‰ä¼šå¯¹åº”ä¸€æ¡é“¾è¡¨ï¼Œæ‰€æœ‰å“ˆå¸Œå€¼ç›¸åŒçš„å…ƒç´ éƒ½æ”¾åˆ°ç›¸åŒæ¡¶å¯¹åº”çš„é“¾è¡¨ä¸­ã€‚\næ’å…¥æ—¶ï¼Œå“ˆå¸Œå‡½æ•°è®¡ç®—åå¾—å‡ºå­˜æ”¾åœ¨å‡ å·æ¡¶ï¼Œç„¶åéå†æ¡¶ä¸­çš„é“¾è¡¨äº†ï¼š\næ‰¾åˆ°é”®ç›¸åŒçš„é”®å€¼å¯¹ï¼Œåˆ™æ›´æ–°é”®å¯¹åº”çš„å€¼ï¼› æ²¡æœ‰æ‰¾åˆ°é”®ç›¸åŒçš„é”®å€¼å¯¹ï¼Œåˆ™åœ¨é“¾è¡¨çš„æœ«å°¾è¿½åŠ æ–°çš„é”®å€¼å¯¹ é“¾è¡¨æ³•å®ç°çš„å“ˆå¸Œè¡¨çš„è£…è½½å› å­ï¼š\nè£…è½½å› å­=å·²æ’å…¥çš„å…ƒç´ ä¸ªæ•°/æ¡¶æ•°é‡ Go map åŸç† # è¡¨ç¤º map çš„ç»“æ„ä½“æ˜¯ hmapï¼š\n// src/runtime/map.go type hmap struct { // å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ æ•°é‡ count int // çŠ¶æ€æ ‡è¯†ï¼Œä¸»è¦æ˜¯ goroutine å†™å…¥å’Œæ‰©å®¹æœºåˆ¶çš„ç›¸å…³çŠ¶æ€æ§åˆ¶ã€‚å¹¶å‘è¯»å†™çš„åˆ¤æ–­æ¡ä»¶ä¹‹ä¸€å°±æ˜¯è¯¥å€¼ flags uint8 // å“ˆå¸Œè¡¨æŒæœ‰çš„ buckets æ•°é‡ï¼Œä½†æ˜¯å› ä¸ºå“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡éƒ½ 2 çš„å€æ•°ï¼Œ // æ‰€ä»¥è¯¥å­—æ®µä¼šå­˜å‚¨å¯¹æ•°ï¼Œä¹Ÿå°±æ˜¯ len(buckets) == 2^B B uint8 // æº¢å‡ºæ¡¶çš„æ•°é‡ noverflow uint16 // å“ˆå¸Œç§å­ï¼Œå®ƒèƒ½ä¸ºå“ˆå¸Œå‡½æ•°çš„ç»“æœå¼•å…¥éšæœºæ€§ï¼Œè¿™ä¸ªå€¼åœ¨åˆ›å»ºå“ˆå¸Œè¡¨æ—¶ç¡®å®šï¼Œå¹¶åœ¨è°ƒç”¨å“ˆå¸Œå‡½æ•°æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥ hash0 uint32 // æŒ‡å‘ buckets æ•°ç»„ï¼Œé•¿åº¦ä¸º 2^B buckets unsafe.Pointer // å“ˆå¸Œåœ¨æ‰©å®¹æ—¶ç”¨äºä¿å­˜ä¹‹å‰ buckets çš„å­—æ®µ // ç­‰é‡æ‰©å®¹çš„æ—¶å€™ï¼Œbuckets é•¿åº¦å’Œ oldbuckets ç›¸ç­‰ // åŒå€æ‰©å®¹çš„æ—¶å€™ï¼Œbuckets é•¿åº¦æ˜¯ oldbuckets çš„ä¸¤å€ oldbuckets unsafe.Pointer // è¿ç§»è¿›åº¦ï¼Œå°äºæ­¤åœ°å€çš„ buckets æ˜¯å·²è¿ç§»å®Œæˆçš„ nevacuate uintptr extra *mapextra } type mapextra struct { // hmap.buckets ï¼ˆå½“å‰ï¼‰æº¢å‡ºæ¡¶çš„æŒ‡é’ˆåœ°å€ overflow *[]*bmap // ä¸º hmap.oldbuckets ï¼ˆæ—§ï¼‰æº¢å‡ºæ¡¶çš„æŒ‡é’ˆåœ°å€ oldoverflow *[]*bmap // ä¸ºç©ºé—²æº¢å‡ºæ¡¶çš„æŒ‡é’ˆåœ°å€ nextOverflow *bmap } hmap.buckets å°±æ˜¯æŒ‡å‘ä¸€ä¸ª bmap æ•°ç»„ã€‚bmap çš„ç»“æ„ä½“ï¼š\ntype bmap struct { tophash [bucketCnt]uint8 } // ç¼–è¯‘æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ¨å¯¼é”®å€¼å¯¹å ç”¨å†…å­˜ç©ºé—´çš„å¤§å°ï¼Œç„¶åä¿®æ”¹ bmap çš„ç»“æ„ type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } bmap å°±æ˜¯æ¡¶ï¼Œä¸€ä¸ªæ¡¶é‡Œé¢ä¼šæœ€å¤šå­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ã€‚\nåœ¨æ¡¶å†…ï¼Œä¼šæ ¹æ® key è®¡ç®—å‡ºæ¥çš„ hash å€¼çš„é«˜ 8 ä½æ¥å†³å®š key å­˜å‚¨åœ¨æ¡¶ä¸­çš„ä½ç½®ã€‚ key å’Œ value æ˜¯åˆ†åˆ«æ”¾åœ¨ä¸€å—è¿ç»­çš„å†…å­˜ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†èŠ‚çœå†…å­˜ã€‚ä¾‹å¦‚ä¸€ä¸ª map[int64]int8 ç±»å‹çš„ mapï¼Œå¦‚æœæŒ‰ç…§ key1/value1/key2/value2 ... è¿™æ ·çš„å½¢å¼æ¥å­˜å‚¨ï¼Œé‚£ä¹ˆå†…å­˜å¯¹é½æ¯ä¸ª key/value éƒ½éœ€è¦ padding 7 ä¸ªå­—èŠ‚ã€‚ åˆ†å¼€è¿ç»­å­˜å‚¨çš„è¯ï¼Œå°±åªéœ€è¦åœ¨æœ€å padding ä¸€æ¬¡ã€‚ æ¯ä¸ªæ¡¶åªèƒ½å­˜å‚¨ 8 ä¸ª key/valueï¼Œå¦‚æœæœ‰æ›´å¤šçš„ key æ”¾å…¥å½“å‰æ¡¶ï¼Œå°±éœ€è¦ä¸€ä¸ªæº¢å‡ºæ¡¶ï¼Œé€šè¿‡ overflow æŒ‡é’ˆè¿æ¥èµ·æ¥ã€‚ åˆå§‹åŒ– # åˆå§‹åŒ– mapï¼š\nhash := map[string]int{ \u0026#34;1\u0026#34;: 2, \u0026#34;3\u0026#34;: 4, \u0026#34;5\u0026#34;: 6, } hash2 := make(map[string]int, 3) ä¸ç®¡æ˜¯ä½¿ç”¨å­—é¢é‡è¿˜æ˜¯ make åˆå§‹åŒ– mapï¼Œæœ€åéƒ½æ˜¯è°ƒç”¨ makemap å‡½æ•°ï¼š\nfunc makemap(t *maptype, hint int, h *hmap) *hmap { // ... // initialize Hmap if h == nil { h = new(hmap) } // è·å–ä¸€ä¸ªéšæœºçš„å“ˆå¸Œç§å­ h.hash0 = fastrand() // æ ¹æ®ä¼ å…¥çš„ hint è®¡ç®—å‡ºéœ€è¦çš„æœ€å°éœ€è¦çš„æ¡¶çš„æ•°é‡ B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // åˆå§‹åŒ– hash table // å¦‚æœ B ç­‰äº 0ï¼Œé‚£ä¹ˆ buckets å°±ä¼šåœ¨èµ‹å€¼çš„æ—¶å€™å†åˆ†é… // å¦‚æœ hint é•¿åº¦æ¯”è¾ƒå¤§ï¼Œåˆ†é…å†…å­˜ä¼šèŠ±è´¹é•¿ä¸€ç‚¹ if h.B != 0 { var nextOverflow *bmap // makeBucketArray æ ¹æ®ä¼ å…¥çš„ B è®¡ç®—å‡ºçš„éœ€è¦åˆ›å»ºçš„æ¡¶æ•°é‡ // å¹¶åœ¨å†…å­˜ä¸­åˆ†é…ä¸€ç‰‡è¿ç»­çš„ç©ºé—´ç”¨äºå­˜å‚¨æ•°æ® h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) h.extra.nextOverflow = nextOverflow } } return h } é¢„åˆ†é…çš„æº¢å‡ºæ¡¶å’Œæ­£å¸¸æ¡¶æ˜¯åœ¨ä¸€å—è¿ç»­çš„å†…å­˜ä¸­ã€‚\næŸ¥è¯¢ # æŸ¥è¯¢ map ä¸­çš„å€¼ï¼š\nv := hash[key] v, ok := hash[key] è¿™ä¸¤ç§æŸ¥è¯¢æ–¹å¼ä¼šè¢«è½¬æ¢æˆ mapaccess1 å’Œ mapaccess2 å‡½æ•°ï¼Œä¸¤ä¸ªå‡½æ•°åŸºæœ¬ä¸€æ ·ï¼Œä¸è¿‡ mapaccess2 å‡½æ•°çš„è¿”å›å€¼å¤šäº†ä¸€ä¸ª bool ç±»å‹ã€‚\næŸ¥è¯¢è¿‡ç¨‹ï¼š\n1. è®¡ç®—å“ˆå¸Œå€¼ # é€šè¿‡å“ˆå¸Œå‡½æ•°å’Œç§å­è·å–å½“å‰ key çš„ 64 ä½çš„å“ˆå¸Œå€¼ï¼ˆ64 ä½æœºï¼‰ã€‚ä»¥ä¸Šå›¾å“ˆå¸Œå€¼ï¼š11010111 | 110000110110110010001111001010100010010110010101001 â”‚ 00011 ä¸ºä¾‹ã€‚\n2. è®¡ç®—è¿™ä¸ª key è¦æ”¾åœ¨å“ªä¸ªæ¡¶ # æ ¹æ®å“ˆå¸Œå€¼çš„ B ï¼ˆhmap.Bï¼‰ä¸ª bit ä½æ¥è®¡ç®—ï¼Œä¹Ÿå°±æ˜¯ 00011ï¼Œåè¿›åˆ¶çš„å€¼æ˜¯ 3ï¼Œé‚£ä¹ˆå°±æ˜¯ 3 å·æ¡¶ã€‚\n3. è®¡ç®—è¿™ä¸ª key åœ¨æ¡¶å†…çš„ä½ç½® # æ ¹æ®å“ˆå¸Œå€¼çš„é«˜ 8 ä½ï¼Œä¹Ÿå°±æ˜¯ 10010111ï¼Œåè¿›åˆ¶çš„å€¼æ˜¯ 151ï¼Œå…ˆç”¨ 151 å’Œæ¡¶å†…å­˜å‚¨çš„ tophash æ¯”è¾ƒï¼Œå†æ¯”è¾ƒæ¡¶å†…çš„å­˜å‚¨çš„ key å’Œä¼ å…¥çš„ keyï¼Œè¿™ç§æ–¹å¼å¯ä»¥ä¼˜åŒ–æ¡¶å†…çš„è¯»å†™é€Ÿåº¦ã€‚\n// src/runtime/map.go#L434 mapaccess1 for i := uintptr(0); i \u0026lt; bucketCnt; i++ { // å…ˆæ¯”è¾ƒ tophashï¼Œå¦‚æœä¸ç›¸ç­‰ï¼Œå°±ç›´æ¥è¿›å…¥ä¸‹æ¬¡å¾ªç¯ if b.tophash[i] != top { if b.tophash[i] == emptyRest { break bucketloop } continue } // ... // å†æ¯”è¾ƒæ¡¶å†…çš„ key å’Œä¼ å…¥çš„ keyï¼Œå¦‚æœç›¸ç­‰ï¼Œå†è·å–ç›®æ ‡å€¼çš„æŒ‡é’ˆ if t.Key.Equal(key, k) { // ... } } è®¡ç®—åœ¨å‡ å·æ¡¶ç”¨çš„æ˜¯å B ä½ï¼Œtophash ä½¿ç”¨çš„æ˜¯é«˜ 8 ä½ï¼Œè¿™ç§æ–¹å¼å¯ä»¥é¿å…ä¸€ä¸ªæ¡¶å†…å‡ºç°å¤§é‡ç›¸åŒçš„ tophashï¼Œå½±å“è¯»å†™çš„æ€§èƒ½ã€‚\nå¦‚æœå½“å‰æ¡¶ä¸­æ²¡æœ‰æ‰¾åˆ° keyï¼Œè€Œä¸”å­˜åœ¨æº¢å‡ºæ¡¶ï¼Œé‚£ä¹ˆä¼šæ¥ç€éå†æ‰€æœ‰çš„æº¢å‡ºæ¡¶ä¸­çš„æ•°æ®ã€‚\nå†™å…¥ # å†™å…¥ map å’ŒæŸ¥è¯¢ map çš„å®ç°åŸç†ç±»ä¼¼ï¼Œè®¡ç®—å“ˆå¸Œå€¼å’Œå­˜æ”¾åœ¨å“ªä¸ªæ¡¶ï¼Œç„¶åéå†å½“å‰æ¡¶å’Œæº¢å‡ºæ¡¶çš„æ•°æ®ï¼š\nå¦‚æœå½“å‰ key ä¸å­˜åœ¨ï¼Œåˆ™é€šè¿‡åç§»é‡å­˜å‚¨åˆ°æ¡¶ä¸­ å¦‚æœå·²ç»å­˜åœ¨ï¼Œåˆ™è¿”å› value çš„å†…å­˜åœ°å€ï¼Œèµ‹å€¼æ“ä½œæ˜¯åœ¨ç¼–è¯‘æœŸæ‰§è¡Œçš„ã€‚ å¦‚æœæ¡¶å·²æ»¡ï¼Œåˆ™ä¼šåˆ›å»ºæ–°æ¡¶æˆ–è€…ä½¿ç”¨ç©ºé—²çš„æº¢å‡ºæ¡¶ï¼Œæ·»åŠ åˆ°å·²æœ‰æ¡¶çš„æœ«å°¾ï¼Œnoverflow è®¡æ•°åŠ  1ã€‚ æ‰©å®¹ # éšç€ map ä¸­å†™å…¥çš„ key/value å¢å¤šï¼Œè£…è½½å› å­ä¼šè¶Šæ¥è¶Šå¤§ï¼Œå“ˆå¸Œå†²çªçš„æ¦‚ç‡è¶Šæ¥è¶Šå¤§ï¼Œæ€§èƒ½ä¼šè·Ÿç€ä¸‹é™ã€‚å¦‚æœå¤§é‡çš„ key éƒ½è½å…¥åˆ°åŒä¸€ä¸ªæ¡¶ä¸­ï¼Œå“ˆå¸Œè¡¨ä¼šé€€åŒ–æˆé“¾è¡¨ï¼ŒæŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦ä¼šä» O(1) é€€åŒ–åˆ° O(n)ã€‚\næ‰€ä»¥å½“è£…è½½å› å­å¤§åˆ°ä¸€å®šç¨‹åº¦ä¹‹åï¼Œå“ˆå¸Œè¡¨å°±ä¸å¾—ä¸è¿›è¡Œæ‰©å®¹ã€‚\nGo map åœ¨ä»€ä¹ˆæ—¶å€™ä¼šè§¦å‘æ‰©å®¹ï¼Ÿ # func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { // src/runtime/map.go mapassign // If we hit the max load factor or we have too many overflow buckets, // and we\u0026#39;re not already in the middle of growing, start growing. if !h.growing() \u0026amp;\u0026amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) { hashGrow(t, h) goto again // Growing the table invalidates everything, so try again } } è£…è½½å› å­è¶…è¿‡é˜ˆå€¼ 6.5ã€‚ æº¢å‡ºæ¡¶çš„æ•°é‡è¿‡å¤šï¼š å½“ B \u0026lt; 15 æ—¶ï¼Œå¦‚æœæº¢å‡ºæ¡¶çš„æ•°é‡è¶…å¤š 2^B åˆ™è§¦å‘æ‰©å®¹ã€‚ å½“ B \u0026gt;= 15 æ—¶ï¼Œå¦‚æœæº¢å‡ºæ¡¶çš„æ•°é‡è¶…è¿‡ 2^15 åˆ™è§¦å‘æ‰©å®¹ã€‚ ä¸ºä»€ä¹ˆæº¢å‡ºæ¡¶è¿‡å¤šéœ€è¦è¿›è¡Œæ‰©å®¹ï¼Ÿ # ä»€ä¹ˆæƒ…å†µä¸‹ä¼šå‡ºç°è£…è½½å› å­å¾ˆå°ä¸è¶…è¿‡é˜ˆå€¼ï¼Œä½†æ˜¯æº¢å‡ºæ¡¶è¿‡å¤šçš„æƒ…å†µï¼Ÿ\nå…ˆæ’å…¥å¾ˆå¤šå…ƒç´ ï¼Œå¯¼è‡´åˆ›å»ºäº†å¾ˆå¤šæ¡¶ï¼Œä½†æ˜¯æœªè¾¾åˆ°é˜ˆå€¼ï¼Œå¹¶æ²¡æœ‰è§¦å‘æ‰©å®¹ã€‚ä¹‹åå†åˆ é™¤å…ƒç´ ï¼Œé™ä½å…ƒç´ çš„æ€»é‡ã€‚åå¤æ‰§è¡Œå‰é¢çš„æ­¥éª¤ï¼Œä½†æ˜¯åˆä¸ä¼šè§¦å‘æ‰©å®¹ï¼Œå°±ä¼šå¯¼è‡´åˆ›å»ºäº†å¾ˆå¤šæº¢å‡ºæ¡¶ï¼Œä½†æ˜¯ map ä¸­çš„ key åˆ†å¸ƒçš„å¾ˆåˆ†æ•£ã€‚å¯¼è‡´æŸ¥è¯¢å’Œæ’å…¥çš„æ•ˆç‡å¾ˆä½ã€‚\næ¸è¿›å¼æ‰©å®¹ # æ‰©å®¹éœ€è¦æŠŠåŸæœ‰çš„ buckets ä¸­çš„æ•°æ®è¿ç§»åˆ°æ–°çš„ buckets ä¸­ã€‚å¦‚æœä¸€ä¸ªå“ˆå¸Œè¡¨å½“å‰å¤§å°ä¸º 1GBï¼Œæ‰©å®¹ä¸ºåŸæ¥çš„ä¸¤å€å¤§å°ï¼Œé‚£å°±éœ€è¦å¯¹ 1GB çš„æ•°æ®é‡æ–°è®¡ç®—å“ˆå¸Œå€¼ï¼Œå¹¶ä¸”ä»åŸæ¥çš„å†…å­˜ç©ºé—´æ¬ç§»åˆ°æ–°çš„å†…å­˜ç©ºé—´ï¼Œè¿™æ˜¯éå¸¸è€—æ—¶çš„æ“ä½œã€‚\næ‰€ä»¥ map çš„æ‰©å®¹é‡‡ç”¨çš„æ˜¯ä¸€ç§æ¸è¿›å¼çš„æ–¹å¼ï¼Œå°†è¿ç§»çš„æ“ä½œç©¿æ’åœ¨æ’å…¥æ“ä½œçš„è¿‡ç¨‹ä¸­ï¼Œåˆ†æ‰¹å®Œæˆã€‚\nå¤§æ¦‚æ€è·¯å°±æ˜¯ï¼š\nå½“æœ‰æ–°çš„ key/value è¦æ’å…¥æ—¶ï¼Œå°†è¿™ä¸ª key/value æ’å…¥åˆ°æ–° buckets ä¸­ï¼Œå¹¶ä¸”ä»è€çš„ buckets ä¸­æ‹¿å‡ºä¸€ä¸ª key/value æ”¾å…¥åˆ°æ–° bucketsã€‚æ¯æ¬¡æ’å…¥ä¸€ä¸ª key/valueï¼Œéƒ½é‡å¤ä¸Šé¢çš„è¿‡ç¨‹ã€‚ç»è¿‡å¤šæ¬¡æ’å…¥æ“ä½œä¹‹åï¼Œè€çš„ buckets ä¸­çš„æ•°æ®å°±ä¸€ç‚¹ä¸€ç‚¹å…¨éƒ¨è¿ç§»åˆ°æ–°çš„ buckets ä¸­äº†ã€‚ è¿™æ ·ä¸ç”¨ä¸€æ¬¡æ€§å°†æ•°æ®è¿ç§»ï¼Œæ’å…¥æ“ä½œå°±éƒ½å˜å¾—å¾ˆå¿«äº†ã€‚\nå¯¹äºæŸ¥è¯¢æ“ä½œï¼Œä¸ºäº†å…¼å®¹äº†æ–°ã€è€ buckets ä¸­çš„æ•°æ®ï¼Œä¼šå…ˆä»æ–° buckets ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå†å»è€çš„ buckets ä¸­æŸ¥æ‰¾ã€‚\nå¯¹äºæ¡ä»¶ 2 æº¢å‡ºæ¡¶çš„æ•°é‡è¿‡å¤š # ç”³è¯·çš„æ–°çš„ buckets æ•°é‡å’ŒåŸæœ‰çš„ buckets æ•°é‡æ˜¯ç›¸ç­‰çš„ï¼Œè¿›è¡Œçš„æ˜¯ç­‰é‡æ‰©å®¹ã€‚ç”±äº buckets æ•°é‡ä¸å˜ï¼Œæ‰€ä»¥åŸæœ‰çš„æ•°æ®åœ¨å‡ å·æ¡¶ï¼Œè¿ç§»ä¹‹åä»ç„¶åœ¨å‡ å·æ¡¶ã€‚æ¯”å¦‚åŸæ¥åœ¨ 0 å· bucketï¼Œåˆ°æ–°çš„åœ°æ–¹åï¼Œä»ç„¶æ”¾åœ¨ 0 å· bucketã€‚\næ‰©å®¹å®Œæˆåï¼Œæº¢å‡ºæ¡¶æ²¡æœ‰äº†ï¼Œkey éƒ½é›†ä¸­åˆ°äº†ä¸€ä¸ª bucketï¼Œæ›´ä¸ºç´§å‡‘äº†ï¼Œæé«˜äº†æŸ¥æ‰¾çš„æ•ˆç‡ã€‚\nå¯¹äºæ¡ä»¶ 1 å½“è£…è½½å› å­è¶…è¿‡é˜ˆå€¼å # ç”³è¯·çš„æ–°çš„ buckets æ•°é‡å’ŒåŸæœ‰çš„ buckets æ•°é‡çš„ 2 å€ï¼Œä¹Ÿå°±æ˜¯ B+1ã€‚æ¡¶çš„æ•°é‡æ”¹å˜äº†ï¼Œé‚£ä¹ˆ key çš„å“ˆå¸Œå€¼è¦é‡æ–°è®¡ç®—ï¼Œæ‰èƒ½å†³å®šå®ƒåˆ°åº•è½åœ¨å“ªä¸ª bucketã€‚\nä¾‹å¦‚ï¼ŒåŸæ¥ B=5ï¼Œæ ¹æ®å‡º key çš„å“ˆå¸Œå€¼çš„å 5 ä½ï¼Œå°±èƒ½å†³å®šå®ƒè½åœ¨å“ªä¸ª bucketã€‚æ‰©å®¹åçš„ buckets æ•°é‡ç¿»å€ï¼ŒB å˜æˆäº† 6ï¼Œå› æ­¤å˜æˆå“ˆå¸Œå€¼çš„å 6 ä½æ‰èƒ½å†³å®š key è½åœ¨å“ªä¸ª bucketã€‚è¿™å«åš rehashã€‚\nå› æ­¤ï¼ŒæŸä¸ª key åœ¨è¿ç§»å‰å bucket åºå·å¯èƒ½ä¼šæ”¹å˜ï¼Œå–å†³äº rehash ä¹‹åçš„å“ˆå¸Œå€¼å€’æ•°ç¬¬ 6 ä½æ˜¯ 0 è¿˜æ˜¯ 1ã€‚\næ‰©å®¹å®Œæˆåï¼Œè€ buckets ä¸­çš„ key åˆ†è£‚åˆ°äº† 2 ä¸ªæ–°çš„ bucketã€‚\nè¿ç§»å®ç° # Go map æ‰©å®¹çš„å®ç°åœ¨ hashGrow å‡½æ•°ä¸­ï¼ŒhashGrow åªç”³è¯·æ–°çš„ bucketsï¼Œä½†å¹¶æ²¡æœ‰é©¬ä¸Šå°†åŸæœ‰çš„ key/value è¿ç§»æ–°çš„ buckets ä¸­ï¼š\nfunc hashGrow(t *maptype, h *hmap) { bigger := uint8(1) // æº¢å‡ºæ¡¶è¿‡å¤šè§¦å‘çš„æ‰©å®¹æ˜¯ç­‰é‡æ‰©å®¹ï¼Œbigger è®¾ç½®ä¸º 0 if !overLoadFactor(h.count+1, h.B) { bigger = 0 h.flags |= sameSizeGrow } // å°†åŸæœ‰çš„ buckets æŒ‚åˆ° oldbuckets ä¸Š oldbuckets := h.buckets // ç”³è¯·æ–°çš„ buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) flags := h.flags \u0026amp;^ (iterator | oldIterator) if h.flags\u0026amp;iterator != 0 { flags |= oldIterator } // å¦‚æœæ˜¯ç­‰é‡æ‰©å®¹ï¼Œbigger ä¸º 0ï¼ŒB ä¸å˜ h.B += bigger h.flags = flags // åŸæœ‰çš„ buckets æŒ‚åˆ° map çš„ oldbuckets ä¸Š h.oldbuckets = oldbuckets // æ–°ç”³è¯·çš„ buckets æŒ‚åˆ° buckets ä¸Š h.buckets = newbuckets // è®¾ç½®è¿ç§»è¿›åº¦ä¸º 0 h.nevacuate = 0 // æº¢å‡ºæ¡¶æ•°é‡ä¸º 0 h.noverflow = 0 // ... } è¿ç§»æ˜¯åœ¨æ’å…¥æ•°æ®å’Œåˆ é™¤æ•°æ®æ—¶ï¼Œä¹Ÿå°±æ˜¯ mapassign å’Œ mapdelete ä¸­è¿›è¡Œçš„ï¼š\nfunc mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { // ... again: bucket := hash \u0026amp; bucketMask(h.B) if h.growing() { // çœŸæ­£çš„è¿ç§»åœ¨ growWork ä¸­ growWork(t, h, bucket) }\t// ... } func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) { // ... bucket := hash \u0026amp; bucketMask(h.B) if h.growing() { growWork(t, h, bucket) } // ... } func (h *hmap) growing() bool { // oldbuckets ä¸ä¸ºç©ºï¼Œè¯´æ˜è¿˜æ²¡æœ‰è¿ç§»å®Œæˆ return h.oldbuckets != nil } growWorkï¼š\nfunc growWork(t *maptype, h *hmap, bucket uintptr) { // ç¡®è®¤è¿ç§»çš„è€çš„ bucket å¯¹åº”æ­£åœ¨ä½¿ç”¨çš„ bucket evacuate(t, h, bucket\u0026amp;h.oldbucketmask()) // é¢å¤–å†è¿ç§»ä¸€ä¸ª bucketï¼ŒåŠ å¿«è¿ç§»è¿›åº¦ if h.growing() { evacuate(t, h, h.nevacuate) } } çœŸæ­£çš„è¿ç§»åœ¨ evacuate å‡½æ•°ä¸­ï¼Œå®ƒä¼šå¯¹ä¼ å…¥æ¡¶ä¸­çš„æ•°æ®è¿›è¡Œå†åˆ†é…ã€‚evacuate å‡½æ•°æ¯æ¬¡åªå®Œæˆä¸€ä¸ª bucket çš„è¿ç§»å·¥ä½œï¼ˆåŒ…æ‹¬è¿™ä¸ª bucket é“¾æ¥çš„æº¢å‡ºæ¡¶ï¼‰ï¼Œå®ƒä¼šéå† bucket ï¼ˆåŒ…æ‹¬æº¢å‡ºæ¡¶ï¼‰ä¸­å¾—åˆ°æ‰€æœ‰ key/value å¹¶è¿ç§»ã€‚ å·²è¿ç§»çš„ key/value å¯¹åº”çš„ tophash ä¼šè¢«è®¾ç½®ä¸º evacuatedEmptyï¼Œè¡¨ç¤ºå·²ç»è¿ç§»ã€‚\nåˆ é™¤ # åˆ é™¤ map ä¸­çš„ key/valueï¼š\ndelete(hashmap, key) delete å…³é”®å­—çš„å”¯ä¸€ä½œç”¨å°±æ˜¯å°†æŸä¸€ä¸ª key/value ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ã€‚ä¼šè¢«ç¼–è¯‘å™¨è¢«è½¬æ¢æˆ mapdelete æ–¹æ³•ã€‚åˆ é™¤æ“ä½œå…ˆæ˜¯æ‰¾åˆ° key çš„ä½ç½®ï¼Œæ¸…ç©º key/valueï¼Œç„¶åå°† hmap.count - 1ï¼Œå¹¶ä¸”å¯¹åº”çš„ tophash è®¾ç½®ä¸º Emptyã€‚\nmap ä¸ºä»€ä¹ˆæ˜¯æ— åºçš„ # map åœ¨æ‰©å®¹åï¼Œkey/value ä¼šè¿›è¡Œè¿ç§»ï¼Œåœ¨åŒä¸€ä¸ªæ¡¶ä¸­çš„ keyï¼Œæœ‰äº›ä¼šè¿ç§»åˆ°åˆ«çš„æ¡¶ä¸­ï¼Œæœ‰äº› key åŸåœ°ä¸åŠ¨ï¼Œå¯¼è‡´éå† map å°±æ— æ³•ä¿è¯é¡ºåºã€‚\nGo åº•å±‚çš„å®ç°ç®€å•ç²—æš´ï¼Œç›´æ¥ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œè¿™ä¸ªéšæœºæ•°å†³å®šä»å“ªé‡Œå¼€å§‹éå†ï¼Œå› æ­¤æ¯æ¬¡ for range map çš„ç»“æœéƒ½æ˜¯ä¸ä¸€æ ·çš„ã€‚é‚£æ˜¯å› ä¸ºå®ƒçš„èµ·å§‹ä½ç½®æ ¹æœ¬å°±ä¸å›ºå®šã€‚\n"},{"id":15,"href":"/golang-learn/docs/concurrency/04_cond/","title":"æ¡ä»¶å˜é‡","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" æ¡ä»¶å˜é‡ # Go æ ‡å‡†åº“æä¾›äº†æ¡ä»¶å˜é‡ sync.Cond å®ƒå¯ä»¥è®©ä¸€ç»„çš„ goroutine éƒ½åœ¨æ»¡è¶³ç‰¹å®šæ¡ä»¶æ—¶è¢«å”¤é†’ã€‚\nsync.Cond ä¸æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„åŒæ­¥æœºåˆ¶ï¼Œä½†æ˜¯åœ¨æ¡ä»¶é•¿æ—¶é—´æ— æ³•æ»¡è¶³æ—¶ï¼Œä¸ä½¿ç”¨ for {} è¿›è¡Œå¿™ç¢Œç­‰å¾…ç›¸æ¯”ï¼Œsync.Cond èƒ½å¤Ÿè®©å‡ºå¤„ç†å™¨çš„ä½¿ç”¨æƒï¼Œæé«˜ CPU çš„åˆ©ç”¨ç‡ã€‚\nsync.Cond åŸºäºäº’æ–¥é”/è¯»å†™é”ï¼Œå®ƒå’Œäº’æ–¥é”çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ\näº’æ–¥é” sync.Mutex é€šå¸¸ç”¨æ¥ä¿æŠ¤ä¸´ç•ŒåŒºå’Œå…±äº«èµ„æºï¼Œæ¡ä»¶å˜é‡ sync.Cond ç”¨æ¥åè°ƒæƒ³è¦è®¿é—®å…±äº«èµ„æºçš„ goroutineã€‚\nsync.Cond ç»å¸¸ç”¨åœ¨å¤šä¸ª goroutine ç­‰å¾…ï¼Œä¸€ä¸ª goroutine é€šçŸ¥çš„åœºæ™¯ã€‚\næ¯”å¦‚æœ‰ä¸€ä¸ª goroutine åœ¨å¼‚æ­¥åœ°æ¥æ”¶æ•°æ®ï¼Œå‰©ä¸‹çš„å¤šä¸ª goroutine å¿…é¡»ç­‰å¾…è¿™ä¸ªåç¨‹æ¥æ”¶å®Œæ•°æ®ï¼Œæ‰èƒ½è¯»å–åˆ°æ­£ç¡®çš„æ•°æ®ã€‚è¿™ä¸ªæ—¶å€™ï¼Œå°±éœ€è¦æœ‰ä¸ªå…¨å±€çš„å˜é‡æ¥æ ‡å¿—ç¬¬ä¸€ ä¸ª goroutine æ•°æ®æ˜¯å¦æ¥å—å®Œæ¯•ï¼Œå‰©ä¸‹çš„ goroutineï¼Œåå¤æ£€æŸ¥è¯¥å˜é‡çš„å€¼ï¼Œç›´åˆ°æ»¡è¶³è¦æ±‚ã€‚\nå½“ç„¶ä¹Ÿå¯ä»¥åˆ›å»ºå¤šä¸ª channelï¼Œæ¯ä¸ª goroutine é˜»å¡åœ¨ä¸€ä¸ª channel ä¸Šï¼Œç”±æ¥æ”¶æ•°æ®çš„ goroutine åœ¨æ•°æ®æ¥æ”¶å®Œæ¯•åï¼Œé€ä¸ªé€šçŸ¥ã€‚ä½†æ˜¯è¿™ç§æ–¹å¼æ›´å¤æ‚ä¸€ç‚¹ã€‚\nä½¿ç”¨ # NewCond ç”¨æ¥åˆ›å»º sync.Cond å®ä¾‹ï¼Œsync.Cond æš´éœ²äº†å‡ ä¸ªæ–¹æ³•ï¼š\nBroadcast ç”¨æ¥å”¤é†’æ‰€æœ‰ç­‰å¾…æ¡ä»¶å˜é‡çš„ goroutineï¼Œæ— éœ€é”ä¿æŠ¤ã€‚ Signal å”¤é†’ä¸€ä¸ª goroutineã€‚ Wait è°ƒç”¨ Wait ä¼šè‡ªåŠ¨é‡Šæ”¾é”ï¼Œå¹¶æŒ‚èµ·è°ƒç”¨è€…æ‰€åœ¨çš„ goroutineï¼Œä¹Ÿå°±æ˜¯å½“å‰ goroutine ä¼šé˜»å¡åœ¨ Wait æ–¹æ³•è°ƒç”¨çš„åœ°æ–¹ã€‚å¦‚æœå…¶ä»– goroutine è°ƒç”¨äº† Signal æˆ– Broadcast å”¤é†’ äº†è¯¥ goroutineï¼Œé‚£ä¹ˆ Wait æ–¹æ³•åœ¨ç»“æŸé˜»å¡æ—¶ï¼Œä¼šé‡æ–°åŠ é”ï¼Œå¹¶ä¸”ç»§ç»­æ‰§è¡Œ Wait åé¢çš„ä»£ç ã€‚ var status int64 func main() { c := sync.NewCond(\u0026amp;sync.Mutex{}) for i := 0; i \u0026lt; 10; i++ { go listen(c) } time.Sleep(1 * time.Second) go broadcast(c) ch := make(chan os.Signal, 1) signal.Notify(ch, os.Interrupt) \u0026lt;-ch } func broadcast(c *sync.Cond) { c.L.Lock() atomic.StoreInt64(\u0026amp;status, 1) c.Broadcast() c.L.Unlock() } func listen(c *sync.Cond) { c.L.Lock() // ä½¿ç”¨äº† for !condition() è€Œé ifï¼Œæ˜¯å› ä¸ºå½“å‰ goroutine è¢«å”¤é†’æ—¶ï¼Œæ¡ä»¶ä¸ä¸€å®šç¬¦åˆè¦æ±‚ï¼Œéœ€è¦å†æ¬¡ Wait ç­‰å¾…ä¸‹æ¬¡è¢«å”¤é†’ // ä¾‹å¦‚ï¼Œå¦‚æœ broadcast æ²¡æœ‰è°ƒç”¨ atomic.StoreInt64(\u0026amp;status, 1) å°† status è®¾ç½®ä¸º 1ï¼Œè¿™é‡Œåˆ¤æ–­æ¡ä»¶åä¼šå†æ¬¡é˜»å¡ for atomic.LoadInt64(\u0026amp;status) != 1 { c.Wait() } fmt.Println(\u0026#34;listen\u0026#34;) c.L.Unlock() } statusï¼šäº’æ–¥é”éœ€è¦ä¿æŠ¤çš„æ¡ä»¶å˜é‡ã€‚ listen() è°ƒç”¨ Wait() ç­‰å¾…é€šçŸ¥ï¼Œç›´åˆ° status ä¸º 1ã€‚ broadcast() å°† status ç½®ä¸º 1ï¼Œè°ƒç”¨ Broadcast() é€šçŸ¥æ‰€æœ‰ç­‰å¾…çš„ goroutineã€‚ è¿è¡Œï¼š\n$ go run main.go listen ... listen æ‰“å°å‡º 10 æ¬¡ â€œlistenâ€ å¹¶ç»“æŸè°ƒç”¨ã€‚\nåŸç† # sync.Cond ç»“æ„ä½“ï¼š\n// src/sync/cond.go type Cond struct { noCopy noCopy L Locker notify notifyList checker copyChecker } type notifyList struct { // wait å’Œ notify åˆ†åˆ«è¡¨ç¤ºå½“å‰æ­£åœ¨ç­‰å¾…çš„å’Œå·²ç»é€šçŸ¥åˆ°çš„ goroutine çš„ç´¢å¼• wait uint32 notify uint32 lock mutex // head å’Œ tail åˆ†åˆ«æŒ‡å‘çš„é“¾è¡¨çš„å¤´å’Œå°¾ head *sudog tail *sudog } noCopyï¼šç”¨äºä¿è¯ç»“æ„ä½“ä¸ä¼šåœ¨ç¼–è¯‘æœŸé—´æ‹·è´ copyCheckerï¼šç”¨äºç¦æ­¢è¿è¡ŒæœŸé—´å‘ç”Ÿçš„æ‹·è´ Lï¼šç”¨äºä¿æŠ¤ notify å­—æ®µ notifyï¼šä¸€ä¸ª goroutine é“¾è¡¨ï¼Œå®ƒæ˜¯å®ç°åŒæ­¥æœºåˆ¶çš„æ ¸å¿ƒç»“æ„ Wait æ–¹æ³•ä¼šå°†å½“å‰ goroutine é™·å…¥ä¼‘çœ çŠ¶æ€ï¼Œå®ƒçš„æ‰§è¡Œè¿‡ç¨‹åˆ†æˆä»¥ä¸‹ä¸¤ä¸ªæ­¥éª¤ï¼š\nè°ƒç”¨ runtime.notifyListAdd å°†ç­‰å¾…è®¡æ•°å™¨åŠ  1 å¹¶è§£é”ï¼› è°ƒç”¨ runtime.notifyListWait ç­‰å¾…å…¶ä»– goroutine çš„å”¤é†’å¹¶åŠ é”ï¼š func (c *Cond) Wait() { c.checker.check() t := runtime_notifyListAdd(\u0026amp;c.notify) c.L.Unlock() // ä¼‘çœ ç›´åˆ°è¢«å”¤é†’ runtime_notifyListWait(\u0026amp;c.notify, t) c.L.Lock() } func notifyListAdd(l *notifyList) uint32 { return atomic.Xadd(\u0026amp;l.wait, 1) - 1 } // notifyListWait è·å–å½“å‰ goroutine å¹¶å°†å®ƒè¿½åŠ åˆ° goroutine é€šçŸ¥é“¾è¡¨çš„æœ€æœ«ç«¯ func notifyListWait(l *notifyList, t uint32) { s := acquireSudog() s.g = getg() s.ticket = t if l.tail == nil { l.head = s } else { l.tail.next = s } l.tail = s // è°ƒç”¨ runtime.goparkunlock ä½¿å½“å‰ goroutine é™·å…¥ä¼‘çœ  // è¯¥å‡½æ•°ä¼šç›´æ¥è®©å‡ºå½“å‰å¤„ç†å™¨çš„ä½¿ç”¨æƒå¹¶ç­‰å¾…è°ƒåº¦å™¨çš„å”¤é†’ goparkunlock(\u0026amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, 3) releaseSudog(s) } Signal æ–¹æ³•ä¼šå”¤é†’é˜Ÿåˆ—æœ€å‰é¢çš„ goroutineï¼ŒBroadcast æ–¹æ³•ä¼šå”¤é†’é˜Ÿåˆ—ä¸­å…¨éƒ¨çš„ goroutineï¼š\nfunc (c *Cond) Signal() { c.checker.check() runtime_notifyListNotifyOne(\u0026amp;c.notify) } func (c *Cond) Broadcast() { c.checker.check() runtime_notifyListNotifyAll(\u0026amp;c.notify) } notifyListNotifyOne ä» notifyList é“¾è¡¨ä¸­æ‰¾åˆ°æ»¡è¶³ sudog.ticket == l.notify æ¡ä»¶çš„ goroutine å¹¶é€šè¿‡ runtime.readyWithTime å”¤é†’ï¼š\n// src/runtime/sema.go#L554 func notifyListNotifyOne(l *notifyList) { t := l.notify atomic.Store(\u0026amp;l.notify, t+1) for p, s := (*sudog)(nil), l.head; s != nil; p, s = s, s.next { if s.ticket == t { n := s.next if p != nil { p.next = n } else { l.head = n } if n == nil { l.tail = p } s.next = nil readyWithTime(s, 4) return } } } notifyListNotifyAll ä¼šä¾æ¬¡é€šè¿‡ runtime.readyWithTime å”¤é†’é“¾è¡¨ä¸­æ‰€æœ‰ goroutineï¼š\nfunc notifyListNotifyAll(l *notifyList) { s := l.head l.head = nil l.tail = nil atomic.Store(\u0026amp;l.notify, atomic.Load(\u0026amp;l.wait)) for s != nil { next := s.next s.next = nil readyWithTime(s, 4) s = next } } goroutine çš„å”¤é†’é¡ºåºä¹Ÿæ˜¯æŒ‰ç…§åŠ å…¥é˜Ÿåˆ—çš„å…ˆåé¡ºåºï¼Œå…ˆåŠ å…¥çš„ä¼šå…ˆè¢«å”¤é†’ã€‚\n"},{"id":16,"href":"/golang-learn/docs/advance/","title":"ğŸ” åº•å±‚åŸç†","section":"Docs","content":"Go åº•å±‚å†…å­˜ç®¡ç†ï¼ŒGCï¼Œè°ƒåº¦å™¨çš„å®ç°åŸç†ã€‚\nComing soon \u0026hellip;\n"},{"id":17,"href":"/golang-learn/docs/project/05_api/","title":"API é£æ ¼","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" API é£æ ¼ # RESTful API # RPC # "},{"id":18,"href":"/golang-learn/docs/practice/05_performance/","title":"Go æ€§èƒ½ä¼˜åŒ–","section":"ğŸ› ï¸ å®è·µ","content":" Go æ€§èƒ½ä¼˜åŒ– # JSON ä¼˜åŒ– # Go å®˜æ–¹çš„ encoding/json æ˜¯é€šè¿‡åå°„æ¥å®ç°çš„ã€‚æ€§èƒ½ç›¸å¯¹æœ‰äº›æ…¢ã€‚ å¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“æ¥æ›¿ä»£æ ‡å‡†åº“ï¼š\njson-iterator/goï¼Œå®Œå…¨å…¼å®¹æ ‡å‡†åº“ï¼Œæ€§èƒ½æœ‰å¾ˆå¤§æå‡ã€‚ go-jsonï¼Œå®Œå…¨å…¼å®¹æ ‡å‡†åº“ï¼Œæ€§èƒ½å¼ºäº json-iterator/goã€‚ sonicï¼Œå­—èŠ‚å¼€å‘çš„çš„ JSON åºåˆ—åŒ–/ååºåˆ—åŒ–åº“ï¼Œé€Ÿåº¦å¿«ï¼Œä½†æ˜¯å¯¹ç¡¬ä»¶æœ‰ä¸€äº›è¦æ±‚ã€‚ å®é™…å¼€å‘ä¸­å¯ä»¥æ ¹æ®ç¼–è¯‘æ ‡ç­¾æ¥é€‰æ‹© JSON åº“ï¼Œå‚è€ƒ component-base/jsonã€‚\nä½¿ç”¨ç©ºç»“æ„ä½“ # åœ¨ Go ä¸­ç©ºç»“æ„ä½“ struct{} ä¸å æ®å†…å­˜ç©ºé—´ï¼š\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { fmt.Println(unsafe.Sizeof(struct{}{})) // 0 } ç©ºç»“æ„ä½“ä¸å æ®å†…å­˜ç©ºé—´ï¼Œå› æ­¤è¢«å¹¿æ³›ä½œä¸ºå„ç§åœºæ™¯ä¸‹çš„å ä½ç¬¦ä½¿ç”¨ï¼Œå¯ä»¥èŠ‚çœèµ„æºã€‚\né›†åˆ Set # è¦å®ç°ä¸€ä¸ª Setï¼Œé€šå¸¸ä¼šä½¿ç”¨ map æ¥å®ç°ï¼Œæ¯”å¦‚ map[string]boolã€‚ ä½†æ˜¯å¯¹äºé›†åˆæ¥è¯´ï¼Œ åªéœ€è¦ map çš„é”®ï¼Œè€Œä¸éœ€è¦å€¼ã€‚å°†å€¼è®¾ç½®ä¸º bool ç±»å‹ï¼Œå°±ä¼šå¤šå æ® 1 ä¸ªå­—èŠ‚ã€‚è¿™ä¸ªæ—¶å€™å°±å¯ä»¥ä½¿ç”¨ç©ºç»“æ„ä½“ map[string]struct{}ã€‚\nchannel é€šçŸ¥ # æœ‰æ—¶å€™ä½¿ç”¨ channel ä¸éœ€è¦å‘é€ä»»ä½•çš„æ•°æ®ï¼Œåªç”¨æ¥é€šçŸ¥ goroutine æ‰§è¡Œä»»åŠ¡ï¼Œæˆ–ç»“æŸç­‰ã€‚è¿™ä¸ªæ—¶å€™å°±å¯ä»¥ä½¿ç”¨ç©ºç»“æ„ä½“ã€‚\nå†…å­˜å¯¹é½ # ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜å¯¹é½ï¼Ÿ # CPU è®¿é—®å†…å­˜æ—¶ï¼Œå¹¶ä¸æ˜¯é€ä¸ªå­—èŠ‚è®¿é—®ï¼Œè€Œæ˜¯ä»¥å­—é•¿ï¼ˆword sizeï¼‰ä¸ºå•ä½è®¿é—®ã€‚æ¯”å¦‚ï¼š\n64 ä½ç³»ç»Ÿ 1 ä¸ªå­—é•¿ç­‰äº 8 ä¸ªå­—èŠ‚ 32 ä½ç³»ç»Ÿ 1 ä¸ªå­—é•¿ç­‰äº 4 ä¸ªå­—èŠ‚ å› æ­¤ CPU åœ¨è¯»å–å†…å­˜æ—¶æ˜¯ä¸€å—ä¸€å—è¿›è¡Œè¯»å–çš„ã€‚è¿™ä¹ˆè®¾è®¡çš„ç›®çš„ï¼Œæ˜¯å‡å°‘ CPU è®¿é—®å†…å­˜çš„æ¬¡æ•°ï¼ŒåŠ å¤§ CPU è®¿é—®å†…å­˜çš„ååé‡ã€‚æ¯”å¦‚åŒæ ·è¯»å– 8 ä¸ªå­—èŠ‚çš„æ•°æ®ï¼Œä¸€ æ¬¡è¯»å– 4 ä¸ªå­—èŠ‚é‚£ä¹ˆåªéœ€è¦è¯»å– 2 æ¬¡ã€‚\nè¿›è¡Œå†…å­˜å¯¹é½ï¼Œå°±æ˜¯ä¸ºäº†å‡å°‘ CPU è®¿é—®å†…å­˜çš„æ¬¡æ•°ã€‚\nä¸Šå›¾ä¸­ï¼Œå‡å¦‚ CPU å­—é•¿ä¸º 4 ä¸ªå­—èŠ‚ã€‚å˜é‡ a å’Œ b çš„å¤§å°ä¸º 3 ä¸ªå­—èŠ‚ï¼Œæ²¡æœ‰å†…å­˜å¯¹é½ä¹‹å‰ï¼ŒCPU è¯»å– b æ—¶ï¼Œéœ€è¦è®¿é—®ä¸¤æ¬¡å†…å­˜ï¼š\nç¬¬ä¸€æ¬¡è¯»å– 0-3 å­—èŠ‚ï¼Œç§»é™¤ä¸éœ€è¦çš„ 0-2 å­—èŠ‚ï¼Œæ‹¿åˆ° b çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼Œ ç¬¬äºŒæ¬¡è¯»å– 4-7 å­—èŠ‚ï¼Œè¯»å–åˆ° b çš„åé¢ä¸¤ä¸ªå­—èŠ‚ï¼Œå¹¶ç§»é™¤ä¸éœ€è¦çš„ 6ï¼Œ7 å­—èŠ‚ã€‚ åˆå¹¶ 4 ä¸ªå­—èŠ‚çš„æ•°æ® æ”¾å…¥å¯„å­˜å™¨ å†…å­˜å¯¹é½åï¼Œa å’Œ b éƒ½å æ®äº† 4 ä¸ªå­—èŠ‚ç©ºé—´ï¼ŒCPU è¯»å– b å°±åªéœ€è¦è®¿é—®ä¸€æ¬¡å†…å­˜ï¼Œè¯»å–åˆ° 4-7 å­—èŠ‚ã€‚\nå¯¹é½ç³»æ•° # ä¸åŒå¹³å°ä¸Šçš„ç¼–è¯‘å™¨éƒ½æœ‰è‡ªå·±é»˜è®¤çš„ â€œå¯¹é½ç³»æ•°â€ï¼Œå¸¸ç”¨çš„å¹³å°çš„ç³»æ•°å¦‚ä¸‹ï¼š\n64 ä½ç³»ç»Ÿï¼š8 32 ä½ç³»ç»Ÿï¼š4 unsafe æ ‡å‡†åº“æä¾›äº† Alignof æ–¹æ³•ï¼Œå¯ä»¥è¿”å›ä¸€ä¸ªç±»å‹çš„å¯¹é½ç³»æ•°ã€‚ä¾‹å¦‚ï¼š\nfunc main() { fmt.Printf(\u0026#34;bool align: %d\\n\u0026#34;, unsafe.Alignof(bool(true))) // bool align: 1 fmt.Printf(\u0026#34;int8 align: %d\\n\u0026#34;, unsafe.Alignof(int8(0))) // int8 align: 1 fmt.Printf(\u0026#34;int16 align: %d\\n\u0026#34;, unsafe.Alignof(int16(0))) // int16 align: 2 fmt.Printf(\u0026#34;int32 align: %d\\n\u0026#34;, unsafe.Alignof(int32(0))) // int32 align: 4 fmt.Printf(\u0026#34;int64 align: %d\\n\u0026#34;, unsafe.Alignof(int64(0))) // int64 align: 8 fmt.Printf(\u0026#34;byte align: %d\\n\u0026#34;, unsafe.Alignof(byte(0))) // byte align: 1 fmt.Printf(\u0026#34;string align: %d\\n\u0026#34;, unsafe.Alignof(\u0026#34;EDDYCJY\u0026#34;)) // string align: 8 fmt.Printf(\u0026#34;map align: %d\\n\u0026#34;, unsafe.Alignof(map[string]string{})) // map align: 8 } å¯¹é½è§„åˆ™ # å¯¹äºä»»æ„ç±»å‹çš„å˜é‡ xï¼Œunsafe.Alignof(x) è‡³å°‘ä¸º 1ã€‚ å¯¹äº struct ç»“æ„ä½“ç±»å‹çš„å˜é‡ xï¼Œè®¡ç®— x æ¯ä¸€ä¸ªå­—æ®µ f çš„ unsafe.Alignof(x.f)ï¼Œunsafe.Alignof(x) ç­‰äºå…¶ä¸­çš„æœ€å¤§å€¼ã€‚ å¯¹äº array æ•°ç»„ç±»å‹çš„å˜é‡ xï¼Œunsafe.Alignof(x) ç­‰äºæ„æˆæ•°ç»„çš„å…ƒç´ ç±»å‹çš„å¯¹é½å€æ•°ã€‚ Go ç»“æ„ä½“å†…å­˜å¯¹é½ # struct ä¸­çš„å­—æ®µçš„é¡ºåºä¼šå¯¹ struct çš„å¤§å°äº§ç”Ÿå½±å“å—ï¼Ÿ\ntype Part1 struct { a int8 c int32 b int16 } type Part2 struct { a int8 c int32 b int16 } func main() { part1 := Part1{} fmt.Printf(\u0026#34;part1 size: %d, align: %d\\n\u0026#34;, unsafe.Sizeof(part1), unsafe.Alignof(part1)) part2 := Part2{} fmt.Printf(\u0026#34;part2 size: %d, align: %d\\n\u0026#34;, unsafe.Sizeof(part2), unsafe.Alignof(part2)) } è¾“å‡ºï¼š\n// Output: // part1 size: 8, align: 4 // part2 size: 12, align: 4 Part1 åªæ˜¯å¯¹æˆå‘˜å˜é‡çš„å­—æ®µé¡ºåºè¿›è¡Œäº†è°ƒæ•´ï¼Œå°±å‡å°‘äº†ç»“æ„ä½“å ç”¨å¤§å°ã€‚\npart1ï¼š\na ä»ç¬¬ 0 ä¸ªä½ç½®å¼€å§‹å æ® 1 å­—èŠ‚ã€‚ b å¯¹é½ç³»æ•°ä¸º 2ï¼Œå› æ­¤ï¼Œå¿…é¡»ç©ºå‡º 1 ä¸ªå­—èŠ‚ï¼Œåç§»é‡æ‰æ˜¯ 2 çš„å€æ•°ï¼Œä»ç¬¬ 2 ä¸ªä½ç½®å¼€å§‹å æ® 2 å­—èŠ‚ã€‚ c å¯¹é½ç³»æ•°ä¸º 4ï¼Œæ­¤æ—¶ï¼Œå†…å­˜å·²ç»æ˜¯å¯¹é½çš„ï¼Œä»ç¬¬ 4 ä¸ªä½ç½®å¼€å§‹å æ® 4 å­—èŠ‚å³å¯ã€‚ part2ï¼š\na ä»ç¬¬ 0 ä¸ªä½ç½®å¼€å§‹å æ® 1 å­—èŠ‚ã€‚ c å¯¹é½ç³»æ•°ä¸º 4ï¼Œå› æ­¤ï¼Œå¿…é¡»ç©ºå‡º 3 ä¸ªå­—èŠ‚ï¼Œåç§»é‡æ‰æ˜¯ 4 çš„å€æ•°ï¼Œä»ç¬¬ 4 ä¸ªä½ç½®å¼€å§‹å æ® 4 å­—èŠ‚ã€‚ b å¯¹é½ç³»æ•°ä¸º 2ï¼Œä»ç¬¬ 8 ä¸ªä½ç½®å¼€å§‹å æ® 2 å­—èŠ‚ã€‚ ç©º struct{} çš„å¯¹é½ # ç©º struct{} å¤§å°ä¸º 0ï¼Œä½œä¸ºå…¶ä»– struct çš„å­—æ®µæ—¶ï¼Œä¸€èˆ¬ä¸éœ€è¦å†…å­˜å¯¹é½ã€‚ä½†æ˜¯å½“ struct{} ä½œä¸ºç»“æ„ä½“æœ€åä¸€ä¸ªå­—æ®µæ—¶ï¼Œéœ€è¦å†…å­˜å¯¹é½ã€‚ å› ä¸ºå¦‚æœæœ‰æŒ‡é’ˆæŒ‡å‘è¯¥å­—æ®µ, è¿”å›çš„åœ°å€å°†åœ¨ç»“æ„ä½“ä¹‹å¤–ï¼Œå¦‚æœæ­¤æŒ‡é’ˆä¸€ç›´å­˜æ´»ä¸é‡Šæ”¾å¯¹åº”çš„å†…å­˜ï¼Œå°±ä¼šæœ‰å†…å­˜æ³„éœ²çš„é—®é¢˜ï¼ˆè¯¥å†…å­˜ä¸å› ç»“æ„ä½“é‡Šæ”¾è€Œé‡Šæ”¾ï¼‰ã€‚\nå› æ­¤ï¼Œå½“ struct{} ä½œä¸ºå…¶ä»– struct æœ€åä¸€ä¸ªå­—æ®µæ—¶ï¼Œéœ€è¦å¡«å……é¢å¤–çš„å†…å­˜ä¿è¯å®‰å…¨ã€‚\ntype Part1 struct { c int32 a struct{} } type Part2 struct { a struct{} c int32 } func main() { fmt.Println(unsafe.Sizeof(Part1{})) // 8 fmt.Println(unsafe.Sizeof(Part2{})) // 4 } å¯ä»¥çœ‹åˆ° Part1{} é¢å¤–å¡«å……äº† 4 å­—èŠ‚çš„ç©ºé—´ã€‚\né€ƒé€¸åˆ†æ # ç¼–è¯‘å™¨å†³å®šå†…å­˜åˆ†é…ä½ç½®çš„æ–¹å¼ï¼Œå°±ç§°ä¹‹ä¸ºé€ƒé€¸åˆ†æ(escape analysis)ã€‚é€ƒé€¸åˆ†æç”±ç¼–è¯‘å™¨å®Œæˆï¼Œä½œç”¨äºç¼–è¯‘é˜¶æ®µã€‚\nå˜é‡é€ƒé€¸æ˜¯æŒ‡ç¼–è¯‘å™¨å°†ä¸€ä¸ªå˜é‡ä»æ ˆä¸Šåˆ†é…åˆ°å¯¹ä¸Šçš„æƒ…å†µã€‚\nåœ¨ Go ä¸­ï¼Œæ ˆæ˜¯è·Ÿå‡½æ•°ç»‘å®šçš„ï¼Œå‡½æ•°ç»“æŸæ—¶æ ˆè¢«å›æ”¶ã€‚å¦‚æœä¸€ä¸ªå˜é‡åˆ†é…åœ¨æ ˆä¸­ï¼Œåˆ™å‡½æ•°æ‰§è¡Œç»“æŸå¯è‡ªåŠ¨å°†å†…å­˜å›æ”¶ã€‚å¦‚æœåˆ†é…åœ¨å †ä¸­ï¼Œåˆ™å‡½æ•°æ‰§è¡Œç»“æŸå¯äº¤ç»™ GCï¼ˆåƒåœ¾å›æ”¶ï¼‰å¤„ç†ã€‚\nå˜é‡é€ƒé€¸å¸¸è§çš„æƒ…å†µï¼š\næŒ‡é’ˆé€ƒé€¸ï¼šè¿”å›æŒ‡é’ˆï¼Œå½“ä¸€ä¸ªå‡½æ•°è¿”å›ä¸€ä¸ªå±€éƒ¨å˜é‡çš„æŒ‡é’ˆæ—¶ï¼Œç¼–è¯‘å™¨å°±ä¸å¾—ä¸å§è¯¥å˜é‡åˆ†é…åˆ°å †ä¸Šï¼Œä»¥ä¾¿å‡½æ•°è¿”å›åè¿˜å¯ä»¥è®¿é—®å®ƒã€‚ å‘é€æŒ‡é’ˆæˆ–å¸¦æœ‰æŒ‡é’ˆçš„å€¼åˆ° channel ä¸­ï¼Œç¼–è¯‘æ—¶ï¼Œæ˜¯æ²¡æœ‰åŠæ³•çŸ¥é“å“ªä¸ª goroutine ä¼šåœ¨ channel ä¸Šæ¥æ”¶æ•°æ®ã€‚æ‰€ä»¥ç¼–è¯‘å™¨æ²¡æ³•çŸ¥é“å˜é‡ä»€ä¹ˆæ—¶å€™æ‰ä¼šè¢«é‡Šæ”¾ã€‚è¯¥å€¼å°±ä¼šè¢«åˆ†é…åˆ°å †ä¸Šã€‚ åœ¨ä¸€ä¸ªåˆ‡ç‰‡ä¸Šå­˜å‚¨æŒ‡é’ˆæˆ–å¸¦æŒ‡é’ˆçš„å€¼ã€‚ä¾‹å¦‚ []*string ã€‚è¿™ä¼šå¯¼è‡´åˆ‡ç‰‡çš„å†…å®¹é€ƒé€¸ã€‚å°½ç®¡å…¶åé¢çš„æ•°ç»„å¯èƒ½æ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„ï¼Œä½†å…¶å¼•ç”¨çš„å€¼ä¸€å®šæ˜¯åœ¨å †ä¸Šã€‚ åˆ‡ç‰‡çš„åº•å±‚æ•°ç»„è¢«é‡æ–°åˆ†é…äº†ï¼Œå› ä¸º append æ—¶å¯èƒ½ä¼šè¶…å‡ºå…¶å®¹é‡ã€‚åˆ‡ç‰‡åˆå§‹åŒ–çš„åœ°æ–¹åœ¨ç¼–è¯‘æ—¶æ˜¯å¯ä»¥çŸ¥é“çš„ï¼Œå®ƒæœ€å¼€å§‹ä¼šåœ¨æ ˆä¸Šåˆ†é…ã€‚å¦‚æœåˆ‡ç‰‡èƒŒåçš„å­˜å‚¨è¦åŸºäºè¿è¡Œæ—¶çš„æ•°æ®è¿›è¡Œæ‰©å……ï¼Œå°±ä¼šåœ¨å †ä¸Šåˆ†é…ã€‚ åœ¨ interface ç±»å‹ä¸Šè°ƒç”¨æ–¹æ³•éƒ½æ˜¯åŠ¨æ€è°ƒåº¦çš„ï¼Œæ–¹æ³•çš„å®ç°åªèƒ½åœ¨è¿è¡Œæ—¶æ‰çŸ¥é“ã€‚æ¯”å¦‚ io.Reader ç±»å‹çš„å˜é‡ rï¼Œè°ƒç”¨ r.Read(b) ä¼šä½¿ r çš„å€¼å’Œåˆ‡ç‰‡ b çš„åº•å±‚æ•°ç»„éƒ½é€ƒé€¸æ‰ï¼Œåœ¨å †ä¸Šåˆ†é…ã€‚ æ•°æ®ç±»å‹ä¸ç¡®å®šï¼Œå¦‚è°ƒç”¨ fmt.Sprintfï¼Œjson.Marshal ç­‰æ¥å—å˜é‡ä¸º ...interface{} çš„å‡½æ•°ï¼Œä¼šå¯¼è‡´ä¼ å…¥çš„å˜é‡é€ƒé€¸åˆ°å †ä¸Šã€‚ é—­åŒ…å¼•ç”¨ï¼šå¦‚æœä¸€ä¸ªå±€éƒ¨å˜é‡è¢«ä¸€ä¸ªé—­åŒ…å‡½æ•°å¼•ç”¨ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¹Ÿå¯èƒ½æŠŠå®ƒåˆ†é…åˆ°å †ä¸Šï¼Œç¡®ä¿é—­åŒ…å¯ä»¥ç»§ç»­è®¿é—®å®ƒã€‚ func isaclosure() func() { v := 1 return func() { println(v) } } æ ˆç©ºé—´ä¸è¶³ å˜é‡é€ƒé€¸å°±æ„å‘³ç€å¢åŠ äº†å †ä¸­çš„å¯¹è±¡ä¸ªæ•°ï¼Œå½±å“ GC è€—æ—¶ï¼Œå½±å“æ€§èƒ½ã€‚æ‰€ä»¥ç¼–å†™ä»£ç æ—¶ï¼Œé¿å…è¿”å›æŒ‡é’ˆï¼Œé™åˆ¶é—­åŒ…çš„ä½œç”¨èŒƒå›´ç­‰æ¥è¦å°½é‡é¿å…é€ƒé€¸ã€‚\nå¯ä»¥ä½¿ç”¨ç¼–è¯‘å™¨çš„ gcflags=\u0026quot;-m\u0026quot; æ¥æŸ¥çœ‹å˜é‡é€ƒé€¸çš„æƒ…å†µï¼š\npackage main import \u0026#34;fmt\u0026#34; type A struct { s string } // åœ¨æ–¹æ³•å†…è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆ func foo(s string) *A { a := new(A) a.s = s return a // a ä¼šé€ƒé€¸åˆ°å †ä¸Š } func main() { a := foo(\u0026#34;hello\u0026#34;) b := a.s + \u0026#34; world\u0026#34; c := b + \u0026#34;!\u0026#34; fmt.Println(c) // c æ•°æ®ç±»å‹ä¸ç¡®å®šï¼Œæ‰€ä»¥ escapes to heap } è¿è¡Œ go run -gcflags=-m ./main.go ä¼šå¾—åˆ°ä¸‹é¢ç±»ä¼¼çš„è¾“å‡ºï¼š\n# command-line-arguments ./main.go:10:6: can inline foo ./main.go:17:10: inlining call to foo ./main.go:20:13: inlining call to fmt.Println ./main.go:10:10: leaking param: s ./main.go:11:10: new(A) escapes to heap ./main.go:17:10: new(A) does not escape ./main.go:18:11: a.s + \u0026#34; world\u0026#34; does not escape ./main.go:19:9: b + \u0026#34;!\u0026#34; escapes to heap ./main.go:20:13: c escapes to heap ./main.go:20:13: []interface {} literal does not escape \u0026lt;autogenerated\u0026gt;:1: .this does not escape \u0026lt;autogenerated\u0026gt;:1: .this does not escape hello world! ä¼ å€¼è¿˜æ˜¯ä¼ æŒ‡é’ˆï¼Ÿ # ä¼ å€¼ä¼šæ‹·è´æ•´ä¸ªå¯¹è±¡ï¼Œè€Œä¼ æŒ‡é’ˆåªä¼šæ‹·è´æŒ‡é’ˆåœ°å€ï¼ŒæŒ‡å‘çš„å¯¹è±¡æ˜¯åŒä¸€ä¸ªã€‚ä¼ æŒ‡é’ˆå¯ä»¥å‡å°‘å€¼çš„æ‹·è´ï¼Œä½†æ˜¯ä¼šå¯¼è‡´å†…å­˜åˆ†é…é€ƒé€¸åˆ°å †ä¸­ï¼Œå¢åŠ åƒåœ¾å›æ”¶(GC)çš„è´Ÿæ‹…ã€‚åœ¨å¯¹ è±¡é¢‘ç¹åˆ›å»ºå’Œåˆ é™¤çš„åœºæ™¯ä¸‹ï¼Œä¼ é€’æŒ‡é’ˆå¯¼è‡´çš„ GC å¼€é”€å¯èƒ½ä¼šä¸¥é‡å½±å“æ€§èƒ½ã€‚\nä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯¹äºéœ€è¦ä¿®æ”¹åŸå¯¹è±¡å€¼ï¼Œæˆ–å ç”¨å†…å­˜æ¯”è¾ƒå¤§çš„ç»“æ„ä½“ï¼Œé€‰æ‹©ä¼ æŒ‡é’ˆã€‚å¯¹äºåªè¯»çš„å ç”¨å†…å­˜è¾ƒå°çš„ç»“æ„ä½“ï¼Œç›´æ¥ä¼ å€¼èƒ½å¤Ÿè·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚\næ­»ç æ¶ˆé™¤ # æ­»ç æ¶ˆé™¤(dead code elimination, DCE)æ˜¯ä¸€ç§ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯ï¼Œç”¨å¤„æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µå»æ‰å¯¹ç¨‹åºè¿è¡Œç»“æœæ²¡æœ‰ä»»ä½•å½±å“çš„ä»£ç ã€‚\næ­»ç æ¶ˆé™¤å¯ä»¥å‡å°ç¨‹åºä½“ç§¯ï¼Œç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­é¿å…æ‰§è¡Œæ— ç”¨çš„æŒ‡ä»¤ï¼Œç¼©çŸ­è¿è¡Œæ—¶é—´ã€‚\nä½¿ç”¨å¸¸é‡æå‡æ€§èƒ½ # æœ‰äº›åœºæ™¯ä¸‹ï¼Œä½¿ç”¨å¸¸é‡ä¸ä»…å¯ä»¥å‡å°‘ç¨‹åºçš„ä½“ç§¯ï¼Œæ€§èƒ½ä¹Ÿä¼šæœ‰å¾ˆå¤§çš„æå‡ã€‚\nusevar.goï¼š\nfunc Max(num1, num2 int) int { if num1 \u0026gt; num2 { return num1 } return num2 } var a, b = 10, 20 func main() { if Max(a, b) == a { fmt.Println(a) } } useconst.goï¼š\nfunc Max(num1, num2 int) int { if num1 \u0026gt; num2 { return num1 } return num2 } const a, b = 10, 20 func main() { if Max(a, b) == a { fmt.Println(a) } } ä¸Šé¢ä¸¤ä¸ªæ–‡ä»¶ç¼–è¯‘åçš„æ–‡ä»¶å¤§å°ï¼š\n$ ls -lh -rwxr-xr-x 1 pshi2 1049089 1.9M Oct 24 13:45 usevar.exe -rwxr-xr-x 1 pshi2 1049089 1.5M Oct 24 13:44 useconst.exe åªæ˜¯ä½¿ç”¨äº†å¸¸é‡ä»£æ›¿å˜é‡ï¼Œä¸¤ä¸ªæ–‡ä»¶çš„å¤§å°å°±ç›¸å·® 0.3 Mï¼Œä¸ºä»€ä¹ˆï¼Ÿ\nä½¿ç”¨ -gcflags=-m å‚æ•°å¯ä»¥æŸ¥çœ‹ç¼–è¯‘å™¨åšäº†å“ªäº›ä¼˜åŒ–ï¼š\n$ go build -gcflags=-m ./useconst.go # command-line-arguments ./main.go:5:6: can inline Max ./main.go:15:8: inlining call to Max ./main.go:16:14: inlining call to fmt.Println ./main.go:16:14: ... argument does not escape ./main.go:16:15: a escapes to heap Max å‡½æ•°è¢«å†…è”äº†ï¼Œå†…è”åçš„ä»£ç æ˜¯è¿™æ ·çš„ï¼š\nfunc main() { var result int if a \u0026gt; b { result = a } else { result = b } if result == a { fmt.Println(a) } } ç”±äº a å’Œ b å‡ä¸ºå¸¸é‡ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µä¼šç›´æ¥è®¡ç®—ï¼š\nfunc main() { var result int if 10 \u0026gt; 20 { result = 10 } else { result = 20 } if result == 10 { fmt.Println(a) } } 10 \u0026gt; 20 æ°¸è¿œä¸ºå‡ï¼Œé‚£ä¹ˆåˆ†æ”¯æ¶ˆé™¤ï¼Œresult æ°¸è¿œç­‰äº 20ï¼š\nfunc main() { if 20 == 10 { fmt.Println(a) } } 20 == 10 ä¹Ÿæ°¸è¿œä¸ºå‡ï¼Œå†æ¬¡æ¶ˆé™¤åˆ†æ”¯ï¼š\nfunc main() {} ä½†æ˜¯å¯¹äºå˜é‡ a å’Œ bï¼Œç¼–è¯‘å™¨å¹¶ä¸çŸ¥é“è¿è¡Œè¿‡ç¨‹ä¸­ aã€b ä¼šä¸ä¼šå‘ç”Ÿæ”¹å˜ï¼Œå› æ­¤ä¸èƒ½å¤Ÿè¿›è¡Œæ­»ç æ¶ˆé™¤ï¼Œè¿™éƒ¨åˆ†ä»£ç è¢«ç¼–è¯‘åˆ°æœ€ç»ˆçš„äºŒè¿›åˆ¶ç¨‹åºä¸­ã€‚å› æ­¤ç¼–è¯‘åçš„äºŒè¿›åˆ¶ç¨‹åºä½“ç§¯å¤§äº† 0.3 Mã€‚\nå› æ­¤ï¼Œåœ¨å£°æ˜å…¨å±€å˜é‡æ—¶ï¼Œå¦‚æœèƒ½å¤Ÿç¡®å®šä¸ºå¸¸é‡ï¼Œå°½é‡ä½¿ç”¨ const è€Œé varã€‚è¿™æ ·å¾ˆå¤šè¿ç®—åœ¨ç¼–è¯‘å™¨å³å¯æ‰§è¡Œã€‚æ­»ç æ¶ˆé™¤åï¼Œæ—¢å‡å°äº†äºŒè¿›åˆ¶çš„ä½“ç§¯ï¼Œåˆå¯ä»¥æé«˜è¿è¡Œæ—¶çš„æ•ˆç‡ã€‚\nå¯æ¨æ–­çš„å±€éƒ¨å˜é‡ # Go ç¼–è¯‘å™¨åªå¯¹å‡½æ•°çš„å±€éƒ¨å˜é‡åšäº†ä¼˜åŒ–ï¼Œå½“å¯ä»¥æ¨æ–­å‡ºå‡½æ•°çš„å±€éƒ¨å˜é‡çš„å€¼æ—¶ï¼Œæ­»ç æ¶ˆé™¤ä»ç„¶ä¼šç”Ÿæ•ˆï¼Œä¾‹å¦‚ï¼š\nfunc main() { var a, b = 10, 20 if max(a, b) == a { fmt.Println(a) } } ä¸Šé¢çš„ä»£ç ä¸ useconst.go çš„ç¼–è¯‘ç»“æœæ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºç¼–è¯‘å™¨å¯ä»¥æ¨æ–­å‡º aã€b å˜é‡çš„å€¼ã€‚\nå¦‚æœå¢åŠ äº†å¹¶å‘æ“ä½œï¼š\nfunc main() { var a, b = 10, 20 go func() { b, a = a, b }() if max(a, b) == a { fmt.Println(a) } } ä¸Šé¢çš„ä»£ç ï¼Œaã€b çš„å€¼ä¸èƒ½æœ‰æ•ˆæ¨æ–­ï¼Œæ­»ç æ¶ˆé™¤å¤±æ•ˆã€‚\nåŒ…çº§åˆ«çš„å˜é‡æ¨æ–­éš¾åº¦æ˜¯éå¸¸å¤§çš„ã€‚å‡½æ•°å†…éƒ¨çš„å±€éƒ¨å˜é‡çš„ä¿®æ”¹åªä¼šå‘ç”Ÿåœ¨è¯¥å‡½æ•°ä¸­ã€‚ä½†æ˜¯å¦‚æœæ˜¯åŒ…çº§åˆ«çš„å˜é‡ï¼Œå¯¹è¯¥å˜é‡çš„ä¿®æ”¹å¯èƒ½å‡ºç°åœ¨ï¼š\nåŒ…åˆå§‹åŒ–å‡½æ•° init() ä¸­ï¼Œinit() å‡½æ•°å¯èƒ½æœ‰å¤šä¸ªï¼Œä¸”å¯èƒ½ä½äºä¸åŒçš„ .go æºæ–‡ä»¶ã€‚ åŒ…å†…çš„å…¶ä»–å‡½æ•°ã€‚ å¦‚æœæ˜¯ public å˜é‡ï¼ˆé¦–å­—æ¯å¤§å†™ï¼‰ï¼Œå…¶ä»–åŒ…å¼•ç”¨æ—¶å¯ä¿®æ”¹ã€‚ å› æ­¤ï¼ŒGo ç¼–è¯‘å™¨åªå¯¹å±€éƒ¨å˜é‡ä½œäº†ä¼˜åŒ–ã€‚\nåˆ©ç”¨ sync.Pool å‡å°‘å †åˆ†é… # sync.Pool ä½¿ç”¨ã€‚\næ§åˆ¶ goroutine çš„å¹¶å‘æ•°é‡ # åŸºäº GPM çš„ Go è°ƒåº¦å™¨ï¼Œå¯ä»¥å¤§è§„æ¨¡çš„åˆ›å»º goroutine æ¥æ‰§è¡Œä»»åŠ¡ï¼Œå¯èƒ½ 1kï¼Œ1w ä¸ª goroutine æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯å½“ goroutine éå¸¸å¤§æ—¶ï¼Œæ¯”å¦‚ 10wï¼Œ100w ç”šè‡³æ›´å¤š å°±ä¼šå‡ºç°é—®é¢˜ã€‚\nå³ä½¿æ¯ä¸ª goroutine åªåˆ†é… 2KB çš„å†…å­˜ï¼Œä½†æ˜¯æ•°é‡å¤ªå¤šä¼šå¯¼è‡´å†…å­˜å ç”¨æš´æ¶¨ï¼Œå¯¹ GC é€ æˆæå¤§çš„å‹åŠ›ï¼ŒGC æ˜¯æœ‰ STW æœºåˆ¶çš„ï¼Œè¿è¡Œæ—¶ä¼šæŒ‚èµ·ç”¨æˆ·ç¨‹åºç›´åˆ°åƒåœ¾å›æ”¶å®Œã€‚è™½ç„¶ Go 1.8 å»æ‰äº† STW ä»¥åŠæ”¹æˆäº†å¹¶è¡Œ GCï¼Œæ€§èƒ½ä¸Šæœ‰äº†ä¸ å°çš„æå‡ä½†æ˜¯ï¼Œå¦‚æœå¤ªè¿‡äºé¢‘ç¹åœ°è¿›è¡Œ GCï¼Œä¾ç„¶ä¼šæœ‰æ€§èƒ½ç“¶é¢ˆã€‚ runtime å’Œ GC ä¹Ÿéƒ½æ˜¯ goroutineï¼Œå¦‚æœ goroutine è§„æ¨¡å¤ªå¤§ï¼Œå†…å­˜åƒç´§ï¼ŒGo è°ƒåº¦å™¨å°±ä¼šé˜»å¡ goroutineï¼Œè¿›è€Œå¯¼è‡´å†…å­˜æº¢å‡ºï¼Œç”šè‡³ crashã€‚ åˆ©ç”¨ channel çš„ç¼“å­˜åŒºæ§åˆ¶å¹¶å‘æ•°é‡ # func main() { var wg sync.WaitGroup // åˆ›å»ºç¼“å†²åŒºå¤§å°ä¸º 3 çš„ channel ch := make(chan struct{}, 3) for i := 0; i \u0026lt; 10; i++ { // å¦‚æœç¼“å­˜åŒºæ»¡äº†ï¼Œåˆ™ä¼šé˜»å¡åœ¨è¿™é‡Œ ch \u0026lt;- struct{}{} wg.Add(1) go func(i int) { defer wg.Done() log.Println(i) time.Sleep(time.Second) // é‡Šæ”¾ç¼“å†²åŒº \u0026lt;-ch }(i) } wg.Wait() } ä½¿ç”¨ç¬¬ä¸‰æ–¹ goroutine pool # å¸¸ç”¨çš„ç¬¬ä¸‰æ–¹ goroutine poolï¼š\nants conc é›¶æ‹·è´ä¼˜åŒ– # ä¼˜åŒ–å­—ç¬¦ä¸²ä¸å­—èŠ‚è½¬æ¢ï¼Œå‡å°‘å†…å­˜åˆ†é… # è®¾ç½® GOMAXPROCS # "},{"id":19,"href":"/golang-learn/docs/concurrency/05_once/","title":"Once","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" Once # Go æ ‡å‡†åº“ä¸­ sync.Once å¯ä»¥ä¿è¯ Go ç¨‹åºè¿è¡ŒæœŸé—´çš„æŸæ®µä»£ç åªä¼šæ‰§è¡Œä¸€æ¬¡ã€‚å¸¸å¸¸ç”¨äºå•ä¾‹å¯¹è±¡çš„åˆå§‹åŒ–åœºæ™¯ã€‚\nä½¿ç”¨ # sync.Once åªæœ‰ä¸€ä¸ªå¯¹å¤–å”¯ä¸€æš´éœ²çš„æ–¹æ³• Doï¼Œå¯ä»¥å¤šæ¬¡è°ƒç”¨ï¼Œä½†æ˜¯åªç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶ä¼šæ‰§è¡Œä¸€æ¬¡ã€‚\nfunc main() { o := \u0026amp;sync.Once{} for i := 0; i \u0026lt; 10; i++ { o.Do(func() { fmt.Println(\u0026#34;only once\u0026#34;) }) } } è¿è¡Œï¼š\n$ go run main.go only once åˆ©ç”¨ channel å®ç° Once # ä¸‹é¢çš„ä»£ç ä¹Ÿå¯ä»¥è¾¾åˆ°æ‰§è¡Œä¸€æ¬¡çš„æ•ˆæœï¼Œä¸è¿‡é‡å¤æ‰§è¡Œä¼šå¯¼è‡´ panicï¼š\nvar setonce chan struct{} func initialize() { // channel ä¸å¯ä»¥é‡å¤å…³é—­ï¼Œå¦åˆ™ä¼š panic close(a.setonce) // åˆå§‹åŒ– // ... } åŸç† # sync.Once çš„å®ç°ï¼š\n// src/sync/once.go type Once struct { done uint32 m Mutex } func (o *Once) Do(f func()) { // å¦‚æœä¼ å…¥çš„å‚æ•° f å·²ç»æ‰§è¡Œè¿‡ï¼Œç›´æ¥è¿”å› if atomic.LoadUint32(\u0026amp;o.done) == 0 { o.doSlow(f) } } func (o *Once) doSlow(f func()) { // ä¸ºå½“å‰ goroutine åŠ é” o.m.Lock() defer o.m.Unlock() if o.done == 0 { // å°† done è®¾ç½®ä¸º 1 defer atomic.StoreUint32(\u0026amp;o.done, 1) // æ‰§è¡Œå‚æ•° f f() } } sync.Once ä½¿ç”¨äº’æ–¥é”å’ŒåŸå­æ“ä½œå®ç°äº†æŸä¸ªå‡½æ•°åœ¨ç¨‹åºè¿è¡ŒæœŸé—´åªèƒ½æ‰§è¡Œä¸€æ¬¡çš„è¯­ä¹‰ã€‚\nä½¿ç”¨äº’æ–¥é”ï¼ŒåŒæ—¶åˆ©ç”¨åŒæ£€æŸ¥çš„æœºåˆ¶ï¼ˆdouble-checkingï¼‰ï¼Œå†æ¬¡åˆ¤æ–­ o.done æ˜¯å¦ä¸º 0ï¼Œå¦‚æœä¸º 0ï¼Œåˆ™æ˜¯ç¬¬ä¸€æ¬¡æ‰§è¡Œï¼Œæ‰§è¡Œå®Œæ¯•åï¼Œå°±å°† o.done è®¾ç½®ä¸º 1ï¼Œç„¶åé‡Šæ”¾é”ã€‚\nå³ä½¿æœ‰å¤šä¸ª goroutine åŒæ—¶è¿›å…¥äº† doSlow æ–¹æ³•ï¼Œå› ä¸ºåŒæ£€æŸ¥çš„æœºåˆ¶ï¼Œåç»­çš„ goroutine ä¼šçœ‹åˆ° o.done çš„å€¼ä¸º 1ï¼Œä¹Ÿä¸ä¼šå†æ¬¡æ‰§è¡Œ fã€‚\n"},{"id":20,"href":"/golang-learn/docs/basic/05_function/","title":"å‡½æ•°","section":"ğŸš è¯­è¨€åŸºç¡€","content":" å‡½æ•° # å‚æ•°ä¼ é€’ # å‡½æ•°çš„å‚æ•°ä¼ é€’æœ‰ä¸¤ç§æ–¹å¼ï¼š\nå€¼ä¼ é€’ï¼šå½“ä¼ ä¸€ä¸ªå‚æ•°å€¼åˆ°è¢«è°ƒç”¨çš„å‡½æ•°é‡Œé¢æ—¶ï¼Œå®é™…ä¸Šæ˜¯ä¼ äº†è¿™ä¸ªå€¼çš„å‰¯æœ¬ï¼Œè¢«è°ƒç”¨æ–¹å’Œè°ƒç”¨æ–¹ä¸¤è€…æŒæœ‰ä¸ç›¸å…³çš„ä¸¤ä»½æ•°æ®ã€‚ å¼•ç”¨ä¼ é€’ï¼šå½“ä¼ ä¸€ä¸ªå‚æ•°å€¼åˆ°è¢«è°ƒç”¨çš„å‡½æ•°é‡Œé¢æ—¶ï¼Œå®é™…æ˜¯ä¼ äº†å‚æ•°çš„æŒ‡é’ˆï¼Œè¢«è°ƒç”¨æ–¹å’Œè°ƒç”¨æ–¹ä¸¤è€…æŒæœ‰ç›¸åŒçš„æ•°æ®ï¼Œä»»æ„ä¸€æ–¹åšå‡ºçš„ä¿®æ”¹éƒ½ä¼šå½±å“å¦ä¸€æ–¹ã€‚ Go ä½¿ç”¨çš„æ˜¯å€¼ä¼ é€’ï¼Œä¸ç®¡å‚æ•°æ˜¯åŸºæœ¬ç±»å‹ï¼Œç»“æ„ä½“è¿˜æ˜¯æŒ‡é’ˆï¼Œéƒ½ä¼šå¯¹ä¼ é€’çš„å‚æ•°è¿›è¡Œæ‹·è´ï¼ŒåŒºåˆ«æ— éæ˜¯æ‹·è´çš„ç›®æ ‡å¯¹è±¡è¿˜æ˜¯æ‹·è´æŒ‡é’ˆã€‚æ‹·è´æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯ä¼šåŒæ—¶å‡ºç°ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŸæœ‰çš„å†…å­˜ç©ºé—´ã€‚\npackage main import \u0026#34;fmt\u0026#34; type foo struct { i int } func printFunc(a foo, b, c *foo) { a.i = 31 b.i = 41 c = \u0026amp;foo{i: 60} fmt.Printf(\u0026#34;print function - a=(%d, %p) b=(%v, %p) c=(%v, %p)\\n\u0026#34;, a, \u0026amp;a, b, \u0026amp;b, c, \u0026amp;c) } func main() { a := foo{i: 30} b := \u0026amp;foo{i: 40} c := \u0026amp;foo{i: 50} fmt.Printf(\u0026#34;before calling - a=(%d, %p) b=(%v, %p) c=(%v, %p)\\n\u0026#34;, a, \u0026amp;a, b, \u0026amp;b, c, \u0026amp;c) printFunc(a, b, c) fmt.Printf(\u0026#34;after calling - a=(%d, %p) b=(%v, %p) c=(%v, %p)\\n\u0026#34;, a, \u0026amp;a, b, \u0026amp;b, c, \u0026amp;c) } è¿è¡Œåè¾“å‡ºï¼š\nbefore calling - a=({30}, 0xc00000a0d8) b=(\u0026amp;{40}, 0xc00004c020) c=(\u0026amp;{50}, 0xc00004c028) print function - a=({31}, 0xc00000a120) b=(\u0026amp;{41}, 0xc00004c038) c=(\u0026amp;{60}, 0xc00004c040) after calling - a=({30}, 0xc00000a0d8) b=(\u0026amp;{41}, 0xc00004c020) c=(\u0026amp;{50}, 0xc00004c028) a ä¼ å…¥å‡½æ•°çš„åªæ˜¯å‰¯æœ¬ï¼Œå‡½æ•°å†…çš„ä¿®æ”¹ä¸ä¼šå½±å“åˆ°è°ƒç”¨æ–¹ã€‚ b ä¼ å…¥å‡½æ•°çš„æ˜¯æŒ‡é’ˆçš„å‰¯æœ¬ï¼Œä½†æ˜¯ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€ç‰‡å†…å­˜ç©ºé—´ï¼Œä¿®æ”¹åä¼šå½±å“åˆ°è°ƒç”¨æ–¹ã€‚ c ä¼ å…¥å‡½æ•°çš„æ˜¯æŒ‡é’ˆçš„å‰¯æœ¬ï¼Œä½†æ˜¯å‡½æ•°å†…çš„ c = \u0026amp;foo{i: 60} å°†è¿™ä¸ªæŒ‡é’ˆå‰¯æœ¬æŒ‡å‘äº†å¦ä¸€ç‰‡å†…å­˜ç©ºé—´ï¼Œæ‰€ä»¥ä¸ä¼šå†å½±å“è°ƒç”¨æ–¹ã€‚ ä¼ å€¼è¿˜æ˜¯ä¼ æŒ‡é’ˆï¼Ÿ # è¡¨é¢ä¸Šçœ‹ï¼ŒæŒ‡é’ˆå‚æ•°æ€§èƒ½ä¼šæ›´å¥½ï¼Œä½†æ˜¯è¦æ³¨æ„è¢«å¤åˆ¶çš„æŒ‡é’ˆä¼šå»¶é•¿ç›®æ ‡å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œè¿˜å¯èƒ½å¯¼è‡´å®ƒè¢«åˆ†é…åˆ°å †ä¸Šï¼Œå…¶æ€§èƒ½æ¶ˆè€—è¦åŠ ä¸Šå †å†…å­˜åˆ†é…å’Œåƒåœ¾å›æ”¶çš„æˆæœ¬ã€‚\nåœ¨æ ˆä¸Šå¤åˆ¶å°å¯¹è±¡ï¼Œè¦æ¯”å †ä¸Šåˆ†é…å†…å­˜è¦å¿«çš„å¤šã€‚å¦‚æœå¤åˆ¶æˆæœ¬é«˜ï¼Œæˆ–è€…éœ€è¦ä¿®æ”¹åŸå¯¹è±¡ï¼Œä½¿ç”¨æŒ‡é’ˆæ›´å¥½ã€‚\n"},{"id":21,"href":"/golang-learn/docs/project/06_api_doc/","title":"API æ–‡æ¡£","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" API æ–‡æ¡£ # "},{"id":22,"href":"/golang-learn/docs/practice/06_trace/","title":"Go Trace","section":"ğŸ› ï¸ å®è·µ","content":" Go Trace # Go PProf å¾ˆéš¾å®Œæˆ Goroutine çš„åˆ†æã€‚è¿™å°±éœ€è¦ä½¿ç”¨ go tool trace å‘½ä»¤ã€‚\ngo tool pprof å¯ä»¥è·Ÿè¸ªè¿è¡Œç¼“æ…¢çš„å‡½æ•°ï¼Œæˆ–è€…æ‰¾åˆ°å¤§éƒ¨åˆ† CPU æ—¶é—´èŠ±è´¹åœ¨å“ªé‡Œã€‚ go tool trace æ›´é€‚åˆäºæ‰¾å‡ºç¨‹åºåœ¨ä¸€æ®µæ—¶é—´å†…æ­£åœ¨åšä»€ä¹ˆï¼Œè€Œä¸æ˜¯æ€»ä½“ä¸Šçš„å¼€é”€ã€‚\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;runtime/trace\u0026#34; ) func main() { f, err := os.Create(\u0026#34;trace.out\u0026#34;) if err != nil { panic(err) } defer f.Close() err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() ch := make(chan string) go func() { ch \u0026lt;- \u0026#34;hello\u0026#34; }() // read from channel \u0026lt;-ch } ç”Ÿæˆè·Ÿè¸ªæ–‡ä»¶ï¼š\ngo run main.go å¯åŠ¨å¯è§†åŒ–ç•Œé¢ï¼š\n$ go tool trace trace.out 2019/11/18 15:17:28 Parsing trace... 2019/11/18 15:17:28 Splitting trace... 2019/11/18 15:17:28 Opening browser. Trace viewer is listening on http://127.0.0.1:59181 æŸ¥çœ‹å¯è§†åŒ–ç•Œé¢ï¼š\nView trace Goroutine analysis Network blocking profile (â¬‡) Synchronization blocking profile (â¬‡) Syscall blocking profile (â¬‡) Scheduler latency profile (â¬‡) User-defined tasks User-defined regions Minimum mutator utilization View traceï¼šæœ€å¤æ‚ã€æœ€å¼ºå¤§å’Œäº¤äº’å¼çš„å¯è§†åŒ–æ˜¾ç¤ºäº†æ•´ä¸ªç¨‹åºæ‰§è¡Œçš„æ—¶é—´è½´ã€‚è¿™ä¸ªè§†å›¾æ˜¾ç¤ºäº†åœ¨æ¯ä¸ªè™šæ‹Ÿå¤„ç†å™¨ä¸Šè¿è¡Œç€ä»€ä¹ˆï¼Œ ä»¥åŠä»€ä¹ˆæ˜¯è¢«é˜»å¡ç­‰å¾…è¿è¡Œçš„ã€‚ Goroutine analysisï¼šæ˜¾ç¤ºäº†åœ¨æ•´ä¸ªæ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œæ¯ç§ç±»å‹çš„ goroutines æ˜¯å¦‚ä½•åˆ›å»ºçš„ã€‚åœ¨é€‰æ‹©ä¸€ç§ç±»å‹ä¹‹åå°±å¯ä»¥çœ‹åˆ°å…³äºè¿™ç§ ç±»å‹çš„ goroutine çš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œåœ¨è¯•å›¾ä» mutex è·å–é”ã€ä»ç½‘ç»œè¯»å–ã€è¿è¡Œç­‰ç­‰æ¯ä¸ª goroutine è¢«é˜»å¡çš„æ—¶é—´ã€‚ Network blocking profileï¼šç½‘ç»œé˜»å¡æ¦‚å†µ Synchronization blocking profileï¼šåŒæ­¥é˜»å¡æ¦‚å†µ Syscall blocking profileï¼šç³»ç»Ÿè°ƒç”¨é˜»å¡æ¦‚å†µ Scheduler latency profileï¼šä¸ºè°ƒåº¦å™¨çº§åˆ«çš„ä¿¡æ¯æä¾›è®¡æ—¶åŠŸèƒ½ï¼Œæ˜¾ç¤ºè°ƒåº¦åœ¨å“ªé‡Œæœ€è€—è´¹æ—¶é—´ã€‚ User defined tasksï¼šç”¨æˆ·è‡ªå®šä¹‰ä»»åŠ¡ User defined regionsï¼šç”¨æˆ·è‡ªå®šä¹‰åŒºåŸŸ Minimum mutator utilizationï¼šæœ€ä½ Mutator åˆ©ç”¨ç‡ Network/Sync/Syscall blocking profile æ˜¯åˆ†æé”ç«äº‰çš„æœ€ä½³é€‰æ‹©ã€‚\nScheduler latency profile # æŸ¥çœ‹é—®é¢˜æ—¶ï¼Œé™¤éæ˜¯å¾ˆæ˜æ˜¾çš„ç°è±¡ï¼Œå¦åˆ™å…ˆæŸ¥çœ‹ â€œScheduler latency profileâ€ï¼Œèƒ½é€šè¿‡ Graph çœ‹åˆ°æ•´ä½“çš„è°ƒç”¨å¼€é”€æƒ…å†µï¼Œå¦‚ä¸‹ï¼š\nè¿™é‡Œåªæœ‰ä¸¤å—ï¼Œä¸€ä¸ªæ˜¯ trace æœ¬èº«ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯ channel çš„æ”¶å‘ã€‚\nGoroutine analysis # é€šè¿‡ â€œGoroutine analysisâ€ è¿™ä¸ªåŠŸèƒ½çœ‹åˆ°æ•´ä¸ªè¿è¡Œè¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªå‡½æ•°å—æœ‰å¤šå°‘ä¸ªæœ‰ Goroutine åœ¨è·‘ï¼Œå¹¶ä¸”è§‚å¯Ÿæ¯ä¸ªçš„ Goroutine çš„è¿è¡Œ å¼€é”€éƒ½èŠ±è´¹åœ¨å“ªä¸ªé˜¶æ®µã€‚å¦‚ä¸‹ï¼š\nä¸Šå›¾æœ‰ 3 ä¸ª goroutineï¼Œåˆ†åˆ«æ˜¯ runtime.mainã€runtime/trace.Start.func1ã€main.main.func1ï¼š\nåŒæ—¶ä¹Ÿå¯ä»¥çœ‹åˆ°å½“å‰ Goroutine åœ¨æ•´ä¸ªè°ƒç”¨è€—æ—¶ä¸­çš„å æ¯”ï¼Œä»¥åŠ GC æ¸…æ‰«å’Œ GC æš‚åœç­‰å¾…çš„ä¸€äº›å¼€é”€ã€‚å¯ä»¥æŠŠå›¾è¡¨ä¸‹è½½ä¸‹æ¥åˆ†æï¼Œç›¸å½“äºæŠŠ æ•´ä¸ª Goroutine è¿è¡Œæ—¶æ°å¼€æ¥çœ‹äº†ï¼Œè¿™å—èƒ½å¤Ÿå¾ˆå¥½çš„å¸®åŠ©å¯¹ Goroutine è¿è¡Œé˜¶æ®µåšä¸€ä¸ªçš„å‰–æï¼Œå¯ä»¥å¾—çŸ¥åˆ°åº•æ…¢å“ªï¼Œç„¶åå†å†³å®š ä¸‹ä¸€æ­¥çš„æ’æŸ¥æ–¹å‘ã€‚å¦‚ä¸‹ï¼š\nåç§° å«ä¹‰ è€—æ—¶ Execution Time æ‰§è¡Œæ—¶é—´ 3140ns Network Wait Time ç½‘ç»œç­‰å¾…æ—¶é—´ 0ns Sync Block Time åŒæ­¥é˜»å¡æ—¶é—´ 0ns Blocking Syscall Time è°ƒç”¨é˜»å¡æ—¶é—´ 0ns Scheduler Wait Time è°ƒåº¦ç­‰å¾…æ—¶é—´ 14ns GC Sweeping GC æ¸…æ‰« 0ns GC Pause GC æš‚åœ 0ns View trace # æ—¶é—´çº¿ï¼šæ˜¾ç¤ºæ‰§è¡Œçš„æ—¶é—´å•å…ƒï¼Œæ ¹æ®æ—¶é—´ç»´åº¦çš„ä¸åŒå¯ä»¥è°ƒæ•´åŒºé—´ï¼Œå…·ä½“å¯æ‰§è¡Œ shift + ? æŸ¥çœ‹å¸®åŠ©æ‰‹å†Œã€‚ å †ï¼šæ˜¾ç¤ºæ‰§è¡ŒæœŸé—´çš„å†…å­˜åˆ†é…å’Œé‡Šæ”¾æƒ…å†µã€‚ åç¨‹ï¼šæ˜¾ç¤ºåœ¨æ‰§è¡ŒæœŸé—´çš„æ¯ä¸ª Goroutine è¿è¡Œé˜¶æ®µæœ‰å¤šå°‘ä¸ªåç¨‹åœ¨è¿è¡Œï¼Œå…¶åŒ…å« GC ç­‰å¾…ï¼ˆGCWaitingï¼‰ã€å¯è¿è¡Œï¼ˆRunnableï¼‰ã€ è¿è¡Œä¸­ï¼ˆRunningï¼‰è¿™ä¸‰ç§çŠ¶æ€ã€‚ OS çº¿ç¨‹ï¼šæ˜¾ç¤ºåœ¨æ‰§è¡ŒæœŸé—´æœ‰å¤šå°‘ä¸ªçº¿ç¨‹åœ¨è¿è¡Œï¼Œå…¶åŒ…å«æ­£åœ¨è°ƒç”¨ Syscallï¼ˆInSyscallï¼‰ã€è¿è¡Œä¸­ï¼ˆRunningï¼‰è¿™ä¸¤ç§çŠ¶æ€ã€‚ è™šæ‹Ÿå¤„ç†å™¨ï¼šæ¯ä¸ªè™šæ‹Ÿå¤„ç†å™¨æ˜¾ç¤ºä¸€è¡Œï¼Œè™šæ‹Ÿå¤„ç†å™¨çš„æ•°é‡ä¸€èˆ¬é»˜è®¤ä¸ºç³»ç»Ÿå†…æ ¸æ•°ã€‚ åç¨‹å’Œäº‹ä»¶ï¼šæ˜¾ç¤ºåœ¨æ¯ä¸ªè™šæ‹Ÿå¤„ç†å™¨ä¸Šæœ‰ä»€ä¹ˆ Goroutine æ­£åœ¨è¿è¡Œï¼Œè€Œè¿çº¿è¡Œä¸ºä»£è¡¨äº‹ä»¶å…³è”ã€‚ ç‚¹å‡»å…·ä½“çš„ Goroutine è¡Œä¸ºåå¯ä»¥çœ‹åˆ°å…¶ç›¸å…³è”çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¿™å—å¾ˆç®€å•ï¼Œå¤§å®¶å®é™…æ“ä½œä¸€ä¸‹å°±æ‡‚äº†ã€‚æ–‡å­—è§£é‡Šå¦‚ä¸‹ï¼š\nStartï¼šå¼€å§‹æ—¶é—´ Wall Durationï¼šæŒç»­æ—¶é—´ Self Timeï¼šæ‰§è¡Œæ—¶é—´ Start Stack Traceï¼šå¼€å§‹æ—¶çš„å †æ ˆä¿¡æ¯ End Stack Traceï¼šç»“æŸæ—¶çš„å †æ ˆä¿¡æ¯ Incoming flowï¼šè¾“å…¥æµ Outgoing flowï¼šè¾“å‡ºæµ Preceding eventsï¼šä¹‹å‰çš„äº‹ä»¶ Following eventsï¼šä¹‹åçš„äº‹ä»¶ All connectedï¼šæ‰€æœ‰è¿æ¥çš„äº‹ä»¶ View Events # å¯ä»¥é€šè¿‡ç‚¹å‡» View Options-Flow eventsã€Following events ç­‰æ–¹å¼ï¼ŒæŸ¥çœ‹åº”ç”¨è¿è¡Œä¸­çš„äº‹ä»¶æµæƒ…å†µã€‚å¦‚ä¸‹ï¼š\né€šè¿‡åˆ†æå›¾ä¸Šçš„äº‹ä»¶æµï¼Œå¯å¾—çŸ¥è¿™ç¨‹åºä» G1 runtime.main å¼€å§‹è¿è¡Œï¼Œåœ¨è¿è¡Œæ—¶åˆ›å»ºäº† 2 ä¸ª Goroutineï¼Œ å…ˆæ˜¯åˆ›å»º G18 runtime/trace.Start.func1ï¼Œç„¶åå†æ˜¯ G19 main.main.func1 ã€‚è€ŒåŒæ—¶å¯ä»¥é€šè¿‡å…¶ Goroutine Name å»äº†è§£ å®ƒçš„è°ƒç”¨ç±»å‹ï¼Œå¦‚ï¼šruntime/trace.Start.func1 å°±æ˜¯ç¨‹åºä¸­åœ¨ main.main è°ƒç”¨äº† runtime/trace.Start æ–¹æ³•ï¼Œç„¶åè¯¥æ–¹æ³•åˆåˆ©ç”¨ åç¨‹åˆ›å»ºäº†ä¸€ä¸ªé—­åŒ… func1 å»è¿›è¡Œè°ƒç”¨ã€‚\nç»“åˆå¼€å¤´çš„ä»£ç å»çœ‹çš„è¯ï¼Œå¾ˆæ˜æ˜¾å°±æ˜¯ ch çš„è¾“å…¥è¾“å‡ºçš„è¿‡ç¨‹äº†ã€‚\næ”¶é›† trace # ä½¿ç”¨ runtime/trace åŒ… è°ƒç”¨ trace.Start å’Œ trace.Stopã€‚\nä½¿ç”¨ -trace=\u0026lt;file\u0026gt; æµ‹è¯•æ ‡å¿— ç”¨æ¥æ”¶é›†å…³äºè¢«æµ‹è¯•ä»£ç çš„ trace æ—¶æ¯”è¾ƒæœ‰ç”¨ã€‚\nä½¿ç”¨ debug/pprof/trace handler ç”¨æ¥æ”¶é›†è¿è¡Œä¸­çš„ web åº”ç”¨çš„ traceã€‚\nè·Ÿè¸ªä¸€ä¸ª web åº”ç”¨ # å¦‚æœæ—©å·²åŸ‹å¥½ _ \u0026quot;net/http/pprof\u0026quot; è¿™ä¸ªå·¥å…·ï¼Œå°±å¯ä»¥æ‰§è¡Œï¼š\ncurl http://127.0.0.1:6060/debug/pprof/trace\\?seconds\\=20 \u0026gt; trace.out go tool trace trace.out View trace # ç‚¹å¼€äº† View trace ç•Œé¢ï¼š\nåœ¨åˆé€‚çš„åŒºåŸŸæ‰§è¡Œå¿«æ·é”® W ä¸æ–­åœ°æ”¾å¤§æ—¶é—´çº¿ï¼Œå¦‚ä¸‹ï¼š\nåˆæ­¥æ’æŸ¥ï¼Œç»å¤§éƒ¨åˆ†çš„ G éƒ½å’Œ google.golang.org/grpc.(*Server).Serve.func æœ‰å…³ï¼Œå…³è”çš„ä¸€å¤§ä¸²ä¹Ÿæ˜¯ Serve æ‰€è§¦å‘çš„ç›¸å…³åŠ¨ä½œã€‚\nç»§ç»­è¿½è¸ª View trace æ·±å…¥è¿›å»ï¼Œâ€œNetwork blocking profileâ€ å’Œ â€œSyscall blocking profileâ€ æ‰€æä¾›çš„ä¿¡æ¯ï¼Œå¦‚ä¸‹ï¼š\nNetwork blocking profile # Syscall blocking profile # é€šè¿‡å¯¹ä»¥ä¸Šä¸‰é¡¹çš„è·Ÿè¸ªåˆ†æï¼ŒåŠ ä¸Šè¿™ä¸ªæ³„éœ²ï¼Œè¿™ä¸ªé˜»å¡çš„è€—æ—¶ï¼Œè¿™ä¸ªæ¶‰åŠçš„å†…éƒ¨æ–¹æ³•åï¼Œå¾ˆæ˜æ˜¾å°±æ˜¯å¿˜è®°å…³é—­å®¢æˆ·ç«¯è¿æ¥äº†ã€‚\nä¸å»ºè®®å°† pprof handlers æš´éœ²ç»™ Internetï¼Œå‚è€ƒ https://mmcloughlin.com/posts/your-pprof-is-showingã€‚\nå†…å®¹æ¥è‡ª Go å¤§æ€å™¨ä¹‹è·Ÿè¸ªå‰–æ trace\n"},{"id":23,"href":"/golang-learn/docs/concurrency/06_pool/","title":"Pool","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" Pool # Go ä» 1.3 ç‰ˆæœ¬å¼€å§‹æä¾›äº†å¯¹è±¡é‡ç”¨çš„æœºåˆ¶ï¼Œå³ sync.Poolã€‚sync.Pool ç”¨æ¥ä¿å­˜å¯ä»¥è¢«é‡å¤ä½¿ç”¨çš„ä¸´æ—¶å¯¹è±¡ï¼Œé¿å…äº†é‡å¤åˆ›å»ºå’Œé”€æ¯ä¸´æ—¶å¯¹è±¡å¸¦æ¥çš„æ¶ˆè€—ï¼Œé™ä½ GC å‹åŠ›ï¼Œæé«˜æ€§èƒ½ã€‚\nsync.Pool æ˜¯å¯ä¼¸ç¼©çš„ï¼Œä¹Ÿæ˜¯å¹¶å‘å®‰å…¨çš„ã€‚å¯ä»¥åœ¨å¤šä¸ª goroutine ä¸­å¹¶å‘è°ƒç”¨ sync.Pool å­˜å–å¯¹è±¡ã€‚\nä½¿ç”¨ # var buffers = sync.Pool{ New: func() interface{} { return new(bytes.Buffer) }, } func GetBuffer() *bytes.Buffer { return buffers.Get().(*bytes.Buffer) } func PutBuffer(buf *bytes.Buffer) { buf.Reset() buffers.Put(buf) } Newï¼šç±»å‹æ˜¯ func() interface{}ï¼Œç”¨æ¥åˆ›å»ºæ–°çš„å…ƒç´ ã€‚ Getï¼šä» Pool ä¸­å–å‡ºä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœæ²¡æœ‰æ›´å¤šçš„ç©ºé—²å…ƒç´ ï¼Œå°±è°ƒç”¨ New åˆ›å»ºæ–°çš„å…ƒç´ ã€‚å¦‚æœæ²¡æœ‰è®¾ç½® New é‚£ä¹ˆå¯èƒ½è¿”å› nilã€‚ Putï¼šå°†ä¸€ä¸ªå…ƒç´ æ”¾å› Pool ä¸­ï¼Œä½¿è¯¥å…ƒç´ å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œå¦‚æœ Put çš„å€¼æ˜¯ nilï¼Œä¼šè¢«å¿½ç•¥ã€‚\nå¯ä»¥å…ˆ Putï¼Œå† Get ä¹ˆï¼Ÿ # ä¸å¯ä»¥ã€‚\ntype item struct { value int } func main() { pool := sync.Pool{ New: func() interface{} { return item{} }, } pool.Put(item{value: 1}) data := pool.Get() fmt.Println(data) } åŸç† # Go 1.13 ä¹‹å‰çš„ sync.Pool çš„é—®é¢˜ï¼š\næ¯æ¬¡ GC éƒ½ä¼šå›æ”¶åˆ›å»ºçš„å¯¹è±¡ã€‚ ç¼“å­˜å…ƒç´ æ•°é‡å¤ªå¤šï¼Œå°±ä¼šå¯¼è‡´ STW è€—æ—¶å˜é•¿ï¼› ç¼“å­˜å…ƒç´ éƒ½è¢«å›æ”¶åï¼Œä¼šå¯¼è‡´ Get å‘½ä¸­ç‡ä¸‹é™ï¼ŒGet æ–¹æ³•ä¸å¾—ä¸æ–°åˆ›å»ºå¾ˆå¤šå¯¹è±¡ã€‚ åº•å±‚ä½¿ç”¨äº† Mutexï¼Œå¹¶å‘è¯·æ±‚ç«äº‰é”æ¿€çƒˆçš„æ—¶å€™ï¼Œä¼šå¯¼è‡´æ€§èƒ½çš„ä¸‹é™ã€‚ Go 1.13 è¿›è¡Œäº†ä¼˜åŒ–ï¼Œç§»é™¤äº† Mutexï¼Œå¢åŠ äº† victim ç¼“å­˜ã€‚\nPool çš„ç»“æ„ä½“ï¼š\ntype Pool struct { noCopy noCopy // æ¯ä¸ª P çš„æœ¬åœ°é˜Ÿåˆ—ï¼Œå®é™…ç±»å‹ä¸º [P]poolLocal local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal // [P]poolLocalçš„å¤§å° localSize uintptr // size of the local array victim unsafe.Pointer // local from previous cycle victimSize uintptr // size of victims array // è‡ªå®šä¹‰çš„å¯¹è±¡åˆ›å»ºå›è°ƒå‡½æ•°ï¼Œå½“ pool ä¸­æ— å¯ç”¨å¯¹è±¡æ—¶ä¼šè°ƒç”¨æ­¤å‡½æ•° New func() interface{} } é‡è¦çš„ä¸¤ä¸ªå­—æ®µæ˜¯ local å’Œ victimï¼Œéƒ½æ˜¯è¦ç”¨æ¥å­˜å‚¨ç©ºé—²çš„å…ƒç´ ã€‚\nlocal å­—æ®µå­˜å‚¨æŒ‡å‘ [P]poolLocal æ•°ç»„ï¼ˆä¸¥æ ¼æ¥è¯´ï¼Œå®ƒæ˜¯ä¸€ä¸ªåˆ‡ç‰‡ï¼‰çš„æŒ‡é’ˆã€‚è®¿é—®æ—¶ï¼ŒP çš„ id å¯¹åº” [P]poolLocal ä¸‹æ ‡ç´¢å¼•ã€‚é€šè¿‡è¿™æ ·çš„è®¾è®¡ï¼Œå¤šä¸ª goroutine ä½¿ç”¨ åŒä¸€ä¸ª Pool æ—¶ï¼Œå‡å°‘äº†ç«äº‰ï¼Œæå‡äº†æ€§èƒ½ã€‚\nåœ¨ src/sync/pool.go æ–‡ä»¶çš„ init å‡½æ•°é‡Œï¼Œæ³¨å†Œäº† GC å‘ç”Ÿæ—¶ï¼Œå¦‚ä½•æ¸…ç† Pool çš„å‡½æ•°ï¼š\nfunc init() { runtime_registerPoolCleanup(poolCleanup) } GC æ—¶ sync.Pool çš„å¤„ç†é€»è¾‘ï¼š\nfunc poolCleanup() { // ä¸¢å¼ƒå½“å‰ victim, STW æ‰€ä»¥ä¸ç”¨åŠ é” for _, p := range oldPools { p.victim = nil p.victimSize = 0 } // å°† local å¤åˆ¶ç»™ victim, å¹¶å°†åŸ local ç½®ä¸º nil for _, p := range allPools { p.victim = p.local p.victimSize = p.localSize p.local = nil p.localSize = 0 } oldPools, allPools = allPools, nil } poolCleanup ä¼šåœ¨ STW é˜¶æ®µè¢«è°ƒç”¨ã€‚ä¸»è¦æ˜¯å°† local å’Œ victim ä½œäº¤æ¢ï¼Œè¿™æ ·ä¹Ÿå°±ä¸è‡´äºè®© GC æŠŠæ‰€æœ‰çš„ Pool éƒ½æ¸…ç©ºäº†ã€‚\nå¦‚æœ sync.Pool çš„è·å–ã€é‡Šæ”¾é€Ÿåº¦ç¨³å®šï¼Œé‚£ä¹ˆå°±ä¸ä¼šæœ‰æ–°çš„æ± å¯¹è±¡è¿›è¡Œåˆ†é…ã€‚å¦‚æœè·å–çš„é€Ÿåº¦ä¸‹é™äº†ï¼Œé‚£ä¹ˆå¯¹è±¡å¯èƒ½ä¼šåœ¨ä¸¤ä¸ª GC å‘¨æœŸå†…è¢«é‡Šæ”¾ï¼Œè€Œä¸æ˜¯ Go 1.13 ä»¥å‰çš„ä¸€ä¸ª GC å‘¨æœŸã€‚\nè°ƒç”¨ Get æ—¶ï¼Œä¼šå…ˆä» victim ä¸­è·å–ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™å°±ä¼šä» local ä¸­è·å–ï¼Œå¦‚æœ local ä¸­ä¹Ÿæ²¡æœ‰ï¼Œå°±ä¼šæ‰§è¡Œ New åˆ›å»ºæ–°çš„å…ƒç´ ã€‚\nå†…å­˜æ³„éœ² # ä½¿ç”¨çš„ç¤ºä¾‹ä»£ç å®ç°äº†ä¸€ä¸ª buffer æ± ï¼Œè¿™ä¸ªå®ç°å¯èƒ½ä¼šæœ‰å†…å­˜æ³„æ¼çš„é£é™©ã€‚ä¸ºä»€ä¹ˆï¼Ÿ\nå› ä¸ºåœ¨å–å‡º bytes.Buffer ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥ç»™è¿™ä¸ª buffer ä¸­å¢åŠ å¤§é‡çš„ byte æ•°æ®ï¼Œè¿™ä¼šå¯¼è‡´åº•å±‚çš„ byte slice çš„å®¹é‡å¯èƒ½ä¼šå˜å¾—å¾ˆå¤§ã€‚è¿™ä¸ªæ—¶å€™ï¼Œå³ä½¿ Reset å†æ”¾å›åˆ°æ± å­ä¸­ï¼Œè¿™äº› byte slice çš„å®¹é‡ä¸ä¼šæ”¹å˜ï¼Œ æ‰€å çš„ç©ºé—´ä¾ç„¶å¾ˆå¤§ã€‚\nReset çš„å®ç°ï¼š\n// Reset resets the buffer to be empty, // but it retains the underlying storage for use by future writes. // Reset is the same as Truncate(0). func (b *Buffer) Reset() { // åŸºäºå·²æœ‰ slice åˆ›å»ºæ–° slice å¯¹è±¡ï¼Œä¸ä¼šæ‹·è´åŸæ•°ç»„æˆ–è€…åŸåˆ‡ç‰‡ä¸­çš„æ•°æ®ï¼Œæ–° slice å’Œè€ slice å…±ç”¨åº•å±‚æ•°ç»„ // å®ƒåªä¼šåˆ›å»ºä¸€ä¸ª æŒ‡å‘åŸæ•°ç»„çš„ åˆ‡ç‰‡ç»“æ„ä½“ï¼Œæ–°è€ slice å¯¹åº•å±‚æ•°ç»„çš„æ›´æ”¹éƒ½ä¼šå½±å“åˆ°å½¼æ­¤ã€‚ b.buf = b.buf[:0] b.off = 0 b.lastRead = opInvalid } // åˆ‡ç‰‡ç»“æ„ä½“ // runtime/slice.go type slice struct { array unsafe.Pointer // å…ƒç´ æŒ‡é’ˆï¼ŒæŒ‡å‘åº•å±‚æ•°ç»„ len int // é•¿åº¦ cap int // å®¹é‡ } åˆ‡ç‰‡ç»“æ„ä½“ï¼š\n// runtime/slice.go type slice struct { array unsafe.Pointer // å…ƒç´ æŒ‡é’ˆï¼ŒæŒ‡å‘åº•å±‚æ•°ç»„ len int // é•¿åº¦ cap int // å®¹é‡ } å› ä¸º Pool å›æ”¶çš„æœºåˆ¶ï¼Œè¿™äº›å¤§çš„ Buffer å¯èƒ½ä¸ä¼šè¢«ç«‹å³å›æ”¶ï¼Œè€Œæ˜¯ä¼šå ç”¨å¾ˆå¤§çš„ç©ºé—´ï¼Œè¿™å±äºå†…å­˜æ³„æ¼çš„é—®é¢˜ã€‚\nGo çš„æ ‡å‡†åº“ encoding/json å’Œ fmt ä¿®å¤è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯å¢åŠ äº†æ£€æŸ¥é€»è¾‘ï¼šå¦‚æœæ”¾å›çš„ buffer è¶…è¿‡ä¸€å®šå¤§å°ï¼Œå°±ç›´æ¥ä¸¢å¼ƒæ‰ï¼Œä¸å†æ”¾åˆ°æ± å­ä¸­ã€‚\n// è¶…è¿‡ä¸€å®šå¤§å°ï¼Œç›´æ¥ä¸¢å¼ƒæ‰ if cap(p.buf) \u0026gt; 64\u0026lt;\u0026lt;0 { return } // æ”¾å› pool æ‰€ä»¥åœ¨ä½¿ç”¨ sync.Pool æ—¶ï¼Œå›æ”¶ buffer çš„æ—¶å€™ï¼Œä¸€å®šè¦æ£€æŸ¥å›æ”¶çš„å¯¹è±¡çš„å¤§å°ã€‚å¦‚æœ buffer å¤ªå¤§ï¼Œå°±ç›´æ¥ä¸¢å¼ƒæ‰ã€‚\nä¼˜åŒ–å†…å­˜ä½¿ç”¨ # ä½¿ç”¨ buffer æ± çš„æ—¶å€™ï¼Œå¯ä»¥æ ¹æ®å®é™…å…ƒç´ çš„å¤§å°æ¥åˆ†ä¸ºå‡ ä¸ª buffer æ± ã€‚æ¯”å¦‚ï¼Œå°äº 512 byte çš„å…ƒç´ çš„ buffer å ä¸€ä¸ªæ± å­ï¼›å…¶æ¬¡ï¼Œå°äº 1K byte å¤§å°çš„å…ƒç´ å ä¸€ä¸ªæ± å­ï¼› å†æ¬¡ï¼Œå°äº 4K byte å¤§å°çš„å…ƒç´ å ä¸€ä¸ªæ± å­ã€‚è¿™æ ·åˆ†æˆå‡ ä¸ªæ± å­ä»¥åï¼Œå°±å¯ä»¥æ ¹æ®éœ€è¦ï¼Œåˆ°æ‰€éœ€å¤§å°çš„æ± å­ä¸­è·å– buffer äº†ã€‚\nä¾‹å¦‚æ ‡å‡†åº“ net/http/server.go çš„å®ç°ï¼š\nvar ( bufioReaderPool sync.Pool bufioWriter2kPool sync.Pool bufioWriter4kPool sync.Pool ) var copyBufPool = sync.Pool{ New: func() interface{} { b := make([]byte, 32*1024) return \u0026amp;b }, } func bufioWriterPool(size int) *sync.Pool { switch size { case 2 \u0026lt;\u0026lt; 10: return \u0026amp;bufioWriter2kPool case 4 \u0026lt;\u0026lt; 10: return \u0026amp;bufioWriter4kPool } return nil } è¿˜æœ‰ç¬¬ä¸‰æ–¹çš„å®ç°ï¼š\nbytebufferpool "},{"id":24,"href":"/golang-learn/docs/concurrency/07_context/","title":"Context","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" Context # Go 1.7 ç‰ˆæœ¬ä¸­æ­£å¼å¼•å…¥æ–°æ ‡å‡†åº“ contextã€‚ä¸»è¦çš„ä½œç”¨æ˜¯åœ¨åœ¨ä¸€ç»„ goroutine ä¹‹é—´ä¼ é€’å…±äº«çš„å€¼ã€å–æ¶ˆä¿¡å·ã€deadline ç­‰ã€‚\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline â€” è¿”å›å½“å‰ context çš„æˆªæ­¢æ—¶é—´ã€‚ Done â€” è¿”å›ä¸€ä¸ªåªè¯»çš„ channelï¼Œå¯ç”¨äºè¯†åˆ«å½“å‰ channel æ˜¯å¦å·²ç»è¢«å…³é—­ï¼Œå…¶åŸå› å¯èƒ½æ˜¯åˆ°æœŸï¼Œä¹Ÿå¯èƒ½æ˜¯è¢«å–æ¶ˆäº†ã€‚å¤šæ¬¡è°ƒç”¨ Done æ–¹æ³•ä¼šè¿”å›åŒä¸€ä¸ª channelã€‚ Err â€” è¿”å›å½“å‰ context è¢«å…³é—­çš„åŸå› ã€‚ å¦‚æœ context è¢«å–æ¶ˆï¼Œä¼šè¿”å› Canceled é”™è¯¯ã€‚ å¦‚æœ context è¶…æ—¶ï¼Œä¼šè¿”å› DeadlineExceeded é”™è¯¯ã€‚ Value â€” è¿”å›å½“å‰ context å¯¹åº”æ‰€å­˜å‚¨çš„ contextä¿¡æ¯ï¼Œå¯ä»¥ç”¨æ¥ä¼ é€’è¯·æ±‚ç‰¹å®šçš„æ•°æ®ã€‚ åˆ›å»º contextï¼š\nBackgroundï¼šåˆ›å»ºä¸€ä¸ªç©ºçš„ contextï¼Œä¸€èˆ¬ç”¨åœ¨ä¸»å‡½æ•°ã€åˆå§‹åŒ–ã€æµ‹è¯•ä»¥åŠåˆ›å»º root context çš„æ—¶å€™ã€‚ TODOï¼šåˆ›å»ºä¸€ä¸ªç©ºçš„ contextï¼Œä¸çŸ¥é“è¦ä¼ é€’ä¸€äº›ä»€ä¹ˆä¸Šä¸‹æ–‡ä¿¡æ¯çš„æ—¶å€™ï¼Œå°±ç”¨è¿™ä¸ªã€‚ WithCancelï¼šåŸºäº parent context åˆ›å»ºä¸€ä¸ªå¯ä»¥å–æ¶ˆçš„æ–° contextã€‚ WithTimeoutï¼šåŸºäº parent context åˆ›å»ºä¸€ä¸ªå…·æœ‰è¶…æ—¶æ—¶é—´çš„æ–° contextã€‚ WithDeadlineï¼šå’Œ WithTimeout ä¸€æ ·ï¼Œåªä¸è¿‡å‚æ•°æ˜¯æˆªæ­¢æ—¶é—´ï¼ˆè¶…æ—¶æ—¶é—´åŠ ä¸Šå½“å‰æ—¶é—´ï¼‰ã€‚ WithValueï¼šåŸºäºæŸä¸ª context åˆ›å»ºå¹¶å­˜å‚¨å¯¹åº”çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ æœ€å¸¸ç”¨çš„åœºæ™¯ï¼Œä½¿ç”¨ context æ¥å–æ¶ˆä¸€ä¸ª goroutine çš„è¿è¡Œï¼š\nfunc main() { ctx, cancel := context.WithCancel(context.Background()) go func() { defer func() { fmt.Println(\u0026#34;goroutine exit\u0026#34;) }() for { select { case \u0026lt;-ctx.Done(): return default: time.Sleep(time.Second) } } }() time.Sleep(time.Second) cancel() time.Sleep(2 * time.Second) } å¯ä»¥å¤šä¸ª goroutine åŒæ—¶è®¢é˜… ctx.Done() ç®¡é“ä¸­çš„æ¶ˆæ¯ï¼Œä¸€æ—¦æ¥æ”¶åˆ°å–æ¶ˆä¿¡å·å°±ç«‹åˆ»åœæ­¢å½“å‰æ­£åœ¨æ‰§è¡Œçš„å·¥ä½œã€‚\nåŸç† # context çš„æœ€å¤§ä½œç”¨å°±æ˜¯åœ¨ä¸€ç»„ goroutine æ„æˆçš„æ ‘å½¢ç»“æ„ä¸­å¯¹ä¿¡å·è¿›è¡ŒåŒæ­¥ï¼Œä»¥å‡å°‘è®¡ç®—èµ„æºçš„æµªè´¹ã€‚\nä¾‹å¦‚ï¼ŒGo çš„ HTTP serverï¼Œå¤„ç†æ¯ä¸€ä¸ªè¯·æ±‚ï¼Œéƒ½æ˜¯å¯åŠ¨ä¸€ä¸ªå•ç‹¬çš„ goroutineï¼Œå¤„ç†è¿‡ç¨‹ä¸­è¿˜ä¼šå¯åŠ¨æ–°çš„ goroutine æ¥è®¿é—®æ•°æ®åº“å’Œå…¶ä»–æœåŠ¡ã€‚è€Œ context åœ¨ä¸åŒ Goroutine ä¹‹é—´å¯ä»¥åŒæ­¥è¯·æ±‚ç‰¹å®šæ•°æ®ã€å–æ¶ˆä¿¡å·ä»¥åŠå¤„ç† è¯·æ±‚çš„æˆªæ­¢æ—¥æœŸã€‚\næ¯ä¸€ä¸ª context éƒ½ä¼šä» root goroutine ä¸€å±‚å±‚ä¼ é€’åˆ°åº•å±‚ã€‚context å¯ä»¥åœ¨ä¸Šå±‚ goroutine æ‰§è¡Œå‡ºç°é”™è¯¯æ—¶ï¼Œå°†ä¿¡å·åŠæ—¶åŒæ­¥ç»™ä¸‹å±‚ã€‚\nWithCancel # // src/context/context.go#L235 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := withCancel(parent) return c, func() { c.cancel(true, Canceled, nil) } } func withCancel(parent Context) *cancelCtx { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } c := \u0026amp;cancelCtx{} // æ„å»º çˆ¶å­ context ä¹‹é—´çš„å…³è”ï¼Œå½“ çˆ¶ context è¢«å–æ¶ˆæ—¶ï¼Œå­ context ä¹Ÿä¼šè¢«å–æ¶ˆ c.propagateCancel(parent, c) return c } func (c *cancelCtx) propagateCancel(parent Context, child canceler) { c.Context = parent done := parent.Done() if done == nil { // parent context æ˜¯ä¸ªç©º context return // parent is never canceled } select { case \u0026lt;-done: // parent context å·²ç»è¢«å–æ¶ˆï¼Œchild ä¹Ÿä¼šç«‹åˆ»è¢«å–æ¶ˆ child.cancel(false, parent.Err(), Cause(parent)) return default: } // æ‰¾åˆ°å¯ä»¥å–æ¶ˆçš„ parent context if p, ok := parentCancelCtx(parent); ok { p.mu.Lock() if p.err != nil { // parent context å·²ç»è¢«å–æ¶ˆï¼Œchild ä¹Ÿä¼šç«‹åˆ»è¢«å–æ¶ˆ child.cancel(false, p.err, p.cause) } else { // å°† child åŠ å…¥åˆ° parent çš„ children åˆ—è¡¨ä¸­ // ç­‰å¾… parent é‡Šæ”¾å–æ¶ˆä¿¡å· if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() return } if a, ok := parent.(afterFuncer); ok { // parent implements an AfterFunc method. c.mu.Lock() stop := a.AfterFunc(func() { child.cancel(false, parent.Err(), Cause(parent)) }) c.Context = stopCtx{ Context: parent, stop: stop, } c.mu.Unlock() return } goroutines.Add(1) // æ²¡æœ‰æ‰¾åˆ°å¯å–æ¶ˆçš„ parent context // è¿è¡Œä¸€ä¸ªæ–°çš„ goroutine åŒæ—¶ç›‘å¬ parent.Done() å’Œ child.Done() ä¸¤ä¸ª channel go func() { select { case \u0026lt;-parent.Done(): // åœ¨ parent.Done() å…³é—­æ—¶è°ƒç”¨ child.cancel å–æ¶ˆ å­ context child.cancel(false, parent.Err(), Cause(parent)) case \u0026lt;-child.Done(): // è¿™ä¸ªç©ºçš„ case è¡¨ç¤ºå¦‚æœå­èŠ‚ç‚¹è‡ªå·±å–æ¶ˆäº†ï¼Œé‚£å°±é€€å‡ºè¿™ä¸ª selectï¼Œçˆ¶èŠ‚ç‚¹çš„å–æ¶ˆä¿¡å·å°±ä¸ç”¨ç®¡äº†ã€‚ // å¦‚æœå»æ‰è¿™ä¸ª caseï¼Œé‚£ä¹ˆå¾ˆå¯èƒ½çˆ¶èŠ‚ç‚¹ä¸€ç›´ä¸å–æ¶ˆï¼Œè¿™ä¸ª goroutine å°±æ³„æ¼äº† } }() } func (c *cancelCtx) Done() \u0026lt;-chan struct{} { c.mu.Lock() // æœ‰è°ƒç”¨äº† Done() æ–¹æ³•çš„æ—¶å€™æ‰ä¼šè¢«åˆ›å»º if c.done == nil { c.done = make(chan struct{}) } // è¿”å›çš„æ˜¯ä¸€ä¸ªåªè¯»çš„ channel // è¿™ä¸ª channel ä¸ä¼šè¢«å†™å…¥æ•°æ®ï¼Œç›´æ¥è°ƒç”¨è¯»è¿™ä¸ª channelï¼Œåç¨‹ä¼šè¢« block ä½ã€‚ // ä¸€èˆ¬é€šè¿‡æ­é… select æ¥ä½¿ç”¨ã€‚ä¸€æ—¦å…³é—­ï¼Œå°±ä¼šç«‹å³è¯»å‡ºé›¶å€¼ã€‚ d := c.done c.mu.Unlock() return d } propagateCancel çš„ä½œç”¨å°±æ˜¯å‘ä¸Šå¯»æ‰¾å¯ä»¥â€œæŒ‚é â€çš„â€œå¯å–æ¶ˆâ€çš„ contextï¼Œå¹¶ä¸”â€œæŒ‚é â€ä¸Šå»ã€‚è¿™æ ·ï¼Œè°ƒç”¨ä¸Šå±‚ cancel æ–¹æ³•çš„æ—¶å€™ï¼Œå°±å¯ä»¥å±‚å±‚ä¼ é€’ï¼Œ å°†é‚£äº›æŒ‚é çš„å­ context åŒæ—¶â€œå–æ¶ˆâ€ã€‚\ncancelCtx.cancel ä¼šå…³é—­ context ä¸­çš„ channel å¹¶å‘æ‰€æœ‰çš„ å­ context åŒæ­¥å–æ¶ˆä¿¡å·ï¼š\nfunc (c *cancelCtx) cancel(removeFromParent bool, err, cause error) { // ... if d == nil { c.done.Store(closedchan) } else { close(d) } // éå†æ‰€æœ‰ å­ contextï¼Œå–æ¶ˆæ‰€æœ‰ å­ context for child := range c.children { // NOTE: acquiring the child\u0026#39;s lock while holding parent\u0026#39;s lock. child.cancel(false, err, cause) } // å°†å­èŠ‚ç‚¹ç½®ç©º c.children = nil // ... if removeFromParent { // ä»çˆ¶èŠ‚ç‚¹ä¸­ç§»é™¤è‡ªå·± removeChild(c.Context, c) } } WithTimeout å’Œ WithDeadline # WithTimeout å’Œ WithDeadline åˆ›å»ºçš„ context ä¹Ÿéƒ½æ˜¯å¯ä»¥è¢«å–æ¶ˆçš„ã€‚\nWithTimeout å’Œ WithDeadline åˆ›å»ºçš„æ˜¯ timeCtxï¼ŒtimerCtx åŸºäº cancelCtxï¼Œå¤šäº†ä¸€ä¸ª time.Timer å’Œ deadlineï¼š\ntype timerCtx struct { cancelCtx timer *time.Timer // Under cancelCtx.mu. deadline time.Time } func (c *timerCtx) cancel(removeFromParent bool, err error) { // ç›´æ¥è°ƒç”¨ cancelCtx çš„å–æ¶ˆæ–¹æ³• c.cancelCtx.cancel(false, err) if removeFromParent { // ä»çˆ¶èŠ‚ç‚¹ä¸­åˆ é™¤å­èŠ‚ç‚¹ removeChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { // å…³æ‰å®šæ—¶å™¨ï¼Œè¿™æ ·ï¼Œåœ¨deadline åˆ°æ¥æ—¶ï¼Œä¸ä¼šå†æ¬¡å–æ¶ˆ c.timer.Stop() c.timer = nil } c.mu.Unlock() } WithTimeout å®é™…å°±æ—¶è°ƒç”¨äº† WithDeadlineï¼Œä¼ å…¥çš„ deadline æ˜¯å½“å‰æ—¶é—´åŠ ä¸Š timeout çš„æ—¶é—´ï¼š\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } WithDeadline çš„å®ç°ï¼š\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { return WithDeadlineCause(parent, d, nil) } func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc) { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } // å¦‚æœ parent context çš„ deadline æ—©äºæŒ‡å®šæ—¶é—´ã€‚ç›´æ¥æ„å»ºä¸€ä¸ªå¯å–æ¶ˆçš„ context // åŸå› æ˜¯ä¸€æ—¦ parent context è¶…æ—¶ï¼Œè‡ªåŠ¨è°ƒç”¨ cancel å‡½æ•°ï¼Œå­èŠ‚ç‚¹ä¹Ÿä¼šéšä¹‹å–æ¶ˆ // æ‰€ä»¥æ²¡æœ‰å¿…è¦å†å¤„ç† å­ context çš„è®¡æ—¶å™¨ if cur, ok := parent.Deadline(); ok \u0026amp;\u0026amp; cur.Before(d) { return WithCancel(parent) } c := \u0026amp;timerCtx{ deadline: d, } // æ„å»ºä¸€ä¸ª cancelCtxï¼ŒæŒ‚é åˆ°ä¸€ä¸ªå¯å–æ¶ˆçš„ parent context ä¸Š // ä¹Ÿå°±æ˜¯è¯´ä¸€æ—¦ parent context å–æ¶ˆäº†ï¼Œè¿™ä¸ªå­ context éšä¹‹å–æ¶ˆã€‚ c.cancelCtx.propagateCancel(parent, c) dur := time.Until(d) if dur \u0026lt;= 0 { // è¶…è¿‡äº†æˆªæ­¢æ—¥æœŸï¼Œç›´æ¥å–æ¶ˆ c.cancel(true, DeadlineExceeded, cause) return c, func() { c.cancel(false, Canceled, nil) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { // åˆ°äº†æˆªæ­¢æ—¶é—´ï¼Œtimer ä¼šè‡ªåŠ¨è°ƒç”¨ cancel å‡½æ•°å–æ¶ˆ c.timer = time.AfterFunc(dur, func() { // ä¼ å…¥é”™è¯¯ DeadlineExceeded c.cancel(true, DeadlineExceeded, cause) }) } return c, func() { c.cancel(true, Canceled, nil) } } å¦‚æœè¦åˆ›å»ºçš„è¿™ä¸ª å­ context çš„ deadline æ¯” parent context çš„è¦æ™šï¼Œparent context åˆ°æ—¶é—´äº†ä¼šè‡ªåŠ¨å–æ¶ˆï¼Œå­ context ä¹Ÿä¼šå–æ¶ˆï¼Œ å¯¼è‡´ å­ context çš„ deadline æ—¶é—´è¿˜æ²¡åˆ°å°±ä¼šè¢«å–æ¶ˆ\nWithValue # // src/context/context.go#L713 func WithValue(parent Context, key, val any) Context { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } if key == nil { panic(\u0026#34;nil key\u0026#34;) } if !reflectlite.TypeOf(key).Comparable() { panic(\u0026#34;key is not comparable\u0026#34;) } return \u0026amp;valueCtx{parent, key, val} } type valueCtx struct { Context key, val interface{} } func (c *valueCtx) Value(key any) any { if c.key == key { return c.val } // å¦‚æœ valueCtx ä¸­å­˜å‚¨çš„é”®å€¼å¯¹ä¸ä¼ å…¥çš„å‚æ•°ä¸åŒ¹é… // å°±ä¼šä» parent context ä¸­æŸ¥æ‰¾è¯¥é”®å¯¹åº”çš„å€¼ç›´åˆ°æŸä¸ª parent context ä¸­è¿”å› nil æˆ–è€…æŸ¥æ‰¾åˆ°å¯¹åº”çš„å€¼ã€‚ return value(c.Context, key) } "},{"id":25,"href":"/golang-learn/docs/practice/07_coredump/","title":"Go CoreDump è°ƒè¯•","section":"ğŸ› ï¸ å®è·µ","content":" Go CoreDump è°ƒè¯• # Go ä¹Ÿå¯ä»¥å¼€å¯ç±»ä¼¼ C++ CoreDump åŠŸèƒ½ï¼ŒCoreDump æ˜¯å¼‚å¸¸é€€å‡ºç¨‹åºçš„å†…å­˜å¿«ç…§ã€‚ç¨‹åºå´©æºƒæ—¶ï¼Œå¯ä»¥å¸®åŠ©å®šä½ crash å‘ç”Ÿçš„åŸå› ã€‚\nå¦‚ä½•ç”Ÿæˆ CoreDump æ–‡ä»¶ # GOTRACEBACK å¯ä»¥æ§åˆ¶ç¨‹åºå´©æºƒæ—¶è¾“å‡ºçš„è¯¦ç»†ç¨‹åº¦ã€‚ å¯é€‰çš„å€¼ï¼š\nnone ä¸æ˜¾ç¤ºä»»ä½• goroutine æ ˆ traceã€‚ single, é»˜è®¤é€‰é¡¹ï¼Œæ˜¾ç¤ºå½“å‰ goroutine æ ˆ traceã€‚ all æ˜¾ç¤ºæ‰€æœ‰ç”¨æˆ·åˆ›å»ºçš„ goroutine æ ˆ traceã€‚ system æ˜¾ç¤ºæ‰€æœ‰ goroutine æ ˆ trace,ç”šè‡³è¿è¡Œæ—¶çš„ traceã€‚ crash ç±»ä¼¼ system, è€Œä¸”è¿˜ä¼šç”Ÿæˆ core dumpã€‚ å¯ä»¥è®¾ç½® export GOTRACEBACK=crash æ¥ç”Ÿæˆ core dumpã€‚\nç¼–è¯‘æ—¶è¦ç¡®ä¿ä½¿ç”¨ç¼–è¯‘å™¨æ ‡å¿— -N å’Œ -l æ¥æ„å»ºäºŒè¿›åˆ¶æ–‡ä»¶,å®ƒä¼šç¦ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œç¼–è¯‘å™¨ä¼˜åŒ–å¯èƒ½ä¼šä½¿è°ƒè¯•æ›´åŠ å›°éš¾ã€‚\n$ go build -gcflags=all=\u0026#34;-N -l\u0026#34; å¦‚æœ coredump æ²¡æœ‰ç”Ÿæˆï¼Œå¯èƒ½æ˜¯ coredump size é…ç½®ä¸º 0ï¼Œå¦‚ä¸‹å‘½ä»¤å°† coredump é…ç½®ä¸º 1MB å¤§å°ï¼š\n$ ulimit -c 1048576 å¦‚ä½•è°ƒè¯• CoreDump æ–‡ä»¶ # package main import \u0026#34;math/rand\u0026#34; func main() { var sum int for { n := rand.Intn(1e6) sum += n if sum % 42 == 0 { panic(\u0026#34;panic for GOTRACEBACK\u0026#34;) } } } ä¸Šé¢çš„ç¨‹åºå°†å¾ˆå¿«å´©æºƒ\npanic: panic for GOTRACEBACK goroutine 1 [running]: main.main() C:/Code/example.v1/system/coredump/main.go:21 +0x78 æ— æ³•ä»ä¸Šé¢çš„ panic æ ˆ trace ä¸­åˆ†è¾¨å‡ºå´©æºƒæ‰€æ¶‰åŠçš„å€¼ã€‚å¢åŠ æ—¥å¿—æˆ–è®¸æ˜¯ä¸€ç§è§£å†³æ–¹æ¡ˆï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸æ€»æ˜¯çŸ¥é“åœ¨ä½•å¤„æ·»åŠ æ—¥å¿—ã€‚ æ·»åŠ ç¯å¢ƒå˜é‡ GOTRACEBACK=crash å†è¿è¡Œå®ƒã€‚ç°åœ¨ä¼šå·²æ‰“å°å‡ºæ‰€æœ‰ goroutineï¼ŒåŒ…æ‹¬ runtimeï¼Œå› æ­¤è¾“å‡ºæ›´åŠ è¯¦ç»†ã€‚ å¹¶è¾“å‡º core dumpï¼š\nGOROOT=C:\\Program Files\\Go #gosetup GOPATH=C:\\Code\\gowork #gosetup \u0026#34;C:\\Program Files\\Go\\bin\\go.exe\u0026#34; build -o C:\\Users\\shipeng\\AppData\\Local\\Temp\\GoLand\\___1go_build_github_com_shipengqi_example_v1_system_coredump.exe github.com/shipengqi/example.v1/system/coredump #gosetup C:\\Users\\shipeng\\AppData\\Local\\Temp\\GoLand\\___1go_build_github_com_shipengqi_example_v1_system_coredump.exe #gosetup panic: panic for GOTRACEBACK goroutine 1 [running]: panic({0x4408c0, 0x45e5f8}) C:/Program Files/Go/src/runtime/panic.go:1147 +0x3a8 fp=0xc000047f58 sp=0xc000047e98 pc=0x40ea08 main.main() C:/Code/example.v1/system/coredump/main.go:21 +0x78 fp=0xc000047f80 sp=0xc000047f58 pc=0x43be58 runtime.main() C:/Program Files/Go/src/runtime/proc.go:255 +0x217 fp=0xc000047fe0 sp=0xc000047f80 pc=0x411437 runtime.goexit() C:/Program Files/Go/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc000047fe8 sp=0xc000047fe0 pc=0x435921 goroutine 2 [force gc (idle)]: runtime.gopark(0x0, 0x0, 0x0, 0x0, 0x0) C:/Program Files/Go/src/runtime/proc.go:366 +0xd6 fp=0xc000043fb0 sp=0xc000043f90 pc=0x4117d6 runtime.goparkunlock(...) C:/Program Files/Go/src/runtime/proc.go:372 runtime.forcegchelper() C:/Program Files/Go/src/runtime/proc.go:306 +0xb1 fp=0xc000043fe0 sp=0xc000043fb0 pc=0x411671 runtime.goexit() C:/Program Files/Go/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc000043fe8 sp=0xc000043fe0 pc=0x435921 created by runtime.init.7 C:/Program Files/Go/src/runtime/proc.go:294 +0x25 goroutine 3 [GC sweep wait]: runtime.gopark(0x0, 0x0, 0x0, 0x0, 0x0) C:/Program Files/Go/src/runtime/proc.go:366 +0xd6 fp=0xc000045fb0 sp=0xc000045f90 pc=0x4117d6 runtime.goparkunlock(...) C:/Program Files/Go/src/runtime/proc.go:372 runtime.bgsweep() C:/Program Files/Go/src/runtime/mgcsweep.go:163 +0x88 fp=0xc000045fe0 sp=0xc000045fb0 pc=0x3fc7e8 runtime.goexit() C:/Program Files/Go/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc000045fe8 sp=0xc000045fe0 pc=0x435921 created by runtime.gcenable C:/Program Files/Go/src/runtime/mgc.go:181 +0x55 goroutine 4 [GC scavenge wait]: runtime.gopark(0x0, 0x0, 0x0, 0x0, 0x0) C:/Program Files/Go/src/runtime/proc.go:366 +0xd6 fp=0xc000055f80 sp=0xc000055f60 pc=0x4117d6 runtime.goparkunlock(...) C:/Program Files/Go/src/runtime/proc.go:372 runtime.bgscavenge() C:/Program Files/Go/src/runtime/mgcscavenge.go:265 +0xcd fp=0xc000055fe0 sp=0xc000055f80 pc=0x3fa8ed runtime.goexit() C:/Program Files/Go/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc000055fe8 sp=0xc000055fe0 pc=0x435921 created by runtime.gcenable C:/Program Files/Go/src/runtime/mgc.go:182 +0x65 éœ€è¦è°ƒè¯•ï¼Œå°±å¯ä»¥ä½¿ç”¨ delveã€‚\nå®‰è£… delveï¼š\n$ go install github.com/go-delve/delve/cmd/dlv@latest é€šè¿‡ dlv core å‘½ä»¤æ¥è°ƒè¯• coredumpã€‚é€šè¿‡ bt å‘½ä»¤æ‰“å°å †æ ˆï¼Œå¹¶ä¸”å±•ç¤ºç¨‹åºé€ æˆçš„ panicã€‚\n"},{"id":26,"href":"/golang-learn/docs/project/07_make/","title":"make","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" make # é¡¹ç›®ç®¡ç†\n"},{"id":27,"href":"/golang-learn/docs/practice/08_mod/","title":"Go Modules","section":"ğŸ› ï¸ å®è·µ","content":" Go Modules # Golang åœ¨ 1.11 æ¨å‡ºäº† Go Moduleã€‚è¿™æ˜¯å®˜æ–¹æå€¡çš„æ–°çš„åŒ…ç®¡ç†ï¼Œä¹ƒè‡³é¡¹ç›®ç®¡ç†æœºåˆ¶ï¼Œè§£å†³äº† GOPATH çš„é—®é¢˜ï¼Œç›¸å½“äºå¼ƒç”¨äº† GOPATHã€‚\nGo Module æœºåˆ¶ # Go Module ä¸åŒäºåŸºäº GOPATH å’Œ Vendor çš„é¡¹ç›®æ„å»ºï¼Œå…¶ä¸»è¦æ˜¯é€šè¿‡ $GOPATH/pkg/mod ä¸‹ç¼“å­˜çš„æ¨¡å—æ¥å¯¹é¡¹ç›®è¿›è¡Œæ„å»ºã€‚ åŒä¸€ä¸ªæ¨¡å—ç‰ˆæœ¬çš„æ•°æ®åªç¼“å­˜ä¸€ä»½ï¼Œæ‰€æœ‰å…¶ä»–æ¨¡å—å…±äº«ä½¿ç”¨ã€‚\nå¯ä»¥ä½¿ç”¨ go clean -modcache æ¸…ç†æ‰€æœ‰å·²ç¼“å­˜çš„æ¨¡å—ç‰ˆæœ¬æ•°æ®ã€‚\nGO111MODULE # Go Module ç›®å‰æ˜¯å¯é€‰çš„ï¼Œå¯ä»¥é€šè¿‡ç¯å¢ƒå˜é‡ GO111MODULE æ¥æ§åˆ¶æ˜¯å¦å¯ç”¨ï¼ŒGO111MODULE æœ‰ä¸‰ç§ç±»å‹:\non æ‰€æœ‰çš„æ„å»ºï¼Œéƒ½ä½¿ç”¨ Module æœºåˆ¶ off æ‰€æœ‰çš„æ„å»ºï¼Œéƒ½ä¸ä½¿ç”¨ Module æœºåˆ¶ï¼Œè€Œæ˜¯ä½¿ç”¨ GOPATH å’Œ Vendor auto åœ¨ GOPATH ä¸‹çš„é¡¹ç›®ï¼Œä¸ä½¿ç”¨ Module æœºåˆ¶ï¼Œä¸åœ¨ GOPATH ä¸‹çš„é¡¹ç›®ä½¿ç”¨ GOPROXY # GOPROXY ç”¨äºè®¾ç½® Go Module ä»£ç†ã€‚ä½¿ Go åœ¨åç»­æ‹‰å–æ¨¡å—ç‰ˆæœ¬æ—¶èƒ½å¤Ÿè„±ç¦»ä¼ ç»Ÿçš„ VCS æ–¹å¼ä»é•œåƒç«™ç‚¹å¿«é€Ÿæ‹‰å–ã€‚å®ƒçš„å€¼æ˜¯ä¸€ä¸ªä»¥ , åˆ†å‰²çš„ Go module proxy åˆ—è¡¨ã€‚Golang 1.13 ä»¥åå®ƒæœ‰ä¸€ä¸ªé»˜è®¤çš„å€¼ GOPROXY=https://proxy.golang.org,directï¼Œ ä½†æ˜¯ proxy.golang.org åœ¨ä¸­å›½æ˜¯æ— æ³•è®¿é—®çš„ï¼Œå¯ä»¥æ‰§è¡Œ go env -w GOPROXY=https://goproxy.cn,direct æ¥æ›¿æ¢è¿™ä¸ªå€¼ã€‚\noffï¼Œå½“ GOPROXY=off æ—¶ç¦æ­¢ Go åœ¨åç»­æ“ä½œä¸­ä½¿ç”¨ Go module proxyã€‚ directï¼Œå€¼åˆ—è¡¨ä¸­çš„ direct ç”¨äºæŒ‡ç¤º Go å›æºåˆ°æ¨¡å—ç‰ˆæœ¬çš„æºåœ°å€å»æŠ“å–(å¦‚ GitHub)ã€‚å½“å€¼åˆ—è¡¨ä¸­ä¸Šä¸€ä¸ª Go module proxy è¿” å› 404 æˆ– 410 é”™è¯¯æ—¶ï¼ŒGo è‡ªåŠ¨å°è¯•åˆ—è¡¨ä¸­çš„ä¸‹ä¸€ä¸ª proxyï¼Œå½“é‡è§ direct æ—¶å›æºæºåœ°å€ï¼Œé‡è§ EOF æ—¶ç»ˆæ­¢å¹¶æŠ› å‡º â€œinvalid version: unknown revision\u0026hellip;â€ çš„é”™è¯¯ã€‚ go.mod # go.mod æ˜¯ Go moduels é¡¹ç›®æ‰€å¿…é¡»çš„æœ€é‡è¦çš„æ–‡ä»¶ï¼Œæè¿°äº†å½“å‰é¡¹ç›®ï¼ˆä¹Ÿå°±æ˜¯å½“å‰æ¨¡å—ï¼‰çš„å…ƒä¿¡æ¯ï¼Œæ¯ä¸€è¡Œéƒ½ä»¥ä¸€ä¸ªåŠ¨è¯å¼€å¤´ï¼Œç›®å‰æœ‰ 5 ä¸ªåŠ¨è¯:\nmoduleï¼šå®šä¹‰å½“å‰é¡¹ç›®çš„æ¨¡å—è·¯å¾„ã€‚ goï¼šè®¾ç½®é¢„æœŸçš„ Go ç‰ˆæœ¬ã€‚ requireï¼šè®¾ç½®ç‰¹å®šçš„æ¨¡å—ç‰ˆæœ¬ã€‚ excludeï¼šä»ä½¿ç”¨ä¸­æ’é™¤ä¸€ä¸ªç‰¹å®šçš„æ¨¡å—ç‰ˆæœ¬ã€‚ replaceï¼šå°†ä¸€ä¸ªæ¨¡å—ç‰ˆæœ¬æ›¿æ¢ä¸ºå¦å¤–ä¸€ä¸ªæ¨¡å—ç‰ˆæœ¬ã€‚ module example.com/foobar go 1.13 require ( example.com/apple v0.1.2 example.com/banana v1.2.3 example.com/banana/v2 v2.3.4 example.com/pineapple v0.0.0-20190924185754-1b0db40df49a ) exclude example.com/banana v1.2.4 replace example.com/apple v0.1.2 =\u0026gt; example.com/rda v0.1.0 replace example.com/banana =\u0026gt; example.com/hugebanana replace ä½¿ç”¨ # å¦‚æœæ‰¾ä¸åˆ° proxy,é‚£ä¹ˆå¯ä»¥ç”¨ replace.ç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€ go.mod,åŠ å…¥å¦‚ä¸‹å†…å®¹:\n// Fix unable to access \u0026#39;https://go.googlesource.com/xxx/\u0026#39;: The requested URL returned error: 502 replace ( golang.org/x/crypto =\u0026gt; github.com/golang/crypto latest golang.org/x/lint =\u0026gt; github.com/golang/lint latest golang.org/x/net =\u0026gt; github.com/golang/net latest golang.org/x/oauth2 =\u0026gt; github.com/golang/oauth2 latest golang.org/x/sync =\u0026gt; github.com/golang/sync latest golang.org/x/sys =\u0026gt; github.com/golang/sys latest golang.org/x/text =\u0026gt; github.com/golang/text latest golang.org/x/time =\u0026gt; github.com/golang/time latest golang.org/x/tools =\u0026gt; github.com/golang/tools latest ) go mod tidy å‘½ä»¤ä¼šæŠŠ latest è‡ªåŠ¨æ›¿æ¢æˆæœ€æ–°çš„ç‰ˆæœ¬å·ï¼š\nreplace ( golang.org/x/crypto =\u0026gt; github.com/golang/crypto v0.0.0-20191206172530-e9b2fee46413 golang.org/x/lint =\u0026gt; github.com/golang/lint v0.0.0-20191125180803-fdd1cda4f05f golang.org/x/net =\u0026gt; github.com/golang/net v0.0.0-20191207000613-e7e4b65ae663 golang.org/x/oauth2 =\u0026gt; github.com/golang/oauth2 v0.0.0-20191202225959-858c2ad4c8b6 golang.org/x/sync =\u0026gt; github.com/golang/sync v0.0.0-20190911185100-cd5d95a43a6e golang.org/x/sys =\u0026gt; github.com/golang/sys v0.0.0-20191206220618-eeba5f6aabab golang.org/x/text =\u0026gt; github.com/golang/text v0.3.2 golang.org/x/time =\u0026gt; github.com/golang/time v0.0.0-20191024005414-555d28b269f0 golang.org/x/tools =\u0026gt; github.com/golang/tools v0.0.0-20191206204035-259af5ff87bd ) å¦‚æœæ˜¯è€é¡¹ç›®ï¼Œå¯èƒ½ä¼šå‡ºç°ç±»ä¼¼é”™è¯¯ï¼š\ngo: golang.org/x/net@v0.0.0-20190628185345-da137c7871d7: git fetch -f origin refs/heads/*:refs/heads/* refs/tags/*:refs/tags/* in /go/pkg/mod/cache/vcs/4a22365141bc4eea5d5ac4a1395e653f2669485db75ef119e7bbec8e19b12a21: exit status 128: fatal: unable to access \u0026#39;https://go.googlesource.com/net/\u0026#39;: The requested URL returned error: 502 åŸå› å°±æ˜¯æç¤º net åŒ…é™¤äº†æœ€æ–°ç‰ˆä¹‹å¤–,è¿˜éœ€è¦å…¶å®ƒçš„ç‰ˆæœ¬ v0.0.0-20190628185345-da137c7871d7ï¼Œéœ€è¦ä¿®æ”¹ go.mod:\ngolang.org/x/net v0.0.0-20190628185345-da137c7871d7 =\u0026gt; github.com/golang/net v0.0.0-20191207000613-e7e4b65ae663 go.sum # go.sum ç±»ä¼¼äº dep çš„ Gopkg.lockã€‚åˆ—å‡ºäº†å½“å‰é¡¹ç›®ç›´æ¥æˆ–é—´æ¥ä¾èµ–çš„æ‰€æœ‰æ¨¡å—ç‰ˆæœ¬ï¼Œå¹¶å†™æ˜äº†é‚£äº›æ¨¡å—ç‰ˆæœ¬çš„ SHA-256 å“ˆå¸Œå€¼ä»¥å¤‡ Go åœ¨ä»Š åçš„æ“ä½œä¸­ä¿è¯é¡¹ç›®æ‰€ä¾èµ–çš„é‚£äº›æ¨¡å—ç‰ˆæœ¬ä¸ä¼šè¢«ç¯¡æ”¹ã€‚\nk8s.io/client-go v0.0.0-20190620085101-78d2af792bab h1:E8Fecph0qbNsAbijJJQryKu4Oi9QTp5cVpjTE+nqg6g= k8s.io/client-go v0.0.0-20190620085101-78d2af792bab/go.mod h1:E95RaSlHr79aHaX0aGSwcPNfygDiPKOVXdmivCIZT0k= ä¸Šé¢ç¤ºä¾‹ä¸­ä¸€ä¸ªæ¨¡å—è·¯å¾„æœ‰ä¸¤ç§ï¼Œå‰è€…ä¸º Go module æ‰“åŒ…æ•´ä¸ªæ¨¡å—åŒ…æ–‡ä»¶ zip åå†è¿›è¡Œ hash å€¼ï¼Œè€Œåè€…ä¸ºé’ˆå¯¹ go.mod çš„ hash å€¼ã€‚ ä»–ä»¬ä¸¤è€…ï¼Œè¦ä¸å°±æ˜¯åŒæ—¶å­˜åœ¨ï¼Œè¦ä¸å°±æ˜¯åªå­˜åœ¨ go.mod hashã€‚\nå½“ Go è®¤ä¸ºè‚¯å®šç”¨ä¸åˆ°æŸä¸ªæ¨¡å—ç‰ˆæœ¬çš„æ—¶å€™å°±ä¼šçœç•¥å®ƒçš„ zip hashï¼Œå°±ä¼šå‡ºç°ä¸å­˜åœ¨ zip hashï¼Œåªå­˜åœ¨ go.mod hash çš„æƒ…å†µã€‚\nGo Checksum Database # Go Checksum Database ç”¨äºä¿æŠ¤ Go ä»ä»»ä½•æºæ‹‰åˆ° Go æ¨¡å—ç‰ˆæœ¬ä¸ä¼šè¢«ç¯¡æ”¹ã€‚è¯¦ç»†å¯ä»¥æŸ¥çœ‹ go help module-authã€‚\nGOSUMDB # GOSUMDB æ˜¯ä¸€ä¸ª Go checksum database çš„å€¼ã€‚å½“å®ƒç­‰äº off æ—¶è¡¨ç¤ºç¦æ­¢ Go åœ¨åç»­æ“ä½œä¸­æ ¡éªŒæ¨¡å—ç‰ˆæœ¬ã€‚\né»˜è®¤å€¼ sum.golang.org ä¸­å›½æ— æ³•è®¿é—®ï¼Œå¯ä»¥å°† GOPROXY è®¾ç½®ä¸º goproxy.cnã€‚goproxy.cn æ”¯æŒä»£ç† sum.golang.orgã€‚ go mod å‘½ä»¤ # Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just \u0026#39;go mod\u0026#39;. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using \u0026#39;go get\u0026#39;. See \u0026#39;go help modules\u0026#39; for an overview of module functionality. Usage: go mod \u0026lt;command\u0026gt; [arguments] The commands are: download ä¸‹è½½ go.mod æ–‡ä»¶ä¸­æŒ‡æ˜çš„æ‰€æœ‰ä¾èµ–åˆ°æœ¬åœ°ç¼“å­˜ edit ç¼–è¾‘ go.mod æ–‡ä»¶ graph æŸ¥çœ‹ç°æœ‰çš„ä¾èµ–ç»“æ„ init åœ¨å½“å‰ç›®å½•ç”Ÿæˆ go.mod æ–‡ä»¶ tidy æ·»åŠ ä¾èµ–çš„æ¨¡å—ï¼Œå¹¶ç§»é™¤æ— ç”¨çš„æ¨¡å— vendor å¯¼å‡ºç°æœ‰çš„æ‰€æœ‰ä¾èµ– verify æ ¡éªŒä¸€ä¸ªæ¨¡å—æ˜¯å¦è¢«ç¯¡æ”¹è¿‡ why è§£é‡Šä¸ºä»€ä¹ˆéœ€è¦ä¸€ä¸ªæ¨¡å— Use \u0026#34;go help mod \u0026lt;command\u0026gt;\u0026#34; for more information about a command. å…³äºç§æœ‰ module # å¦‚æœé¡¹ç›®ä¾èµ–äº†ç§æœ‰æ¨¡å—ï¼ŒGOPROXY è®¿é—®ä¸åˆ°ï¼Œå¯ä»¥ä½¿ç”¨ GOPRIVATEã€‚\næ¯”å¦‚ GOPRIVATE=*.corp.example.com è¡¨ç¤ºæ‰€æœ‰æ¨¡å—è·¯å¾„ä»¥ corp.example.com çš„ä¸‹ä¸€çº§åŸŸå (å¦‚ team1.corp.example.com) ä¸ºå‰ç¼€çš„ æ¨¡å—ç‰ˆæœ¬éƒ½å°†ä¸ç»è¿‡ Go module proxy å’Œ Go checksum database ï¼ˆæ³¨æ„ä¸åŒ…æ‹¬ corp.example.com æœ¬èº«ï¼‰ã€‚\nGOPRIVATE è¾ƒä¸ºç‰¹æ®Šï¼Œå®ƒçš„å€¼å°†ä½œä¸º GONOPROXY å’Œ GONOSUMDB çš„é»˜è®¤å€¼ã€‚æ‰€ä»¥åªä½¿ç”¨ GOPRIVATE å°±è¶³å¤Ÿã€‚\nè¿ç§»é¡¹ç›®åˆ° Go Module # å‡†å¤‡ç¯å¢ƒ # å¼€å¯ GO11MODULEï¼šgo env -w GO111MODULE=onï¼Œç¡®ä¿é¡¹ç›®ç›®å½•ä¸åœ¨ GOPATH ä¸­ã€‚ é…ç½®ä»£ç† export GOPROXY=https://goproxy.cn,directã€‚ è¿ç§» # # clone é¡¹ç›®, ä¸è¦åœ¨ `GOPATH` ä¸­, ä¹‹å‰çš„é¡¹ç›®çš„ç»“æ„æ˜¯ `GOPATH/src/cdf-mannager` git clone https://github.com/xxx/cdf-mannager # åˆ é™¤ vender cd cdf-mannager rm -rf vender # init go mod init cdf-mannager # ä¸‹è½½ä¾èµ– ä¹Ÿå¯ä»¥ä¸æ‰§è¡Œè¿™ä¸€æ­¥ï¼Œ go run æˆ– go build ä¼šè‡ªåŠ¨ä¸‹è½½ go mod download Go ä¼šæŠŠ Gopkg.lock æˆ–è€… glide.lock ä¸­çš„ä¾èµ–é¡¹å†™å…¥åˆ° go.mod æ–‡ä»¶ä¸­ã€‚go.mod æ–‡ä»¶çš„å†…å®¹åƒä¸‹é¢è¿™æ ·ï¼š\nmodule cdf-manager require ( github.com/fsnotify/fsnotify v1.4.7 github.com/gin-contrib/sse v0.0.0-20170109093832-22d885f9ecc7 github.com/gin-gonic/gin v0.0.0-20180814085852-b869fe1415e4 github.com/golang/protobuf v0.0.0-20170601230230-5a0f697c9ed9 github.com/hashicorp/hcl v1.0.0 github.com/inconshreveable/mousetrap v0.0.0-20141017200713-76626ae9c91c github.com/json-iterator/go v0.0.0-20170829155851-36b14963da70 github.com/lexkong/log v0.0.0-20180607165131-972f9cd951fc github.com/magiconair/properties v1.8.0 github.com/mattn/go-isatty v0.0.0-20170307163044-57fdcb988a5c github.com/mitchellh/mapstructure v1.1.2 github.com/pelletier/go-toml v1.2.0 github.com/satori/go.uuid v0.0.0-20180103152354-f58768cc1a7a github.com/spf13/afero v1.1.2 github.com/spf13/cast v1.3.0 github.com/spf13/cobra v0.0.0-20180427134550-ef82de70bb3f github.com/spf13/jwalterweatherman v1.0.0 github.com/spf13/pflag v1.0.3 github.com/spf13/viper v0.0.0-20181207100336-6d33b5a963d9 github.com/ugorji/go v1.1.2-0.20180831062425-e253f1f20942 github.com/willf/pad v0.0.0-20160331131008-b3d780601022 golang.org/x/sys v0.0.0-20190116161447-11f53e031339 golang.org/x/text v0.3.0 gopkg.in/go-playground/validator.v8 v8.0.0-20160718134125-5f57d2222ad7 gopkg.in/yaml.v2 v2.2.2 ) å¦‚æœæ˜¯ä¸€ä¸ªæ–°é¡¹ç›®ï¼Œæˆ–è€…åˆ é™¤äº† Gopkg.lock æ–‡ä»¶ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œï¼š\ngo mod init cdf-mannager # æ‹‰å–å¿…é¡»æ¨¡å— ç§»é™¤ä¸ç”¨çš„æ¨¡å— go mod tidy æ¥ä¸‹æ¥å°±å¯ä»¥è¿è¡Œ go run main.go äº†ã€‚\nè¿ç§»åˆ° vendor # å¦‚æœä¸æƒ³ä½¿ç”¨ go mod çš„ç¼“å­˜æ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨ go mod vendor å›åˆ°ä½¿ç”¨çš„ vendor ç›®å½•è¿›è¡ŒåŒ…ç®¡ç†çš„æ–¹å¼ã€‚\nè¿™ä¸ªå‘½ä»¤å¹¶åªæ˜¯å•çº¯åœ°æŠŠ go.sum ä¸­çš„æ‰€æœ‰ä¾èµ–ä¸‹è½½åˆ° vendor ç›®å½•é‡Œã€‚\nå†ä½¿ç”¨ go build -mod=vendor æ¥æ„å»ºé¡¹ç›®ï¼Œå› ä¸ºåœ¨ go modules æ¨¡å¼ä¸‹ go build æ˜¯å±è”½ vendor æœºåˆ¶çš„:\nå‘å¸ƒæ—¶éœ€è¦å¸¦ä¸Š vendor ç›®å½•ã€‚\næ·»åŠ æ–°ä¾èµ–åŒ… # æ·»åŠ æ–°ä¾èµ–åŒ…æœ‰ä¸‹é¢å‡ ç§æ–¹å¼ï¼š\nç›´æ¥ä¿®æ”¹ go.mod æ–‡ä»¶ï¼Œç„¶åæ‰§è¡Œ go mod downloadã€‚ ä½¿ç”¨ go get packagename@vx.x.xï¼Œä¼šè‡ªåŠ¨æ›´æ–° go.mod æ–‡ä»¶çš„ã€‚ go runã€go build ä¹Ÿä¼šè‡ªåŠ¨ä¸‹è½½ä¾èµ–ã€‚ go get æ‹‰å–æ–°çš„ä¾èµ–ï¼š\nä¾èµ–åŒ…å†²çªé—®é¢˜ # è¿ç§»åé‡åˆ°äº†ä¸‹é¢çš„æŠ¥é”™ï¼š\n../gowork/pkg/mod/github.com/gin-gonic/gin@v0.0.0-20180814085852-b869fe1415e4/binding/msgpack.go:12:2: unknown import path \u0026#34;github.com/ugorji/go/codec\u0026#34;: ambiguous import: found github.com/ugorji/go/codec in multiple modules: github.com/ugorji/go v0.0.0-20170215201144-c88ee250d022 (/root/gowork/pkg/mod/github.com/ugorji/go@v0.0.0-20170215201144-c88ee250d022/codec) github.com/ugorji/go/codec v0.0.0-20181204163529-d75b2dcb6bc8 (/root/gowork/pkg/mod/github.com/ugorji/go/codec@v0.0.0-20181204163529-d75b2dcb6bc8) é€šè¿‡ go mod graph å¯ä»¥æŸ¥çœ‹å…·ä½“ä¾èµ–è·¯å¾„ï¼š\ngithub.com/spf13/viper@v1.3.2 github.com/ugorji/go/codec@v0.0.0-20181204163529-d75b2dcb6bc8 github.com/gin-gonic/gin@v1.3.1-0.20190120102704-f38a3fe65f10 github.com/ugorji/go@v1.1.1 å¯ä»¥çœ‹åˆ° viper å’Œ gin åˆ†åˆ«ä¾èµ–äº† github.com/ugorji/go å’Œ github.com/ugorji/go/codecã€‚\nåº”è¯¥æ˜¯ go æŠŠè¿™ä¸¤ä¸ª path å½“æˆä¸åŒçš„æ¨¡å—å¼•å…¥å¯¼è‡´çš„å†²çªã€‚workaroundã€‚\nGo get/install ä»£ç†é—®é¢˜ # è®¾ç½®ä»£ç†ä¹‹åï¼Œgo ç¨‹åºä¼šä½¿ç”¨æŒ‡å®šçš„ä»£ç†ï¼š\n# windows set http_proxy=http://[user]:[pass]@[proxy_ip]:[proxy_port]/ set https_proxy=http://[user]:[pass]@[proxy_ip]:[proxy_port]/ # linux export http_proxy=http://[user]:[pass]@[proxy_ip]:[proxy_port]/ export https_proxy=http://[user]:[pass]@[proxy_ip]:[proxy_port]/ æ³¨æ„å¦‚æœä½ è¦æ‹‰å»çš„ä¾èµ–æ˜¯ä½¿ç”¨ Git ä½œä¸ºæºæ§åˆ¶ç®¡ç†å™¨ï¼Œé‚£ä¹ˆ Git çš„ proxy ä¹Ÿéœ€è¦é…ç½®ï¼š\ngit config --global http.proxy http://[user]:[pass]@[proxy_ip]:[proxy_port]/ git config --global https.proxy http://[user]:[pass]@[proxy_ip]:[proxy_port]/ ç®¡ç† Go çš„ç¯å¢ƒå˜é‡ # Golang 1.13 æ–°å¢äº† go env -w ç”¨äºå†™å…¥ç¯å¢ƒå˜é‡ï¼Œå†™å…¥åˆ° $HOME/.config/go/env ï¼ˆos.UserConfigDir è¿”å›çš„è·¯å¾„ï¼‰æ–‡ä»¶ä¸­ã€‚ go env -w ä¸ä¼šè¦†ç›–ç³»ç»Ÿç¯å¢ƒå˜é‡ã€‚ å»ºè®®åˆ é™¤ Go ç›¸å…³çš„ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼Œä½¿ç”¨ go env -w é…ç½®ã€‚ æ§åˆ¶åŒ…çš„ç‰ˆæœ¬ # go get è¿›è¡ŒåŒ…ç®¡ç†æ—¶ï¼š\næ‹‰å–æœ€æ–°çš„ç‰ˆæœ¬(ä¼˜å…ˆæ‹©å– tag)ï¼šgo get golang.org/x/text@latest æ‹‰å– master åˆ†æ”¯çš„æœ€æ–° commitï¼šgo get golang.org/x/text@master æ‹‰å– tag ä¸º v0.3.2 çš„ commitï¼šgo get golang.org/x/text@v0.3.2 æ‹‰å– hash ä¸º 342b231 çš„ commitï¼Œæœ€ç»ˆä¼šè¢«è½¬æ¢ä¸º v0.3.2ï¼šgo get golang.org/x/text@342b2eã€‚å› ä¸º Go modules ä¼šä¸ tag è¿› è¡Œå¯¹æ¯”ï¼Œè‹¥å‘ç°å¯¹åº”çš„ commit ä¸ tag æœ‰å…³è”ï¼Œåˆ™è¿›è¡Œè½¬æ¢ã€‚ ç”¨ go get -u æ›´æ–°ç°æœ‰çš„ä¾èµ–ï¼Œgo get -u all æ›´æ–°æ‰€æœ‰æ¨¡å—ã€‚ ä¸ºä»€ä¹ˆ go get æ‹‰å–çš„æ˜¯ v0.0.0 # ä¸ºä»€ä¹ˆ go get æ‹‰å–çš„æ˜¯ v0.0.0ï¼Œå®ƒä»€ä¹ˆæ—¶å€™ä¼šæ‹‰å–æ­£å¸¸å¸¦ç‰ˆæœ¬å·çš„ tags å‘¢ã€‚å®é™…ä¸Šè¿™éœ€è¦åŒºåˆ†ä¸¤ç§æƒ…å†µï¼Œå¦‚ä¸‹ï¼š\næ‰€æ‹‰å–çš„æ¨¡å—æœ‰å‘å¸ƒ tags å¦‚æœåªæœ‰å•ä¸ªæ¨¡å—ï¼Œé‚£ä¹ˆå°±å–ä¸»ç‰ˆæœ¬å·æœ€å¤§çš„é‚£ä¸ª tagã€‚ å¦‚æœæœ‰å¤šä¸ªæ¨¡å—ï¼Œåˆ™æ¨ç®—ç›¸åº”çš„æ¨¡å—è·¯å¾„ï¼Œå–ä¸»ç‰ˆæœ¬å·æœ€å¤§çš„é‚£ä¸ª tagï¼ˆå­æ¨¡å—çš„ tag çš„æ¨¡å—è·¯å¾„ä¼šæœ‰å‰ç¼€è¦æ±‚ï¼‰ æ‰€æ‹‰å–çš„æ¨¡å—æ²¡æœ‰å‘å¸ƒè¿‡ tags é»˜è®¤å–ä¸»åˆ†æ”¯æœ€æ–°ä¸€æ¬¡ commit çš„ commithashã€‚github.com/ugorji/go/codec@v0.0.0-20181204163529-d75b2dcb6bc8 æ˜¯å› ä¸º github.com/ugorji/go/codec æ²¡æœ‰å‘å¸ƒä»»ä½•çš„ tagã€‚å› æ­¤å®ƒé»˜è®¤å–çš„æ˜¯ä¸»åˆ†æ”¯æœ€æ–°ä¸€æ¬¡ commit çš„ commit æ—¶é—´å’Œ commithashï¼Œ ä¹Ÿå°±æ˜¯ 20181204163529-d75b2dcb6bc8ã€‚ å‘å¸ƒ tags çš„å¤šç§æ¨¡å¼ # ä¾‹å¦‚ä¸€ä¸ªé¡¹ç›®ä¸­ï¼Œä¸€å…±æ‰“äº†ä¸¤ä¸ª tagï¼Œåˆ†åˆ«æ˜¯ï¼šv0.0.1 å’Œ module/codec/v0.0.1ï¼Œmodule/codec/v0.0.1 è¿™ç§ tagï¼Œæœ‰ä»€ä¹ˆç”¨ï¼Ÿ\nå…¶å®æ˜¯ Go modules åœ¨åŒä¸€ä¸ªé¡¹ç›®ä¸‹å¤šä¸ªæ¨¡å—çš„ tag è¡¨ç°æ–¹å¼ï¼Œå…¶ä¸»è¦ç›®å½•ç»“æ„ä¸ºï¼š\ndemomodules â”œâ”€â”€ go.mod â”œâ”€â”€ module â”‚ â””â”€â”€ codec â”‚ â”œâ”€â”€ go.mod â”‚ â””â”€â”€ codec.go â””â”€â”€ demomodules.go demomodules è¿™ä¸ªé¡¹ç›®çš„æ ¹ç›®å½•æœ‰ä¸€ä¸ª go.mod æ–‡ä»¶ï¼Œè€Œåœ¨ module/codec ç›®å½•ä¸‹ä¹Ÿæœ‰ä¸€ä¸ª go.mod æ–‡ä»¶ï¼Œå…¶æ¨¡å—å¯¼å…¥å’Œç‰ˆæœ¬ä¿¡æ¯çš„å¯¹åº”å…³ç³»å¦‚ä¸‹ï¼š\ntag æ¨¡å—å¯¼å…¥è·¯å¾„ å«ä¹‰ v0.0.1 github.com/pooky/demomodules demomodules é¡¹ç›®çš„ v 0.0.1 ç‰ˆæœ¬ module/codec/v0.01 github.com/pooky/demomodules/module/codec demomodules é¡¹ç›®ä¸‹çš„å­æ¨¡å— module/codec çš„ v0.0.1 ç‰ˆæœ¬ æ‹‰å–å­æ¨¡å—ï¼Œæ‰§è¡Œå¦‚ä¸‹å‘½ä»¤ï¼š\n$ go get github.com/pooky/demomodules/module/codec@v0.0.1 å‘å¸ƒ module # è¯­ä¹‰åŒ–ç‰ˆæœ¬ # Golang å®˜æ–¹æ¨èçš„æœ€ä½³å®è·µå«åš semverï¼ˆSemantic Versioningï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯­ä¹‰åŒ–ç‰ˆæœ¬ã€‚\nå°±æ˜¯ä¸€ç§æ¸…æ™°å¯è¯»çš„ï¼Œæ˜ç¡®ååº”ç‰ˆæœ¬ä¿¡æ¯çš„ç‰ˆæœ¬æ ¼å¼ã€‚\nç‰ˆæœ¬æ ¼å¼ï¼šä¸»ç‰ˆæœ¬å·.æ¬¡ç‰ˆæœ¬å·.ä¿®è®¢å· ä¸»ç‰ˆæœ¬å·ï¼šåšäº†ä¸å…¼å®¹çš„ API ä¿®æ”¹ æ¬¡ç‰ˆæœ¬å·ï¼šå‘ä¸‹å…¼å®¹çš„æ–°å¢åŠŸèƒ½ ä¿®è®¢å·ï¼š å‘ä¸‹å…¼å®¹çš„é—®é¢˜ä¿®æ­£ã€‚ å½¢å¦‚ vX.Y.Zã€‚\nè¯­ä¹‰åŒ–ç‰ˆæœ¬çš„é—®é¢˜ # å¦‚æœä½ ä½¿ç”¨å’Œå‘å¸ƒçš„åŒ…æ²¡æœ‰ç‰ˆæœ¬ tag æˆ–è€…å¤„äº 1.x ç‰ˆæœ¬ï¼Œé‚£ä¹ˆå¯èƒ½ä½“ä¼šä¸åˆ°ä»€ä¹ˆåŒºåˆ«ï¼Œä¸»è¦çš„åŒºåˆ«ä½“ç°åœ¨ v2.x ä»¥åŠæ›´é«˜ç‰ˆæœ¬çš„åŒ…ä¸Šã€‚\ngo module çš„è°¦å®¹æ€§è§„åˆ™ï¼šå¦‚æœæ—§è½¯ä»¶åŒ…å’Œæ–°è½¯ä»¶åŒ…å…·æœ‰ç›¸åŒçš„å¯¼å…¥è·¯å¾„ï¼Œåˆ™æ–°è½¯ä»¶åŒ…å¿…é¡»å‘åå…¼å®¹æ—§è½¯ä»¶åŒ… ä¹Ÿå°±æ˜¯è¯´å¦‚æœå¯¼å…¥è·¯å¾„ä¸åŒï¼Œå°±æ— éœ€ä¿æŒå…¼å®¹ã€‚\nå®é™…ä¸Š Go modules åœ¨ä¸»ç‰ˆæœ¬å·ä¸º v0 å’Œ v1 çš„æƒ…å†µä¸‹çœç•¥äº†ç‰ˆæœ¬å·ï¼Œè€Œåœ¨ä¸»ç‰ˆæœ¬å·ä¸º v2 åŠä»¥ä¸Šåˆ™éœ€è¦æ˜ç¡®æŒ‡å®šå‡ºä¸»ç‰ˆæœ¬å·ï¼Œå¦åˆ™ä¼šå‡ºç°å†²çªï¼Œå…¶ tag ä¸æ¨¡å—å¯¼å…¥è·¯å¾„çš„å¤§è‡´å¯¹åº”å…³ç³»å¦‚ä¸‹ï¼š\ntag æ¨¡å—å¯¼å…¥è·¯å¾„ v0.0.0 github.com/pooky/demomodules v1.0.0 github.com/pooky/demomodules v2.0.0 github.com/pooky/demomodules/v2 v2.x è¡¨ç¤ºå‘ç”Ÿäº†é‡å¤§å˜åŒ–ï¼Œæ— æ³•ä¿è¯å‘åå…¼å®¹ï¼Œè¿™æ—¶å°±éœ€è¦åœ¨åŒ…çš„å¯¼å…¥è·¯å¾„çš„æœ«å°¾é™„åŠ ç‰ˆæœ¬ä¿¡æ¯ï¼š\nmodule my-module/v2 require ( some/pkg/v2 v2.0.0 some/pkg/v2/mod1 v2.0.0 my/pkg/v3 v3.0.1 ) æ ¼å¼æ€»ç»“ä¸º pkgpath/vNï¼Œå…¶ä¸­ N æ˜¯å¤§äº 1 çš„ä¸»è¦ç‰ˆæœ¬å·ã€‚ä»£ç é‡Œå¯¼å…¥æ—¶ä¹Ÿéœ€è¦é™„å¸¦ä¸Šè¿™ä¸ªç‰ˆæœ¬ä¿¡æ¯ï¼Œå¦‚ import \u0026quot;some/my-module/v2\u0026quot;ã€‚\nä¸ºä»€ä¹ˆå¿½ç•¥ v0 å’Œ v1 çš„ä¸»ç‰ˆæœ¬å· # å¿½ç•¥ v1 ç‰ˆæœ¬çš„åŸå› ï¼šè€ƒè™‘åˆ°è®¸å¤šå¼€å‘äººå‘˜åˆ›å»ºä¸€æ—¦åˆ°è¾¾ v1 ç‰ˆæœ¬ä¾¿æ°¸ä¸æ”¹å˜çš„è½¯ä»¶åŒ…ï¼Œè¿™æ˜¯å®˜æ–¹æ‰€é¼“åŠ±çš„ å¿½ç•¥äº† v0 ç‰ˆæœ¬çš„åŸå› ï¼šæ ¹æ®è¯­ä¹‰åŒ–ç‰ˆæœ¬è§„èŒƒï¼Œv0 çš„è¿™äº›ç‰ˆæœ¬å®Œå…¨æ²¡æœ‰å…¼å®¹æ€§ä¿è¯ã€‚éœ€è¦ä¸€ä¸ªæ˜¾å¼çš„ v0 ç‰ˆæœ¬çš„æ ‡è¯†å¯¹ç¡®ä¿å…¼å®¹æ€§æ²¡æœ‰å¤šå¤§å¸®åŠ©ã€‚\ngo.sum # npm çš„ package-lock.json ä¼šè®°å½•æ‰€æœ‰åº“çš„å‡†ç¡®ç‰ˆæœ¬ï¼Œæ¥æºä»¥åŠæ ¡éªŒå’Œï¼Œå‘å¸ƒæ—¶ä¸éœ€è¦å¸¦ä¸Šå®ƒï¼Œå› ä¸ºå†…å®¹è¿‡äºè¯¦ç»†ä¼šå¯¹ç‰ˆæœ¬æ§åˆ¶ä»¥åŠå˜æ›´è®°å½• ç­‰å¸¦æ¥è´Ÿé¢å½±å“ã€‚\ngo.sum ä¹Ÿæœ‰ç±»ä¼¼çš„ä½œç”¨ï¼Œä¼šè®°å½•å½“å‰ module æ‰€æœ‰çš„é¡¶å±‚å’Œé—´æ¥ä¾èµ–ï¼Œä»¥åŠè¿™äº›ä¾èµ–çš„æ ¡éªŒå’Œï¼Œä»è€Œæä¾›ä¸€ä¸ªå¯ä»¥ 100% å¤ç°çš„æ„å»ºè¿‡ç¨‹å¹¶å¯¹æ„å»ºå¯¹ è±¡æä¾›å®‰å…¨æ€§çš„ä¿è¯ã€‚åŒæ—¶è¿˜ä¼šä¿ç•™è¿‡å»ä½¿ç”¨çš„åŒ…çš„ç‰ˆæœ¬ä¿¡æ¯ï¼Œä»¥ä¾¿æ—¥åå¯èƒ½çš„ç‰ˆæœ¬å›é€€ï¼Œè¿™ä¸€ç‚¹ä¹Ÿä¸æ™®é€šçš„é”æ–‡ä»¶ä¸åŒã€‚\nå‡†ç¡®åœ°è¯´ï¼Œgo.sum æ˜¯ä¸€ä¸ªæ„å»ºçŠ¶æ€è·Ÿè¸ªæ–‡ä»¶ã€‚\næ‰€ä»¥åº”è¯¥æŠŠ go.sum å’Œ go.mod ä¸€åŒæ·»åŠ è¿›ç‰ˆæœ¬æ§åˆ¶å·¥å…·çš„è·Ÿè¸ªåˆ—è¡¨ï¼ŒåŒæ—¶éœ€è¦éšç€ä½ çš„æ¨¡å—ä¸€èµ·å‘å¸ƒã€‚\nTodo # go get å’Œ go install çš„åŒºåˆ«\n"},{"id":28,"href":"/golang-learn/docs/concurrency/08_atomic/","title":"åŸå­æ“ä½œ","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" åŸå­æ“ä½œ # åŸå­æ“ä½œå°±æ˜¯æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸èƒ½è¢«ä¸­æ–­çš„æ“ä½œã€‚\nGo çš„æ ‡å‡†åº“ sync/atomic æä¾›äº†ä¸€äº›å®ç°åŸå­æ“ä½œçš„æ–¹æ³•ï¼š\nAdd CompareAndSwapï¼ˆç®€ç§° CASï¼‰ Load Swap Store è¿™äº›å‡½æ•°é’ˆå¯¹çš„æ•°æ®ç±»å‹æœ‰ï¼š\nint32 int64 uint32 uint64 uintptr unsafe åŒ…ä¸­çš„ Pointer ä»¥ Add ä¸ºä¾‹ï¼Œä¸Šé¢ç±»å‹å¯¹åº”çš„åŸå­æ“ä½œå‡½æ•°ä¸ºï¼š\nfunc AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) unsafe.Pointer ç±»å‹ï¼Œå¹¶æœªæä¾›è¿›è¡ŒåŸå­åŠ æ³•æ“ä½œçš„å‡½æ•°ã€‚\nsync/atomic åŒ…è¿˜æä¾›äº†ä¸€ä¸ªåä¸º Value çš„ç±»å‹ï¼Œå®ƒå¯ä»¥è¢«ç”¨æ¥å­˜å‚¨ï¼ˆStoreï¼‰å’ŒåŠ è½½ï¼ˆLoadï¼‰ä»»æ„ç±»å‹çš„å€¼ã€‚\nå®ƒåªæœ‰ä¸¤ä¸ªæŒ‡é’ˆæ–¹æ³•ï¼š\nStore Loadã€‚ å°½é‡ä¸è¦å‘åŸå­å€¼ä¸­å­˜å‚¨å¼•ç”¨ç±»å‹çš„å€¼ã€‚\nvar box6 atomic.Value v6 := []int{1, 2, 3} box6.Store(v6) v6[1] = 4 // æ­¤å¤„çš„æ“ä½œä¸æ˜¯å¹¶å‘å®‰å…¨çš„ ä¸Šé¢çš„ä»£ç  v6[1] = 4 ç»•è¿‡äº†åŸå­å€¼è€Œè¿›è¡Œäº†éå¹¶å‘å®‰å…¨çš„æ“ä½œã€‚å¯ä»¥æ”¹ä¸ºï¼š\nstore := func(v []int) { replica := make([]int, len(v)) copy(replica, v) box6.Store(replica) } store(v6) v6[2] = 5 ä½¿ç”¨ # äº’æ–¥é”ä¸åŸå­æ“ä½œ # åŒºåˆ«ï¼š\näº’æ–¥é”æ˜¯ç”¨æ¥ä¿æŠ¤ä¸´ç•ŒåŒºï¼ŒåŸå­æ“ä½œç”¨äºå¯¹ä¸€ä¸ªå˜é‡çš„æ›´æ–°ä¿æŠ¤ã€‚ äº’æ–¥é”ç”±æ“ä½œç³»ç»Ÿçš„è°ƒåº¦å™¨å®ç°ï¼ŒåŸå­æ“ä½œç”±åº•å±‚ç¡¬ä»¶æŒ‡ä»¤ç›´æ¥æä¾›æ”¯æŒ å¯¹äºä¸€ä¸ªå˜é‡æ›´æ–°çš„ä¿æŠ¤ï¼ŒåŸå­æ“ä½œé€šå¸¸ä¼šæ›´æœ‰æ•ˆç‡ï¼Œå¹¶ä¸”æ›´èƒ½åˆ©ç”¨è®¡ç®—æœºå¤šæ ¸çš„ä¼˜åŠ¿ã€‚è€Œäº’æ–¥é”ä¿æŠ¤çš„å…±äº«èµ„æºæ¯æ¬¡åªç»™ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œå…¶å®ƒçº¿ç¨‹é˜»å¡ï¼Œç”¨å®Œåå†æŠŠèµ„æºè½¬è®©ç»™å…¶å®ƒçº¿ç¨‹ã€‚\nä½¿ç”¨äº’æ–¥é”å®ç°å¹¶å‘è®¡æ•°ï¼š\nfunc MutexAdd() { var a int32 = 0 var wg sync.WaitGroup var mu sync.Mutex start := time.Now() for i := 0; i \u0026lt; 10000; i++ { wg.Add(1) go func() { defer wg.Done() mu.Lock() a += 1 mu.Unlock() }() } wg.Wait() timeSpends := time.Now().Sub(start).Nanoseconds() fmt.Printf(\u0026#34;mutex value %d, spend time: %v\\n\u0026#34;, a, timeSpends) } ä½¿ç”¨åŸå­æ“ä½œæ›¿æ¢äº’æ–¥é”ï¼š\nfunc AtomicAdd() { var a int32 = 0 var wg sync.WaitGroup start := time.Now() for i := 0; i \u0026lt; 10000; i++ { wg.Add(1) go func() { defer wg.Done() atomic.AddInt32(\u0026amp;a, 1) }() } wg.Wait() timeSpends := time.Now().Sub(start).Nanoseconds() fmt.Printf(\u0026#34;atomic value %d, spend time: %v\\n\u0026#34;, atomic.LoadInt32(\u0026amp;a), timeSpends) } è¿è¡Œåå¾—åˆ°çš„ç»“æœï¼š\nmutex value 10000, spend time: 5160800 atomic value 10000, spend time: 2577300 åŸå­æ“ä½œèŠ‚çœäº†å¤§æ¦‚ä¸€åŠçš„æ—¶é—´ã€‚\nåˆ©ç”¨ CAS å®ç°è‡ªæ—‹é” # func addValue(v int32) { for { // åœ¨è¿›è¡Œè¯»å– value çš„æ“ä½œçš„è¿‡ç¨‹ä¸­,å…¶ä»–å¯¹æ­¤å€¼çš„è¯»å†™æ“ä½œæ˜¯å¯ä»¥è¢«åŒæ—¶è¿›è¡Œçš„,é‚£ä¹ˆè¿™ä¸ªè¯»æ“ä½œå¾ˆå¯èƒ½ä¼šè¯»å–åˆ°ä¸€ä¸ªåªè¢«ä¿®æ”¹äº†ä¸€åŠçš„æ•°æ®. // å› æ­¤è¦ä½¿ç”¨åŸå­è¯»å– old := atomic.LoadInt32(\u0026amp;value) if atomic.CompareAndSwapInt32(\u0026amp;value, old, old + v) { break } } } åœ¨é«˜å¹¶å‘çš„æƒ…å†µä¸‹ï¼Œå•æ¬¡ CAS çš„æ‰§è¡ŒæˆåŠŸç‡ä¼šé™ä½ï¼Œå› æ­¤éœ€è¦é…åˆå¾ªç¯è¯­å¥ forï¼Œå½¢æˆä¸€ä¸ª for+atomic çš„ç±»ä¼¼è‡ªæ—‹ä¹è§‚é”ã€‚\nABA é—®é¢˜ # ä½¿ç”¨ CASï¼Œä¼šæœ‰ ABA é—®é¢˜ï¼ŒABA é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ\nä¾‹å¦‚ï¼Œä¸€ä¸ª goroutine a ä»å†…å­˜ä½ç½® V ä¸­å–å‡º 1ï¼Œè¿™æ—¶å€™å¦ä¸€ä¸ª goroutine b ä¹Ÿä»å†…å­˜ä½ç½® V ä¸­å–å‡º 1ï¼Œå¹¶ä¸” goroutine b å°† V ä½ç½®çš„å€¼æ›´æ–°ä¸º 0ï¼Œæ¥ç€åˆå°† V ä½ç½®çš„å€¼æ”¹ä¸º 1ï¼Œè¿™æ—¶å€™ goroutine a è¿›è¡Œ CAS æ“ä½œå‘ç°ä½ç½® V çš„å€¼ä»ç„¶æ˜¯ 1ï¼Œç„¶å goroutine a æ“ä½œæˆåŠŸã€‚è™½ç„¶ goroutine a çš„ CAS æ“ ä½œæˆåŠŸï¼Œä½†æ˜¯è¿™ä¸ªå€¼å…¶å®å·²ç»è¢«ä¿®æ”¹è¿‡ã€‚\nå¯ä»¥ç»™å˜é‡é™„åŠ æ—¶é—´æˆ³ã€ç‰ˆæœ¬å·ç­‰ä¿¡æ¯æ¥è§£å†³ã€‚\n"},{"id":29,"href":"/golang-learn/docs/project/08_github_actions/","title":"åŸºäº GitHub Actions çš„ CI/CD","section":"ğŸ› ï¸ Go å·¥ç¨‹å®è·µ","content":" åŸºäº GitHub Actions çš„ CI/CD # é™æ€ä»£ç æ£€æŸ¥ # GitHub Actions æ˜¯ GitHub ä¸ºæ‰˜ç®¡åœ¨ github.com ç«™ç‚¹çš„é¡¹ç›®æä¾›çš„æŒç»­é›†æˆæœåŠ¡ã€‚\nåœ¨æ„å»ºæŒç»­é›†æˆä»»åŠ¡æ—¶ï¼Œæˆ‘ä»¬ä¼šåœ¨ä»»åŠ¡ä¸­å¿ƒå®Œæˆå„ç§æ“ä½œï¼Œæ¯”å¦‚å…‹éš†ä»£ç ã€ç¼–è¯‘ä»£ç ã€è¿è¡Œå•å…ƒæµ‹è¯•ã€æ„å»ºå’Œå‘å¸ƒé•œåƒç­‰ã€‚GitHub æŠŠè¿™äº›æ“ä½œç§°ä¸º Actionsã€‚\nActions æ˜¯å¯ä»¥å…±äº«çš„ï¼Œå¼€å‘è€…å¯ä»¥å°† Actions ä¸Šä¼ åˆ° GitHub çš„ Actions å¸‚åœºã€‚ ä¸€ä¸ª awesome actions ä»“åº“ï¼Œé‡Œé¢ä¹Ÿæœ‰ä¸å°‘çš„ Actionã€‚å¦‚æœéœ€è¦æŸä¸ª Actionï¼Œç›´æ¥å¼•ç”¨ä»–äººå†™å¥½çš„ Action å³å¯ã€‚ æ•´ä¸ªæŒç»­é›†æˆè¿‡ç¨‹ï¼Œå°±å˜æˆäº†ä¸€ä¸ª Actions çš„ç»„åˆã€‚\nAction å…¶å®æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„è„šæœ¬ï¼Œå¯ä»¥å°† Action å­˜æ”¾åœ¨ GitHub ä»£ç ä»“åº“ä¸­ï¼Œé€šè¿‡ \u0026lt;userName\u0026gt;/\u0026lt;repoName\u0026gt; çš„è¯­æ³•å¼•ç”¨ Actionã€‚ä¾‹å¦‚ï¼Œ actions/checkout@v2 è¡¨ç¤º https://github.com/actions/checkout è¿™ä¸ªä»“åº“ï¼Œtag æ˜¯ v2ã€‚\nGitHub Actions æœ¯è¯­ï¼š\nworkflowï¼šä¸€ä¸ª .yml æ–‡ä»¶å¯¹åº”ä¸€ä¸ª workflowï¼Œä¹Ÿå°±æ˜¯ä¸€æ¬¡æŒç»­é›†æˆã€‚ä¸€ä¸ª GitHub ä»“åº“å¯ä»¥åŒ…å«å¤šä¸ª workflowï¼Œåªè¦æ˜¯åœ¨ .github/workflow ç›®å½•ä¸‹çš„ .yml æ–‡ä»¶éƒ½ä¼šè¢« GitHub æ‰§è¡Œã€‚ jobï¼šä¸€ä¸ª workflow ç”±ä¸€ä¸ªæˆ–å¤šä¸ª job æ„æˆï¼Œæ¯ä¸ª job ä»£è¡¨ä¸€ä¸ªæŒç»­é›†æˆä»»åŠ¡ã€‚ stepï¼šæ¯ä¸ª job ç”±å¤šä¸ª step æ„æˆï¼Œä¸€æ­¥æ­¥å®Œæˆã€‚ actionï¼šæ¯ä¸ª step å¯ä»¥ä¾æ¬¡æ‰§è¡Œä¸€ä¸ªæˆ–å¤šä¸ªå‘½ä»¤ï¼ˆactionï¼‰ã€‚ onï¼šä¸€ä¸ª workflow çš„è§¦å‘æ¡ä»¶ï¼Œå†³å®šäº†å½“å‰çš„ workflow åœ¨ä»€ä¹ˆæ—¶å€™è¢«æ‰§è¡Œã€‚ workflow æ–‡ä»¶ # GitHub Actions é…ç½®æ–‡ä»¶å­˜æ”¾åœ¨ä»£ç ä»“åº“çš„ .github/workflows ç›®å½•ä¸‹ï¼Œæ–‡ä»¶åç¼€ä¸º .ymlã€.yamlã€‚GitHub åªè¦å‘ç° .github/workflows ç›®å½•é‡Œ é¢æœ‰ .yml æ–‡ä»¶ï¼Œå°±ä¼šè‡ªåŠ¨è¿è¡Œè¯¥æ–‡ä»¶ã€‚\nworkflow æ–‡ä»¶çš„é…ç½®å®˜æ–¹æ–‡æ¡£ã€‚\nname æ˜¯ workflow çš„åç§°ã€‚å¦‚æœçœç•¥è¯¥å­—æ®µï¼Œé»˜è®¤ä¸ºå½“å‰ workflow çš„æ–‡ä»¶åã€‚ on æŒ‡å®šè§¦å‘ workflow çš„æ¡ä»¶ã€‚ on: pushï¼Œæ„æ€æ˜¯ï¼Œpush äº‹ä»¶è§¦å‘ workflowã€‚ä¹Ÿå¯ä»¥æ˜¯äº‹ä»¶çš„æ•°ç»„ï¼Œä¾‹å¦‚: on: [push, pull_request]ã€‚æ‰€æœ‰çš„äº‹ä»¶ã€‚ on.\u0026lt;push|pull_request\u0026gt;.\u0026lt;tags|branches\u0026gt;ï¼ŒæŒ‡å®šè§¦å‘äº‹ä»¶æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é™å®šåˆ†æ”¯æˆ–æ ‡ç­¾ã€‚ # åªæœ‰ master åˆ†æ”¯å‘ç”Ÿ push äº‹ä»¶æ—¶ï¼Œæ‰ä¼šè§¦å‘ workflowã€‚ on: push: branches: - master jobs.\u0026lt;job_id\u0026gt;.name è¡¨ç¤ºè¦æ‰§è¡Œçš„ä¸€é¡¹æˆ–å¤šé¡¹ä»»åŠ¡ã€‚jobs å­—æ®µé‡Œé¢ï¼Œéœ€è¦å†™å‡ºæ¯ä¸€é¡¹ä»»åŠ¡çš„ job_idï¼Œå…·ä½“åç§°è‡ªå®šä¹‰ã€‚job_id é‡Œé¢çš„ name å­—æ®µæ˜¯ä»»åŠ¡çš„è¯´æ˜ã€‚ # jobs å­—æ®µåŒ…å«ä¸¤é¡¹ä»»åŠ¡ï¼Œjob_id åˆ†åˆ«æ˜¯ my_first_job å’Œ my_second_jobã€‚ jobs: my_first_job: name: My first job my_second_job: name: My second job jobs.\u0026lt;job_id\u0026gt;.needs needs å­—æ®µæŒ‡å®šå½“å‰ä»»åŠ¡çš„ä¾èµ–å…³ç³»ï¼Œå³è¿è¡Œé¡ºåºã€‚ # job1 å¿…é¡»å…ˆäº job2 å®Œæˆï¼Œè€Œ job3 ç­‰å¾… job1 å’Œ job2 å®Œæˆåæ‰èƒ½è¿è¡Œã€‚ jobs: my_first_job: name: My first job my_second_job: name: My second job jobs.\u0026lt;job_id\u0026gt;.runs-on runs-on å­—æ®µæŒ‡å®šè¿è¡Œæ‰€éœ€è¦çš„è™šæ‹Ÿæœºç¯å¢ƒï¼Œå®ƒæ˜¯å¿…å¡«å­—æ®µã€‚å¯ç”¨çš„è™šæ‹Ÿï¼š ubuntu-latestã€ubuntu-18.04 æˆ– ubuntu-16.04ã€‚ windows-latestã€windows-2019 æˆ– windows-2016ã€‚ macOS-latest æˆ– macOS-10.14ã€‚ jobs.\u0026lt;job_id\u0026gt;.steps æŒ‡å®šæ¯ä¸ª Job çš„è¿è¡Œæ­¥éª¤ï¼Œå¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªæ­¥éª¤ã€‚æ¯ä¸ªæ­¥éª¤éƒ½å¯ä»¥æŒ‡å®šä¸‹é¢ä¸‰ä¸ªå­—æ®µã€‚ jobs.\u0026lt;job_id\u0026gt;.steps.nameï¼šæ­¥éª¤åç§°ã€‚ jobs.\u0026lt;job_id\u0026gt;.steps.runï¼šè¯¥æ­¥éª¤è¿è¡Œçš„å‘½ä»¤æˆ–è€… actionã€‚ jobs.\u0026lt;job_id\u0026gt;.steps.envï¼šè¯¥æ­¥éª¤æ‰€éœ€çš„ç¯å¢ƒå˜é‡ã€‚ name: Hello on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: GITHUB_TOKEN: {{ secrets.PAT }} run: | echo hello uses å¯ä»¥å¼•ç”¨åˆ«äººå·²ç»åˆ›å»ºçš„ actionsã€‚å¼•ç”¨æ ¼å¼ä¸º username/repo@verisonï¼Œä¾‹å¦‚ uses: actions/setup-go@v3ã€‚ with actions çš„å‚æ•°ã€‚æ¯ä¸ªå‚æ•°éƒ½æ˜¯ä¸€ä¸ªé”®/å€¼å¯¹ã€‚å‚æ•°è¢«è®¾ç½®ä¸ºç¯å¢ƒå˜é‡ï¼Œè¯¥å˜é‡çš„å‰ç¼€ä¸º INPUT_ï¼Œå¹¶è½¬æ¢ä¸ºå¤§å†™ã€‚ jobs: my_first_job: steps: - name: Create a Release uses: goreleaser/goreleaser-action@v2 with: # è¿™äº›å‚æ•°å°†è¢« goreleaser-action ä½œä¸º INPUT_VERSIONã€INPUT_ARGS ç¯å¢ƒå˜é‡ä½¿ç”¨ã€‚ version: latest args: release --rm-dist run æ‰§è¡Œçš„å‘½ä»¤ã€‚å¯ä»¥æœ‰å¤šä¸ªå‘½ä»¤ï¼Œä¾‹å¦‚ï¼š - name: Build run: | go mod tidy go build -v -o crtctl . id step çš„å”¯ä¸€æ ‡è¯†ã€‚ ä½¿ç”¨æ„å»ºçŸ©é˜µ # å¦‚æœæƒ³åœ¨å¤šä¸ªç³»ç»Ÿæˆ–è€…å¤šä¸ªè¯­è¨€ç‰ˆæœ¬ä¸Šæµ‹è¯•æ„å»ºï¼Œå°±éœ€è¦è®¾ç½®æ„å»ºçŸ©é˜µã€‚ä¾‹å¦‚ï¼Œåœ¨å¤šä¸ªæ“ä½œç³»ç»Ÿã€å¤šä¸ª Go ç‰ˆæœ¬ä¸‹è·‘æµ‹è¯•ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹ workflow é…ç½®ï¼š\nname: Go Test on: [push, pull_request] jobs: build: name: Test with go ${{ matrix.go_version }} on ${{ matrix.os }} runs-on: ${{ matrix.os }} strategy: matrix: go_version: [1.15, 1.16] os: [ubuntu-latest, macOS-latest] steps: - name: Set up Go ${{ matrix.go_version }} uses: actions/setup-go@v2 with: go-version: ${{ matrix.go_version }} id: go strategy.matrix é…ç½®äº†è¯¥å·¥ä½œæµç¨‹è¿è¡Œçš„ç¯å¢ƒçŸ©é˜µï¼Œä¼šåœ¨ 4 å°ä¸åŒé…ç½®çš„æœåŠ¡å™¨ä¸Šæ‰§è¡Œè¯¥ workflowï¼šubuntu-latest.1.15ã€ubuntu-latest.1.16ã€ macOS-latest.1.15ã€macOS-latest.1.16ã€‚\nä½¿ç”¨ Secrets # åœ¨æ„å»ºè¿‡ç¨‹ä¸­ï¼Œå¦‚æœæœ‰ç”¨åˆ° token ç­‰æ•æ„Ÿæ•°æ®ï¼Œæ­¤æ—¶å°±å¯ä»¥ä½¿ç”¨ secretsã€‚æˆ‘ä»¬åœ¨å¯¹åº”é¡¹ç›®ä¸­é€‰æ‹© Settings-\u0026gt; Secretsï¼Œå°±å¯ä»¥åˆ›å»º secretã€‚\né…ç½®æ–‡ä»¶ä¸­çš„ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š\nname: Go Test on: [push, pull_request] jobs: helloci-build: name: Test with go runs-on: [ubuntu-latest] environment: name: helloci steps: - name: use secrets env: super_secret: ${{ secrets.MySecrets }} secret name ä¸åŒºåˆ†å¤§å°å†™ï¼Œæ‰€ä»¥å¦‚æœæ–°å»º secret çš„åå­—æ˜¯ nameï¼Œä½¿ç”¨æ—¶ç”¨ secrets.name æˆ–è€… secrets.Name éƒ½æ˜¯å¯ä»¥çš„ã€‚\nä½¿ç”¨ Artifact # åœ¨æ„å»ºè¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šè¾“å‡ºä¸€äº›æ„å»ºäº§ç‰©ï¼Œæ¯”å¦‚æ—¥å¿—æ–‡ä»¶ã€æµ‹è¯•ç»“æœç­‰ã€‚å¯ä»¥ä½¿ç”¨ Github Actions Artifact æ¥å­˜å‚¨ã€‚ä½¿ç”¨ action/upload-artifact å’Œ download-artifact è¿›è¡Œæ„å»ºå‚æ•°çš„ç›¸å…³æ“ä½œã€‚\nsteps: - run: npm ci - run: npm test - name: Upload Test Coverage File uses: actions/upload-artifact@v1.0.0 with: name: coverage-output path: coverage æ‰§è¡ŒæˆåŠŸåï¼Œæˆ‘ä»¬å°±èƒ½åœ¨å¯¹åº” action é¢æ¿çœ‹åˆ°ç”Ÿæˆçš„ Artifactã€‚\nä½¿ç”¨ç¼“å­˜ # ä¸ºäº†ä½¿ workflow æ›´å¿«ã€æ›´é«˜æ•ˆï¼Œå¯ä»¥ä¸ºä¾èµ–é¡¹åŠå…¶ä»–ç»å¸¸é‡å¤ä½¿ç”¨çš„æ–‡ä»¶åˆ›å»ºå’Œä½¿ç”¨ç¼“å­˜ã€‚ä¾‹å¦‚ï¼šnpmï¼Œgo modã€‚è¦ç¼“å­˜ job çš„ä¾èµ–é¡¹å¯ä»¥ä½¿ç”¨ cache ã€‚\ncache ä¼šæ ¹æ® key å°è¯•è¿˜åŸç¼“å­˜ã€‚å½“æ‰¾åˆ°ç¼“å­˜æ—¶ï¼Œä¼šå°†ç¼“å­˜çš„æ–‡ä»¶è¿˜åŸåˆ°ä½ é…ç½®çš„ pathã€‚\nå¦‚æœæ‰¾åˆ°ç¼“å­˜ï¼Œcache ä¼šåœ¨ job æˆåŠŸå®Œæˆæ—¶ä¼šä½¿ç”¨ä½ æä¾›çš„ key è‡ªåŠ¨åˆ›å»ºä¸€ä¸ªæ–°ç¼“å­˜ã€‚å¹¶åŒ…å« path æŒ‡å®šçš„æ–‡ä»¶ã€‚\nå¯ä»¥é€‰æ‹©æä¾›åœ¨ key ä¸ç°æœ‰ç¼“å­˜ä¸åŒ¹é…æ—¶è¦ä½¿ç”¨çš„ restore-keys åˆ—è¡¨ã€‚ ä»å¦ä¸€ä¸ªåˆ†æ”¯è¿˜åŸç¼“å­˜æ—¶ï¼Œrestore-keys åˆ—è¡¨éå¸¸æœ‰ç”¨ï¼Œå› ä¸º restore-keys å¯ä»¥éƒ¨åˆ†åŒ¹é…ç¼“å­˜ keyã€‚\n# Look for a CLI that\u0026#39;s made for this PR - name: Fetch built CLI id: cli-cache uses: actions/cache@v2 with: path: ./_output/linux/amd64/bin/crtctl # The cache key a combination of the current PR number and the commit SHA key: crtctl-${{ github.event.pull_request.number }}-${{ github.sha }} è¾“å…¥å‚æ•° # keyï¼šå¿…é¡»ã€‚ç¼“å­˜çš„ keyã€‚ å®ƒå¯ä»¥æ˜¯å˜é‡ã€ä¸Šä¸‹æ–‡å€¼ã€é™æ€å­—ç¬¦ä¸²å’Œå‡½æ•°çš„ä»»ä½•ç»„åˆã€‚ å¯†é’¥æœ€å¤§é•¿åº¦ä¸º 512 ä¸ªå­—ç¬¦ï¼Œå¯†é’¥é•¿åº¦è¶…è¿‡æœ€å¤§é•¿åº¦å°†å¯¼è‡´æ“ä½œå¤±è´¥ã€‚ pathï¼šå¿…é¡»ã€‚è¿è¡Œå™¨ä¸Šç”¨äºç¼“å­˜æˆ–è¿˜åŸçš„è·¯å¾„ã€‚å¯ä»¥æŒ‡å®šå•ä¸ªè·¯å¾„ï¼Œä¹Ÿå¯ä»¥åœ¨å•ç‹¬çš„è¡Œä¸Šæ·»åŠ å¤šä¸ªè·¯å¾„ã€‚ ä¾‹å¦‚ï¼š - name: Cache Gradle packages uses: actions/cache@v3 with: path: | ~/.gradle/caches ~/.gradle/wrapper restore-keysï¼šå¯é€‰çš„ã€‚å¤‡ç”¨çš„ç¼“å­˜ key å­—ç¬¦ä¸²ï¼Œæ¯ä¸ª key æ”¾ç½®åœ¨ä¸€ä¸ªæ–°è¡Œä¸Šã€‚å¦‚æœ key æ²¡æœ‰å‘½ä¸­ç¼“å­˜ï¼Œåˆ™æŒ‰ç…§æä¾›çš„é¡ºåºä¾æ¬¡ä½¿ç”¨è¿™äº›è¿˜åŸé”®æ¥æŸ¥æ‰¾å’Œè¿˜åŸç¼“å­˜ã€‚ä¾‹å¦‚ï¼š restore-keys: | npm-feature-${{ hashFiles(\u0026#39;package-lock.json\u0026#39;) }} npm-feature- npm- è¾“å‡ºå‚æ•° # cache-hitï¼šå¸ƒå°”å€¼ï¼Œæ˜¯å¦å‘½ä¸­ç¼“å­˜ã€‚ - if: ${{ steps.cache-npm.outputs.cache-hit != \u0026#39;true\u0026#39; }} name: List the state of node modules continue-on-error: true run: npm list ç¼“å­˜åŒ¹é…è¿‡ç¨‹ # å½“ key åŒ¹é…ç°æœ‰ç¼“å­˜æ—¶ï¼Œè¢«ç§°ä¸ºç¼“å­˜å‘½ä¸­ï¼Œå¹¶ä¸”æ“ä½œä¼šå°†ç¼“å­˜çš„æ–‡ä»¶è¿˜åŸåˆ° path ç›®å½•ã€‚ å½“ key ä¸åŒ¹é…ç°æœ‰ç¼“å­˜æ—¶ï¼Œåˆ™è¢«ç§°ä¸ºç¼“å­˜å¤±è¯¯ï¼Œåœ¨ä½œä¸šæˆåŠŸå®Œæˆæ—¶ä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªæ–°ç¼“å­˜ã€‚å‘ç”Ÿç¼“å­˜å¤±è¯¯æ—¶ï¼Œè¯¥æ“ä½œè¿˜ä¼šæœç´¢æŒ‡å®šçš„ restore-keys ä»¥æŸ¥æ‰¾ä»»ä½•åŒ¹é…é¡¹ï¼š å¦‚æœæä¾› restore-keysï¼Œcache æ“ä½œå°†æŒ‰é¡ºåºæœç´¢ä¸ restore-keys åˆ—è¡¨åŒ¹é…çš„ä»»ä½•ç¼“å­˜ã€‚ å½“å­˜åœ¨ç²¾ç¡®åŒ¹é…æ—¶ï¼Œè¯¥æ“ä½œä¼šå°†ç¼“å­˜ä¸­çš„æ–‡ä»¶è¿˜åŸåˆ° path ç›®å½•ã€‚ å¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ï¼Œæ“ä½œå°†ä¼šæœç´¢æ¢å¤é”®å€¼çš„éƒ¨åˆ†åŒ¹é…ã€‚ å½“æ“ä½œæ‰¾åˆ°éƒ¨åˆ†åŒ¹é…æ—¶ï¼Œæœ€è¿‘çš„ç¼“å­˜å°†è¿˜åŸåˆ° path ç›®å½•ã€‚ cache æ“ä½œå®Œæˆï¼Œä½œä¸šä¸­çš„ä¸‹ä¸€ä¸ªæ­¥éª¤è¿è¡Œã€‚ å¦‚æœä½œä¸šæˆåŠŸå®Œæˆï¼Œåˆ™æ“ä½œå°†è‡ªåŠ¨åˆ›å»ºä¸€ä¸ªåŒ…å« path ç›®å½•å†…å®¹çš„æ–°ç¼“å­˜ã€‚ åŒ¹é…ç¼“å­˜é”®è¯¦ç»†è¿‡ç¨‹ ã€‚\nä½¿ç”¨é™åˆ¶å’Œæ”¶å›æ”¿ç­– # GitHub å°†åˆ é™¤ 7 å¤©å†…æœªè¢«è®¿é—®çš„ä»»ä½•ç¼“å­˜æ¡ç›®ã€‚ å¯ä»¥å­˜å‚¨çš„ç¼“å­˜æ•°æ²¡æœ‰é™åˆ¶ï¼Œä½†å­˜å‚¨åº“ä¸­æ‰€æœ‰ç¼“å­˜çš„æ€»å¤§å°é™åˆ¶ä¸º 10 GBã€‚\nå¦‚æœè¶…è¿‡æ­¤é™åˆ¶ï¼ŒGitHub å°†ä¿å­˜æ–°ç¼“å­˜ï¼Œä½†ä¼šå¼€å§‹æ”¶å›ç¼“å­˜ï¼Œç›´åˆ°æ€»å¤§å°å°äºå­˜å‚¨åº“é™åˆ¶ã€‚\nè‡ªåŠ¨æ‰“ Label # ä½¿ç”¨ actions/labeler æ¥å®ç°è‡ªåŠ¨æ‰“ Labelã€‚\nä½¿ç”¨ # åˆ›å»º .github/labeler.yml æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶åŒ…å«æ ‡ç­¾åˆ—è¡¨å’Œéœ€è¦åŒ¹é…çš„ minimatch globsï¼Œä»¥åº”ç”¨æ ‡ç­¾ã€‚\n.github/labeler.yml æ–‡ä»¶ä¸­ï¼Œkey å°±æ˜¯ label çš„åå­—ï¼Œå€¼æ˜¯æ–‡ä»¶è·¯å¾„ã€‚\nWorkflow ç¤ºä¾‹ï¼š\non: pull_request_target: types: [opened, reopened, synchronize, ready_for_review] jobs: # Automatically labels PRs based on file globs in the change. triage: runs-on: ubuntu-latest steps: - uses: actions/labeler@v3 with: repo-token: \u0026#34;${{ secrets.GITHUB_TOKEN }}\u0026#34; configuration-path: .github/labels.yml è¾“å…¥å‚æ•°ï¼š\nrepo-tokenï¼šGITHUB_TOKENï¼Œéœ€è¦ contents:read å’Œ pull-requests:write æƒé™ã€‚ configuration-pathï¼šLabel é…ç½®æ–‡ä»¶è·¯å¾„ã€‚ sync-labelsï¼šå½“åŒ¹é…çš„æ–‡ä»¶è¢«è¿˜åŸæˆ–ä¸å†è¢« PR æ”¹å˜æ—¶ï¼Œæ˜¯å¦è¦åˆ é™¤æ ‡ç­¾ã€‚ è‡ªåŠ¨ Assign # ä½¿ç”¨ auto-assign-action æ¥å®ç°è‡ªåŠ¨ assignã€‚\nåˆ›å»ºé…ç½®æ–‡ä»¶ï¼Œä¾‹å¦‚ï¼š.github/auto_assign.ymlã€‚åœ¨æ–‡ä»¶ä¸­æ·»åŠ  reviewers/assigneesã€‚\n# Set to true to add reviewers to pull requests addReviewers: true # Set to true to add assignees to pull requests addAssignees: false # Set addAssignees to \u0026#39;author\u0026#39; to set the PR creator as the assignee. # addAssignees: author # A list of reviewers to be added to pull requests (GitHub user name) reviewers: - reviewerA - reviewerB - reviewerC # A number of reviewers added to the pull request # Set 0 to add all the reviewers (default: 0) numberOfReviewers: 0 # A list of assignees, overrides reviewers if set # assignees: # - assigneeA # A number of assignees to add to the pull request # Set to 0 to add all of the assignees. # Uses numberOfReviewers if unset. # numberOfAssignees: 2 # Set to true to add reviewers from different groups to pull requests useReviewGroups: true # A list of reviewers, split into different groups, to be added to pull requests (GitHub user name) reviewGroups: groupA: - reviewerA - reviewerB - reviewerC groupB: - reviewerD - reviewerE - reviewerF # Set to true to add assignees from different groups to pull requests useAssigneeGroups: false # A list of assignees, split into different froups, to be added to pull requests (GitHub user name) # assigneeGroups: # groupA: # - assigneeA # - assigneeB # - assigneeC # groupB: # - assigneeD # - assigneeE # - assigneeF # A list of keywords to be skipped the process that add reviewers if pull requests include it # skipKeywords: # - wip # The action will only run for non-draft PRs. If you want to run for all PRs, you need to enable it to run on drafts. # runOnDraft: true Workflow ç¤ºä¾‹ï¼š\nname: \u0026#34;Auto Assign Author\u0026#34; # pull_request_target means that this will run on pull requests, but in # the context of the base repo. This should mean PRs from forks are supported. on: pull_request_target: types: [opened, reopened, ready_for_review] jobs: # Automatically assigns reviewers and owner add-reviews: runs-on: ubuntu-latest steps: - name: Set the author of a PR as the assignee uses: kentaro-m/auto-assign-action@v1.2.4 with: configuration-path: \u0026#34;.github/auto_assignees.yml\u0026#34; repo-token: \u0026#34;${{ secrets.GITHUB_TOKEN }}\u0026#34; Close Stale Issues and PRs # ä½¿ç”¨ close-stale-issues æ¥è‡ªåŠ¨å…³é—­é•¿æ—¶é—´ä¸æ´»è·ƒçš„ PR å’Œ issuesã€‚\né…ç½®å¿…é¡»åœ¨é»˜è®¤åˆ†æ”¯ä¸Šï¼Œé»˜è®¤å€¼å°†ä¼šï¼š\nåœ¨ 60 å¤©æ²¡æœ‰æ´»è·ƒçš„ issue å’Œ PR ä¸Šæ·»åŠ ä¸€ä¸ª \u0026ldquo;Stale\u0026rdquo; æ ‡ç­¾ï¼Œå¹¶æ·»åŠ  commentsã€‚ æ·»åŠ  \u0026ldquo;Stale\u0026rdquo; æ ‡ç­¾ 7 å¤©åå…³é—­ issue å’Œ PRã€‚ å¦‚æœ issue å’Œ PR å‘ç”Ÿæ›´æ–°/è¯„è®ºï¼Œ\u0026ldquo;Stale\u0026rdquo; æ ‡ç­¾å°†è¢«åˆ é™¤ï¼Œè®¡æ—¶å™¨ä¼šé‡å¯ã€‚ éœ€è¦çš„æƒé™ï¼š\npermissions: contents: write # only for delete-branch option issues: write pull-requests: write ç¤ºä¾‹ # name: \u0026#34;Close stale issues and PRs\u0026#34; on: schedule: # First of every month - cron: \u0026#34;30 1 * * *\u0026#34; jobs: stale: runs-on: ubuntu-latest steps: - uses: actions/stale@v3 with: repo-token: ${{ secrets.GITHUB_TOKEN }} stale-issue-message: \u0026#34;This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 5 days. If a Velero team member has requested log or more information, please provide the output of the shared commands.\u0026#34; close-issue-message: \u0026#34;This issue was closed because it has been stalled for 5 days with no activity.\u0026#34; days-before-issue-stale: 30 days-before-issue-close: 5 # Disable stale PRs for now; they can remain open. days-before-pr-stale: -1 days-before-pr-close: -1 # Only issues made after Oct 01 2022. start-date: \u0026#34;2022-10-01T00:00:00\u0026#34; # Only make issues stale if they have these labels. Comma separated. only-labels: \u0026#34;Needs info,Duplicate\u0026#34; Gitleaks # Gitleaks æ˜¯ä¸€æ¬¾ SAST å·¥å…·ï¼Œç”¨äºæ£€æµ‹å’Œé˜²æ­¢ git ä»“åº“ä¸­çš„å¯†ç ã€API å¯†é’¥å’Œä»¤ç‰Œç­‰ç¡¬ç¼–ç ç§˜å¯†ã€‚\nname: gitleaks on: pull_request: push: workflow_dispatch: schedule: - cron: \u0026#34;0 4 * * *\u0026#34; # run once a day at 4 AM jobs: scan: name: gitleaks runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: fetch-depth: 0 - uses: gitleaks/gitleaks-action@v2 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE}} # Only required for Organizations, not personal accounts. å¸¸ç”¨é…ç½®ï¼š\n# å®šä¹‰äº†å¦‚ä½•æ£€æµ‹ secrets [[rules]] # è§„åˆ™ id id = \u0026#34;ignore-testdata\u0026#34; # ä¸ºå•æ¡è§„åˆ™åŠ å…¥ä¸€ä¸ªå…è®¸åˆ—è¡¨ï¼Œä»¥å‡å°‘è¯¯æŠ¥ï¼Œæˆ–å¿½ç•¥å·²çŸ¥çš„ secret çš„æäº¤ã€‚ [rules.allowlist] paths = [\u0026#39;\u0026#39;\u0026#39;.*/testdata/*\u0026#39;\u0026#39;\u0026#39;] # å…¨å±€çš„å…è®¸åˆ—è¡¨ [allowlist] æ›´å¤šé…ç½® Configurationã€‚\nAnchore Container Scan # ç”¨äºè°ƒç”¨ Grype æ‰«æä»ªå¹¶è¿”å›å‘ç°çš„æ¼æ´ï¼Œå¦‚æœå‘ç°äº†æ¼æ´ï¼Œè¿˜å¯é€‰æ‹©ä»¥å¯é…ç½®çš„ä¸¥é‡ç¨‹åº¦å¤±è´¥ã€‚\nname: \u0026#34;grype\u0026#34; on: push: branches: [\u0026#39;main\u0026#39;] tags: [\u0026#39;v*\u0026#39;] pull_request: jobs: scan-source: name: scan-source runs-on: ubuntu-latest permissions: security-events: write actions: read contents: read steps: - uses: actions/checkout@v3 - uses: anchore/scan-action@v3 with: path: \u0026#34;.\u0026#34; fail-build: true grype Configuration # é»˜è®¤é…ç½®æ–‡ä»¶çš„æœç´¢è·¯å¾„:\n.grype.yaml .grype/config.yaml ~/.grype.yaml \u0026lt;XDG_CONFIG_HOME\u0026gt;/grype/config.yaml ä¹Ÿå¯ä»¥ä½¿ç”¨ --config/-c æ¥æŒ‡å®šé…ç½®æ–‡ä»¶ã€‚\nå¸¸ç”¨é…ç½®ï¼š\n# æ‰«ææ—¶ï¼Œå¦‚æœå‘ç°ä¸¥é‡æ€§è¾¾åˆ°æˆ–è¶…è¿‡è®¾ç½®çš„å€¼ï¼Œåˆ™è¿”å›ä»£ç ä¸º 1ã€‚é»˜è®¤ä¸ºæœªè®¾ç½® fail-on-severity: high # å¦‚æœä½¿ç”¨ SBOM è¾“å…¥ï¼Œåˆ™åœ¨è½¯ä»¶åŒ…æ²¡æœ‰ CPE æ—¶è‡ªåŠ¨ç”Ÿæˆ CPE add-cpes-if-none: true # è¾“å‡ºæ ¼å¼ (å…è®¸çš„å€¼: table, json, cyclonedx) output: table # è¦ä»æ‰«æä¸­æ’é™¤çš„æ–‡ä»¶ exclude: - \u0026#34;**/testdata/**\u0026#34; # å¦‚æœçœ‹åˆ° Grype æŠ¥å‘Šè¯¯æŠ¥æˆ–ä»»ä½•å…¶ä»–ä¸æƒ³çœ‹åˆ°çš„æ¼æ´åŒ¹é…ï¼Œå¯ä»¥é…ç½® \u0026#34;å¿½ç•¥è§„åˆ™\u0026#34;ï¼ŒGrype ä¼šå¿½ç•¥åŒ¹é…ç»“æœ ignore: - fix-state: unknown # å…è®¸çš„å€¼: \u0026#34;fixed\u0026#34;, \u0026#34;not-fixed\u0026#34;, \u0026#34;wont-fix\u0026#34;, or \u0026#34;unknown\u0026#34; vulnerability: \u0026#34;CVE-2008-4318\u0026#34; # vulnerability ID æ›´å¤šé…ç½® Grypeã€‚\nGitHub CodeQL Action # GitHub CodeQL Action æ˜¯ä¸€ä¸ªç”¨äºå®‰å…¨æ€§ä»£ç åˆ†æçš„ GitHub Actionsï¼Œä½¿ç”¨ CodeQL æŸ¥è¯¢è¯­è¨€æ¥æœç´¢é¡¹ç›®ä¸­çš„ä»£ç æ¼æ´å’Œå®‰å…¨é—®é¢˜ã€‚ è¯¢å®Œæˆåï¼ŒCodeQL Action ä¼šç”ŸæˆæŠ¥å‘Šï¼Œæ˜¾ç¤ºæŸ¥è¯¢ç»“æœã€‚\nCodeQL å¯ä»¥åœ¨ Security -\u0026gt; Overview -\u0026gt; Code scanning alerts -\u0026gt; Set up code scanning æ‰¾åˆ°å®˜æ–¹ç»™çš„ CodeQL Workflow Templateã€‚ é€‰æ‹© Set up this workflow å°±å¯ä»¥ç”¨ template äº†ã€‚\nä¹Ÿå¯ä»¥è‡ªå·±åœ¨ workflow ä¸­åŠ ä¸Š CodeQL Actionã€‚\nname: \u0026#34;codeql\u0026#34; on: push: branches: [ main ] jobs: analyze: name: analyze runs-on: ubuntu-latest permissions: actions: read contents: read security-events: write steps: - uses: actions/checkout@v3 - uses: actions/setup-go@v4 with: go-version: stable - name: initialize codeql uses: github/codeql-action/init@v2 with: languages: go # javascript, csharp, python, cpp, java - name: build package run: go build ./cmd # build package C/C++, C#, Java, Go, Swift å¯ä»¥ç›´æ¥ä½¿ç”¨ CodeQL çš„ autobuild ä½œæ›¿ä»£ # - name: auto build package # uses: github/codeql-action/autobuild@v2 - uses: github/codeql-action/analyze@v2 Git Auto Commit # ç”¨äºæ£€æµ‹å·¥ä½œæµè¿è¡ŒæœŸé—´æ›´æ”¹çš„æ–‡ä»¶ï¼Œå¹¶å°†å…¶æäº¤å’Œæ¨é€å› GitHub ä»“åº“ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæäº¤ä¼šä»¥ \u0026ldquo;GitHub Action\u0026quot;çš„åä¹‰è¿›è¡Œï¼Œå¹¶ç”±ä¸Šæ¬¡æäº¤çš„ç”¨æˆ·å…±åŒæ’°å†™ã€‚\nCONTRIBUTING.mdï¼ŒChangeLog ä¹‹ç±»çš„æ”¹åŠ¨å¯ä»¥ä½¿ç”¨è¯¥ action æ¥å®ç°è‡ªåŠ¨æäº¤ã€‚\nname: Format on: push jobs: format-code: runs-on: ubuntu-latest permissions: # Give the default GITHUB_TOKEN write permission to commit and push the # added or changed files to the repository. contents: write steps: - uses: actions/checkout@v3 # Other steps that change files in the repository # Commit all changed files back to the repository - uses: stefanzweifel/git-auto-commit-action@v4 Dependency Review # æ‰«ææ‹‰å–è¯·æ±‚ä¸­çš„ä¾èµ–å…³ç³»æ›´æ”¹ï¼Œå¦‚æœå¼•å…¥äº†ä»»ä½•æ¼æ´æˆ–æ— æ•ˆè®¸å¯è¯ï¼Œåˆ™ä¼šå¼•å‘é”™è¯¯ã€‚\nname: \u0026#39;Dependency Review\u0026#39; on: [pull_request] permissions: contents: read jobs: dependency-review: runs-on: ubuntu-latest steps: - name: \u0026#39;Checkout Repository\u0026#39; uses: actions/checkout@v3 - name: \u0026#39;Dependency Review\u0026#39; uses: actions/dependency-review-action@v3 åœ¨ Github Action ä¸­é…ç½® Git è®¿é—® Github # ä½¿ç”¨ Github Access token # é¦–å…ˆéœ€è¦ç”Ÿæˆä¸€ä¸ª Access Tokenï¼Œåˆ›å»º tokenã€‚ åœ¨ repo çš„ Settings é¡µé¢ä¸­æ·»åŠ  Secretï¼Œä¾‹å¦‚ï¼Œæˆ‘çš„ secret å‘½åä¸º PATã€‚ åœ¨ Action ä¸­ä½¿ç”¨ï¼š\nsteps: - name: release run: | GITHUB_TOKEN=${{ secrets.PAT }} make release é€šè¿‡ Access Token çš„æ–¹å¼ clone repoï¼š\nsteps: - name: Checkout uses: actions/checkout@v3 with: repository: shipengqi/crtctl token: ${{ secrets.PAT }} path: crtctl ä¸Šé¢çš„æ–¹å¼ç”¨çš„æ˜¯ HTTPS çš„æ–¹å¼ã€‚é€šè¿‡ git remote -v æŸ¥çœ‹å¯ä»¥çœ‹åˆ° remote çš„åœ°å€ã€‚\nä½¿ç”¨ SSH # é¦–å…ˆéœ€è¦ä¸€ä¸ª Github ä¸­å·²ç»é…ç½®å¥½çš„ ssh çš„ public keyã€‚ åœ¨ repo çš„ Settings é¡µé¢ä¸­æ·»åŠ  Secretï¼Œä¾‹å¦‚ï¼Œæˆ‘çš„ secret å‘½åä¸º SSH_KEYã€‚ åœ¨ Action ä¸­é…ç½® sshï¼š\n- name: Install SSH Key uses: shimataro/ssh-key-action@v2 with: key: ${{ secrets.SSH_KEY }} known_hosts: \u0026#39;just-a-placeholder-so-we-dont-get-errors\u0026#39; ä¹‹åå°±å¯ä»¥åœ¨ Action çš„åç»­æ­¥éª¤ä¸­åƒåœ¨æœ¬åœ°ä¸€æ ·ä½¿ç”¨ SSH çš„æ–¹å¼æ¥ clone repo å’Œæäº¤ä»£ç äº†ã€‚\n"},{"id":30,"href":"/golang-learn/docs/concurrency/09_channel/","title":"Channel","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" Channel # Donâ€™t communicate by sharing memory; share memory by communicating. ä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œé€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜ã€‚ è¿™æ˜¯ Go è¯­è¨€æœ€é‡è¦çš„ç¼–ç¨‹ç†å¿µã€‚goroutine é€šè¿‡ channel å‘å¦ä¸€ä¸ª goroutine å‘é€æ¶ˆæ¯ï¼Œchannel å’Œ goroutine ç»“åˆï¼Œå¯ä»¥å®ç°ç”¨é€šä¿¡ä»£æ›¿å…±äº«å†…å­˜çš„ CSP ï¼ˆCommunicating Sequential Processï¼‰æ¨¡å‹ã€‚\nä½¿ç”¨ # åˆ›å»º channelï¼š\n// æ— ç¼“å†² channel ch := make(chan int) // å¸¦ç¼“å†² channelï¼Œç¼“å†²åŒºä¸º 3 ch = make(chan int, 3) channel çš„é›¶å€¼æ˜¯ nilã€‚\næ— ç¼“å†² channel # æ— ç¼“å†² channel ä¹Ÿå«åšåŒæ­¥ channelï¼š\nä¸€ä¸ª goroutine åŸºäºä¸€ä¸ªæ— ç¼“å†² channel å‘é€æ•°æ®ï¼Œé‚£ä¹ˆå°±ä¼šé˜»å¡ï¼Œç›´åˆ°å¦ä¸€ä¸ª goroutine åœ¨ç›¸åŒçš„ channel ä¸Šæ‰§è¡Œæ¥æ”¶æ“ä½œã€‚ ä¸€ä¸ª goroutine åŸºäºä¸€ä¸ªæ— ç¼“å†² channel å…ˆæ‰§è¡Œäº†æ¥æ”¶æ“ä½œï¼Œä¹Ÿä¼šé˜»å¡ï¼Œç›´åˆ°å¦ä¸€ä¸ª goroutine åœ¨ç›¸åŒçš„ channel ä¸Šæ‰§è¡Œå‘é€æ“ä½œ å¸¦ç¼“å†² channel # å¸¦ç¼“å†²çš„ channel æœ‰ä¸€ä¸ªç¼“å†²åŒºï¼š\nè‹¥ç¼“å†²åŒºæœªæ»¡åˆ™ä¸ä¼šé˜»å¡ï¼Œå‘é€è€…å¯ä»¥ä¸æ–­çš„å‘é€æ•°æ®ã€‚å½“ç¼“å†²åŒºæ»¡äº†åï¼Œå‘é€è€…å°±ä¼šé˜»å¡ã€‚ å½“ç¼“å†²åŒºä¸ºç©ºæ—¶ï¼Œæ¥å—è€…å°±ä¼šé˜»å¡ï¼Œç›´è‡³æœ‰æ–°çš„æ•°æ® å…³é—­ channel # ä½¿ç”¨ close å‡½æ•°å…³é—­ channelï¼š\nchannel å…³é—­åä¸èƒ½å†å‘é€æ•°æ® channel å…³é—­åå¯ä»¥æ¥æ”¶å·²ç»å‘é€æˆåŠŸçš„æ•°æ®ã€‚ channel å…³é—­åå¦‚æœ channel ä¸­æ²¡æœ‰æ•°æ®ï¼Œé‚£ä¹ˆæ¥æ”¶è€…ä¼šæ”¶åˆ°ä¸€ä¸ª channel å…ƒç´ çš„é›¶å€¼ã€‚ close è¡¨ç¤ºè¿™ä¸ª channel ä¸ä¼šå†ç»§ç»­å‘é€æ•°æ®ï¼Œæ‰€ä»¥è¦åœ¨å‘é€è€…æ‰€åœ¨çš„ goroutine å»å…³é—­ channelã€‚\nå…³é—­ä¸€ä¸ª nil çš„ channel ä¼šå¯¼è‡´ panicã€‚\né‡å¤å…³é—­ channel ä¼šå¯¼è‡´ panicã€‚\nå‘å·²å…³é—­çš„ channel å‘é€å€¼ä¼šå¯¼è‡´ panicã€‚\nå•å‘ channel # å½“ä¸€ä¸ª channel ä½œä¸ºä¸€ä¸ªå‡½æ•°å‚æ•°æ—¶ï¼Œå®ƒä¸€èˆ¬æ€»æ˜¯è¢«ä¸“é—¨ç”¨äºåªå‘é€æˆ–è€…åªæ¥æ”¶ã€‚\nchan\u0026lt;- int è¡¨ç¤ºä¸€ä¸ªåªå‘é€ int çš„ channelã€‚ \u0026lt;-chan int è¡¨ç¤ºä¸€ä¸ªåªæ¥æ”¶ int çš„ channelã€‚ cap å’Œ len # cap å‡½æ•°å¯ä»¥è·å– channel å†…éƒ¨ç¼“å†²åŒºçš„å®¹é‡ã€‚ len å‡½æ•°å¯ä»¥è·å– channel å†…éƒ¨ç¼“å†²åŒºæœ‰æ•ˆå…ƒç´ çš„ä¸ªæ•°ã€‚ ä½¿ç”¨ range éå† channel # ä½¿ç”¨ range å¾ªç¯å¯ä»¥éå† channelï¼Œå®ƒä¾æ¬¡ä» channel ä¸­æ¥æ”¶æ•°æ®ï¼Œå½“ channel è¢«å…³é—­å¹¶ä¸”æ²¡æœ‰å€¼å¯æ¥æ”¶æ—¶è·³å‡ºå¾ªç¯ï¼š\nch := make(chan int, 3) ch \u0026lt;- 1 ch \u0026lt;- 2 ch \u0026lt;- 3 // å…³é—­ channel // å¦‚æœä¸å…³é—­ channelï¼Œrange å°±ä¼šé˜»å¡å½“å‰ goroutine, ç›´åˆ° channel å…³é—­ close(ch) for v := range ch { fmt.Println(v) } ä½¿ç”¨ channel å®ç°äº’æ–¥é” # æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®¹é‡åªæœ‰ 1 çš„ channel æ¥ä¿è¯æœ€å¤šåªæœ‰ä¸€ä¸ª goroutine åœ¨åŒä¸€æ—¶åˆ»è®¿é—®ä¸€ä¸ªå…±äº«å˜é‡ï¼š\nvar ( sema = make(chan struct{}, 1) // a binary semaphore guarding balance balance int ) func Deposit(amount int) { sema \u0026lt;- struct{}{} // acquire lock balance = balance + amount \u0026lt;-sema // release lock } func Balance() int { sema \u0026lt;- struct{}{} // acquire lock b := balance \u0026lt;-sema // release lock // return b } åŸç† # channel æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªæœ‰é”çš„ç¯å½¢é˜Ÿåˆ—ï¼Œchannel çš„ç»“æ„ä½“ hchanï¼š\n// src/runtime/chan.go type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G\u0026#39;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } qcountï¼šchannel ä¸­çš„å…ƒç´ ä¸ªæ•° dataqsizï¼šchannel ä¸­çš„å¾ªç¯é˜Ÿåˆ—çš„é•¿åº¦ bufï¼šchannel çš„ç¼“å†²åŒºæ•°æ®æŒ‡é’ˆï¼ŒæŒ‡å‘åº•å±‚çš„å¾ªç¯æ•°ç»„ï¼Œåªé’ˆå¯¹æœ‰ç¼“å†²çš„ channelã€‚ elemsizeï¼šchannel ä¸­å…ƒç´ å¤§å° elemtypeï¼šchannel ä¸­å…ƒç´ ç±»å‹ closedï¼šchannel æ˜¯å¦è¢«å…³é—­çš„æ ‡å¿—ä½ sendxï¼šè¡¨ç¤ºå½“å‰å¯ä»¥å‘é€çš„å…ƒç´ åœ¨åº•å±‚å¾ªç¯æ•°ç»„ä¸­ä½ç½®ç´¢å¼• recvxï¼šè¡¨ç¤ºå½“å‰å¯ä»¥å‘é€çš„å…ƒç´ åœ¨åº•å±‚å¾ªç¯æ•°ç»„ä¸­ä½ç½®ç´¢å¼• sendqï¼šå‘ channel å‘é€æ•°æ®è€Œè¢«é˜»å¡çš„ goroutine é˜Ÿåˆ— recvqï¼šè¯»å– channel çš„æ•°æ®è€Œè¢«é˜»å¡çš„ goroutine é˜Ÿåˆ— lockï¼šä¿æŠ¤ hchan ä¸­æ‰€æœ‰å­—æ®µ waitq æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œé“¾è¡¨ä¸­æ‰€æœ‰çš„å…ƒç´ éƒ½æ˜¯ sudogï¼š\ntype waitq struct { first *sudog last *sudog } type sudog struct { // æŒ‡å‘å½“å‰çš„ goroutine g *g // æŒ‡å‘ä¸‹ä¸€ä¸ª goroutine next *sudog // æŒ‡å‘ä¸Šä¸€ä¸ª goroutine prev *sudog // æŒ‡å‘å…ƒç´ æ•°æ® elem unsafe.Pointer // ... } åˆ›å»º channel # åˆ›å»º channel è¦ä½¿ç”¨ makeï¼Œç¼–è¯‘å™¨ä¼šå°† make è½¬æ¢æˆ makechan æˆ–è€… makechan64 å‡½æ•°ï¼š\n// src/runtime/chan.go#L72 func makechan(t *chantype, size int) *hchan { elem := t.Elem // compiler checks this but be safe. // ... var c *hchan switch { case mem == 0: // æ— ç¼“å†² channel // è°ƒç”¨ mallocgc æ–¹æ³•åˆ†é…ä¸€æ®µè¿ç»­çš„å†…å­˜ç©ºé—´ c = (*hchan)(mallocgc(hchanSize, nil, true)) c.buf = c.raceaddr() case elem.PtrBytes == 0: // channel å­˜å‚¨çš„å…ƒç´ ç±»å‹ä¸æ˜¯æŒ‡é’ˆ // åˆ†é…ä¸€å—è¿ç»­çš„å†…å­˜ç»™ hchan å’Œåº•å±‚æ•°ç»„ c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿›è¡Œä¸¤æ¬¡å†…å­˜åˆ†é…æ“ä½œï¼Œåˆ†åˆ«ä¸º hchan å’Œç¼“å†²åŒºåˆ†é…å†…å­˜ c = new(hchan) c.buf = mallocgc(mem, elem, true) } // è®¾ç½®å…ƒç´ å¤§å°ï¼Œå…ƒç´ ç±»å‹ï¼Œå¾ªç¯æ•°ç»„çš„é•¿åº¦ c.elemsize = uint16(elem.Size_) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) // ... return c } ä½¿ç”¨ mallocgc å‡½æ•°åˆ›å»º channelï¼Œå°±æ„å‘³ç€ channel éƒ½æ˜¯åˆ†é…åœ¨å †ä¸Šçš„ã€‚æ‰€ä»¥å½“ä¸€ä¸ª channel æ²¡æœ‰è¢«ä»»ä½• goroutine å¼•ç”¨æ—¶ï¼Œæ˜¯ä¼šè¢« GC å›æ”¶çš„ã€‚\nå‘ channel å‘é€æ•°æ® # å‘é€æ“ä½œï¼Œä¹Ÿå°±æ˜¯ ch \u0026lt;- i è¯­å¥ï¼Œç¼–è¯‘å™¨æœ€ç»ˆä¼šå°†è¯¥è¯­å¥è½¬æ¢æˆ chansend å‡½æ•°ï¼š\n// src/runtime/chan.go // block ä¸º true æ—¶ï¼Œè¡¨ç¤ºå½“å‰æ“ä½œæ˜¯é˜»å¡çš„ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { // ä¸å¯ä»¥é˜»å¡ï¼Œç›´æ¥è¿”å› falseï¼Œè¡¨ç¤ºæœªå‘é€æˆåŠŸ if !block { return false } // æŒ‚èµ·å½“å‰ goroutine gopark(nil, nil, waitReasonChanSendNilChan, traceBlockForever, 2) throw(\u0026#34;unreachable\u0026#34;) } // ... if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } // æ‰§è¡Œå‘é€æ•°æ®çš„é€»è¾‘ä¹‹å‰ï¼Œå…ˆä¸ºå½“å‰ channel åŠ é”ï¼Œé˜²æ­¢å¤šä¸ªçº¿ç¨‹å¹¶å‘ä¿®æ”¹æ•°æ® lock(\u0026amp;c.lock) // å¦‚æœ channel å·²ç»å…³é—­ï¼Œé‚£ä¹ˆå‘è¯¥ channel å‘é€æ•°æ®ä¼šå¯¼è‡´ panicï¼šsend on closed channel if c.closed != 0 { // è§£é” unlock(\u0026amp;c.lock) // panic panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } // å½“å‰æ¥æ”¶é˜Ÿåˆ—é‡Œå­˜åœ¨ goroutineï¼Œé€šè¿‡ runtime.send ç›´æ¥å°†æ•°æ®å‘é€ç»™é˜»å¡çš„æ¥æ”¶è€… if sg := c.recvq.dequeue(); sg != nil { send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } // èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜æ²¡æœ‰ç­‰å¾…æ•°æ®çš„æ¥æ”¶è€… // å¯¹äºæœ‰ç¼“å†²çš„ channelï¼Œå¹¶ä¸”è¿˜æœ‰ç¼“å†²ç©ºé—´ if c.qcount \u0026lt; c.dataqsiz { // è®¡ç®—å‡ºä¸‹ä¸€ä¸ªå¯ä»¥å­˜å‚¨æ•°æ®çš„ä½ç½® qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } // å°†å‘é€çš„æ•°æ®æ‹·è´åˆ°ç¼“å†²åŒºä¸­å¹¶å¢åŠ  sendx ç´¢å¼•å’Œ qcount è®¡æ•°å™¨ typedmemmove(c.elemtype, qp, ep) // sendx ç´¢å¼• +1 c.sendx++ // ç”±äº buf æ˜¯ä¸€ä¸ªå¾ªç¯æ•°ç»„ï¼Œæ‰€ä»¥å½“ sendx ç­‰äº dataqsiz æ—¶ä¼šé‡æ–°å›åˆ°æ•°ç»„å¼€å§‹çš„ä½ç½®ã€‚ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ // é‡Šæ”¾é” unlock(\u0026amp;c.lock) return true } // èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜ç¼“å†²ç©ºé—´å·²æ»¡ï¼Œæˆ–è€…æ˜¯æ— ç¼“å†² channel // å¦‚æœä¸å¯ä»¥é˜»å¡ï¼Œç›´æ¥è¿”å› falseï¼Œè¡¨ç¤ºæœªå‘é€æˆåŠŸ if !block { unlock(\u0026amp;c.lock) return false } // ç¼“å†²ç©ºé—´å·²æ»¡æˆ–è€…æ˜¯æ— ç¼“å†² channelï¼Œå‘é€æ–¹ä¼šè¢«é˜»å¡ // è·å–å½“å‰å‘é€æ•°æ®çš„ goroutine çš„æŒ‡é’ˆ gp := getg() // æ„é€ ä¸€ä¸ª sudog mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // è®¾ç½®è¿™ä¸€æ¬¡é˜»å¡å‘é€çš„ç›¸å…³ä¿¡æ¯ mysg.elem = ep // å¾…å‘é€æ•°æ®çš„å†…å­˜åœ°å€ mysg.waitlink = nil mysg.g = gp // å½“å‰å‘é€æ•°æ®çš„ goroutine çš„æŒ‡é’ˆ mysg.isSelect = false // æ˜¯å¦åœ¨ select ä¸­ mysg.c = c // å‘é€çš„ channel gp.waiting = mysg gp.param = nil // å°† sudog æ”¾å…¥åˆ°å‘é€ç­‰å¾…é˜Ÿåˆ— c.sendq.enqueue(mysg) // æŒ‚èµ·å½“å‰ goroutineï¼Œç­‰å¾…å”¤é†’ gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceBlockChanSend, 2) KeepAlive(ep) // goroutine å¼€å§‹è¢«å”¤é†’äº† if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } // ç§»é™¤ mysg ä¸Šç»‘å®šçš„ channel mysg.c = nil releaseSudog(mysg) if closed { if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) } // è¢«å”¤é†’äº†ï¼Œä½†æ˜¯ channel å·²ç»å…³é—­äº†ï¼Œpanic panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } // è¿”å› true è¡¨ç¤ºå·²ç»æˆåŠŸå‘ channel å‘é€äº†æ•°æ® return true } send å‘é€æ•°æ®ï¼š\nfunc send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // ... // sg æ˜¯æ¥æ”¶è€…çš„ sudog ç»“æ„ // sg.elem æŒ‡å‘æ¥æ”¶åˆ°çš„å€¼å­˜æ”¾çš„ä½ç½®ï¼Œå¦‚ val \u0026lt;- chï¼ŒæŒ‡çš„å°±æ˜¯ \u0026amp;val if sg.elem != nil { // ç›´æ¥æ‹·è´å†…å­˜åˆ° val \u0026lt;- ch è¡¨è¾¾å¼ä¸­å˜é‡ val æ‰€åœ¨çš„å†…å­˜åœ°å€ï¼ˆ\u0026amp;valï¼‰ä¸Š sendDirect(c.elemtype, sg, ep) sg.elem = nil } // è·å– sudog ä¸Šç»‘å®šçš„ç­‰å¾…æ¥æ”¶çš„ goroutine çš„æŒ‡é’ˆ gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) // å”¤é†’ç­‰å¾…æ¥æ”¶çš„ goroutine goready(gp, skip+1) } goready æ˜¯å°† goroutine çš„çŠ¶æ€æ”¹æˆ runnableï¼Œç„¶åéœ€è¦ç­‰å¾…è°ƒåº¦å™¨çš„è°ƒåº¦ã€‚\nfunc sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { // src æ˜¯å½“å‰ goroutine å‘é€çš„æ•°æ®çš„å†…å­˜åœ°å€ // dst æ˜¯æ¥æ”¶è€…çš„ dst := sg.elem // å†™å±éšœ typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) // æ‹·è´å†…å­˜æ•°æ® memmove(dst, src, t.size) } ä» channel æ¥æ”¶æ•°æ® # Go ä¸­å¯ä»¥ä½¿ç”¨ä¸¤ç§ä¸åŒçš„æ–¹å¼å»æ¥æ”¶ channel ä¸­çš„æ•°æ®ï¼š\ni \u0026lt;- ch i, ok \u0026lt;- ch ç¼–è¯‘å™¨çš„å¤„ç†ååˆ†åˆ«ä¼šè½¬æ¢æˆ chanrecv1ï¼Œchanrecv2ï¼š\n// src/runtime/chan.go func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } ä¸¤ä¸ªæ–¹æ³•æœ€ç»ˆè¿˜æ˜¯è°ƒç”¨äº† chanrecv å‡½æ•°ï¼š\n// src/runtime/chan.go func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // ... // channel æ˜¯ nil if c == nil { // ä¸å¯ä»¥é˜»å¡ï¼Œç›´æ¥è¿”å› if !block { return } // æŒ‚èµ·å½“å‰ goroutine gopark(nil, nil, waitReasonChanReceiveNilChan, traceBlockForever, 2) throw(\u0026#34;unreachable\u0026#34;) } if !block \u0026amp;\u0026amp; empty(c) { if atomic.Load(\u0026amp;c.closed) == 0 { return } if empty(c) { if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } // æ‰§è¡Œæ¥æ”¶æ•°æ®çš„é€»è¾‘ä¹‹å‰ï¼Œå…ˆä¸ºå½“å‰ channel åŠ é” lock(\u0026amp;c.lock) // channel å·²å…³é—­ if c.closed != 0 { // åº•å±‚çš„å¾ªç¯æ•°ç»„ buf ä¸­æ²¡æœ‰å…ƒç´  if c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } // é‡Šæ”¾é” unlock(\u0026amp;c.lock) if ep != nil { // typedmemclr æ ¹æ®ç±»å‹æ¸…ç†ç›¸åº”åœ°å€çš„å†…å­˜ typedmemclr(c.elemtype, ep) } return true, false } } else { // channel æœªå…³é—­ï¼Œå¹¶ä¸”ç­‰å¾…å‘é€é˜Ÿåˆ—é‡Œå­˜åœ¨ goroutine // å‘é€çš„ goroutine è¢«é˜»å¡ï¼Œé‚£æœ‰ä¸¤ç§æƒ…å†µï¼š // 1. è¿™æ˜¯ä¸€ä¸ªéç¼“å†²å‹çš„ channel // 2. ç¼“å†²å‹çš„ channelï¼Œä½†æ˜¯ buf æ»¡äº† // recv ç›´æ¥è¿›è¡Œå†…å­˜æ‹·è´ if sg := c.sendq.dequeue(); sg != nil { recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } } // channel æœªå…³é—­ // ç¼“å†²å‹ channel å¹¶ä¸” buf é‡Œæœ‰å…ƒç´ ï¼Œå¯ä»¥æ­£å¸¸æ¥æ”¶ if c.qcount \u0026gt; 0 { // ç›´æ¥ä»å¾ªç¯æ•°ç»„é‡Œå–å‡ºè¦æ¥æ”¶çš„å…ƒç´  qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } // è¿™é‡Œè¡¨ç¤ºï¼Œä»£ç ä¸­æ²¡æœ‰å¿½ç•¥è¦æ¥æ”¶çš„å€¼ï¼Œä¸æ˜¯ \u0026#34;\u0026lt;- ch\u0026#34;ï¼Œè€Œæ˜¯ \u0026#34;val \u0026lt;- ch\u0026#34;ï¼Œep æŒ‡å‘ val if ep != nil { // æ‹·è´æ•°æ® typedmemmove(c.elemtype, ep, qp) } // æ¸…ç†æ‰å¾ªç¯æ•°ç»„é‡Œç›¸åº”ä½ç½®çš„å€¼ typedmemclr(c.elemtype, qp) // recvx ç´¢å¼• +1 c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } // å…ƒç´ ä¸ªæ•° -1 c.qcount-- unlock(\u0026amp;c.lock) return true, true } // éé˜»å¡æ¥æ”¶ï¼Œé‡Šæ”¾é” // selected è¿”å› falseï¼Œå› ä¸ºæ²¡æœ‰æ¥æ”¶åˆ°å€¼ if !block { unlock(\u0026amp;c.lock) return false, false } // èµ°åˆ°è¿™é‡Œè¯´æ˜ buf æ˜¯ç©ºçš„ // æ²¡æœ‰æ•°æ®å¯æ¥æ”¶ï¼Œé˜»å¡å½“å‰æ¥æ”¶çš„ goroutine // è·å–å½“å‰æ¥æ”¶çš„ goroutine gp := getg() // æ„é€ ä¸€ä¸ª sudog mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // è®¾ç½®è¿™ä¸€æ¬¡é˜»å¡æ¥æ”¶çš„ç›¸å…³ä¿¡æ¯ mysg.elem = ep // å¾…æ¥æ”¶æ•°æ®çš„åœ°å€ mysg.waitlink = nil gp.waiting = mysg mysg.g = gp // å½“å‰æ¥æ”¶çš„ goroutine æŒ‡é’ˆ mysg.isSelect = false // æ˜¯å¦åœ¨ select ä¸­ mysg.c = c // æ¥æ”¶çš„ channel gp.param = nil // å°† sudog æ”¾å…¥åˆ°æ¥æ”¶ç­‰å¾…é˜Ÿåˆ— c.recvq.enqueue(mysg) gp.parkingOnChan.Store(true) // æŒ‚èµ·å½“å‰æ¥æ”¶ goroutine gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceBlockChanRecv, 2) // è¢«å”¤é†’äº† if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success } recv æ¥æ”¶æ•°æ®ï¼š\nfunc recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // æ— ç¼“å†²çš„ channel if c.dataqsiz == 0 { if raceenabled { racesync(c, sg) } // è¿™é‡Œè¡¨ç¤ºï¼Œä»£ç ä¸­æ²¡æœ‰å¿½ç•¥è¦æ¥æ”¶çš„å€¼ï¼Œä¸æ˜¯ \u0026#34;\u0026lt;- ch\u0026#34;ï¼Œè€Œæ˜¯ \u0026#34;val \u0026lt;- ch\u0026#34;ï¼Œep æŒ‡å‘ val if ep != nil { // ç›´æ¥æ‹·è´æ•°æ® recvDirect(c.elemtype, sg, ep) } } else { // ç¼“å†²å‹çš„ channelï¼Œä½†æ˜¯ buf å·²æ»¡ // å°†åº•å±‚çš„å¾ªç¯æ•°ç»„ buf é˜Ÿé¦–çš„å…ƒç´ æ‹·è´åˆ°æ¥æ”¶æ•°æ®çš„åœ°å€ // å°†å‘é€è€…çš„æ•°æ®æ”¾å…¥ buf qp := chanbuf(c, c.recvx) if ep != nil { typedmemmove(c.elemtype, ep, qp) } // å°†å‘é€è€…æ•°æ®æ‹·è´åˆ° buf typedmemmove(c.elemtype, qp, sg.elem) // å¢åŠ  recvx ç´¢å¼• c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx } sg.elem = nil gp := sg.g // é‡Šæ”¾é” unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } // å”¤é†’å‘é€çš„ goroutine goready(gp, skip+1) } å…³é—­ channel # close å…³é—­ channel ä¼šè¢«ç¼–è¯‘å™¨è½¬æ¢æˆ closechan å‡½æ•°ï¼š\n// src/runtime/chan.go#L357 func closechan(c *hchan) { // å…³é—­ä¸€ä¸ª nil çš„ channelï¼Œpanic if c == nil { panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } // å…ˆåŠ é” lock(\u0026amp;c.lock) // é‡å¤å…³é—­ï¼Œpanic if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } // ... // è®¾ç½® channel å…³é—­çš„æ ‡å¿—ä½ c.closed = 1 var glist gList // å°† channel ç­‰å¾…æ¥æ”¶é˜Ÿåˆ—çš„é‡Œ sudog é‡Šæ”¾ for { // ä»æ¥æ”¶é˜Ÿåˆ—é‡Œå–å‡ºä¸€ä¸ª sudog sg := c.recvq.dequeue() // æ¥æ”¶é˜Ÿåˆ—ç©ºäº†ï¼Œè·³å‡ºå¾ªç¯ if sg == nil { break } // if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } // è·å–æ¥æ”¶ goroutine çš„æŒ‡é’ˆ gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } // æ”¾å…¥é“¾è¡¨ glist.push(gp) } // å°† channel ç­‰å¾…å‘é€é˜Ÿåˆ—çš„é‡Œ sudog é‡Šæ”¾ // å¦‚æœå­˜åœ¨ï¼Œè¿™äº› goroutine å°†ä¼š panic // å¯ä»¥æŸ¥çœ‹ chansend å‡½æ•°ä¸­çš„é€»è¾‘ï¼š // å¯¹äºå‘é€è€…ï¼Œå¦‚æœè¢«å”¤é†’å channel å·²å…³é—­ï¼Œåˆ™ä¼š panic for { // ä»å‘é€é˜Ÿåˆ—é‡Œå–å‡ºä¸€ä¸ª sudog sg := c.sendq.dequeue() // å‘é€é˜Ÿåˆ—ç©ºäº†ï¼Œè·³å‡ºå¾ªç¯ if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } // è·å–å‘é€ goroutine çš„æŒ‡é’ˆ gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } // æ”¾å…¥é“¾è¡¨ glist.push(gp) } // é‡Šæ”¾é” unlock(\u0026amp;c.lock) // éå†é“¾è¡¨ï¼Œå”¤é†’æ‰€æœ‰ goroutine for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } recvq å’Œ sendq ä¸­çš„æ‰€æœ‰ goroutine è¢«å”¤é†’åï¼Œä¼šåˆ†åˆ«å»æ‰§è¡Œ chanrecv å’Œ chansend ä¸­ gopark åé¢çš„ä»£ç ã€‚\n"},{"id":31,"href":"/golang-learn/docs/practice/09_gin/","title":"Gin é™æ€æœåŠ¡å™¨","section":"ğŸ› ï¸ å®è·µ","content":" Gin å¦‚ä½•å®ç°å‰ç«¯ç½‘é¡µçš„é™æ€æœåŠ¡å™¨ # Gin ä½œä¸º Web æ¡†æ¶æä¾› API æ¥å£éå¸¸æ–¹ä¾¿ï¼Œä½†æ˜¯åœ¨åŒä¸€ä¸ªé¡¹ç›®ä¸­ï¼Œæ—¢æä¾› API æ¥å£ï¼Œåˆè¦ä½œä¸ºå‰ç«¯ç½‘é¡µçš„é™æ€æœåŠ¡å™¨ï¼Œå°±æ¯”è¾ƒéº»çƒ¦ã€‚é€šå¸¸ Angular (React/Vue) é¡¹ç›®éœ€è¦åœ¨ Nginx æˆ–è€… Tomcat è½¬å‘æ‰å¯ä»¥ã€‚æœ‰äº›å°é¡¹ç›®å¹¶ä¸éœ€è¦å‰åç«¯åˆ†ç¦»ï¼Œå¦‚ä½•è§£å†³ï¼Ÿ\nåˆ©ç”¨ embed æ ‡ç­¾ # Go çš„ 1.16 ç‰ˆæœ¬å¢åŠ äº† embed çš„æ ‡ç­¾ï¼Œå¯ä»¥åˆ©ç”¨è¿™ä¸ªæ ‡ç­¾å°†é™æ€èµ„æºæ‰“åŒ…åˆ°äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚\n. â”œâ”€â”€ config â”œâ”€â”€ controller â”œâ”€â”€ model â”œâ”€â”€ options â”œâ”€â”€ pkg â”‚ â””â”€â”€ response â”‚ â””â”€â”€ response.go â”œâ”€â”€ resources â”‚ â”œâ”€â”€ dist â”‚ â””â”€â”€ html.go â”œâ”€â”€ html.go â”œâ”€â”€ resource.go â”œâ”€â”€ router.go â”œâ”€â”€ server.go â””â”€â”€ store â”œâ”€â”€ audited.go â”œâ”€â”€ groups.go â”œâ”€â”€ mysql.go â”œâ”€â”€ settings.go â”œâ”€â”€ store.go â””â”€â”€ tokens.go ä¸Šé¢é¡¹ç›®çš„ç›®å½•ç»“æ„ä¸­æ³¨æ„è¿™å‡ ä¸ªæ–‡ä»¶ï¼š\nâ”œâ”€â”€ resources â”‚ â”œâ”€â”€ dist â”‚ â””â”€â”€ html.go â”œâ”€â”€ html.go â”œâ”€â”€ resource.go â”œâ”€â”€ router.go dist æ˜¯æ‰“åŒ…å¥½çš„é™æ€èµ„æºã€‚\nhtml.go ä¸ºäº†åé¢æ¸²æŸ“ index.html å’Œé™æ€èµ„æºæä¾›çš„å˜é‡ï¼š\npackage resources import \u0026#34;embed\u0026#34; //go:embed dist/stat-web/index.html var Html []byte //go:embed dist/stat-web var Static embed.FS resource.go å®ç°äº† FS æ¥å£ï¼š\nFS æ¥å£ï¼š\ntype FS interface { // Open opens the named file. // // When Open returns an error, it should be of type *PathError // with the Op field set to \u0026#34;open\u0026#34;, the Path field set to name, // and the Err field describing the problem. // // Open should reject attempts to open names that do not satisfy // ValidPath(name), returning a *PathError with Err set to // ErrInvalid or ErrNotExist. Open(name string) (File, error) } resource.goï¼š\npackage apiserver import ( \u0026#34;embed\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;path\u0026#34; \u0026#34;project/resources\u0026#34; ) type Resource struct { fs embed.FS path string } func NewResource(staticPath string) *Resource { return \u0026amp;Resource{ fs: resources.Static, // resources/html.go ä¸­å®šä¹‰çš„ Static path: staticPath, } } func (r *Resource) Open(name string) (fs.File, error) { // rewrite the static files path fullName := path.Join(r.path, name) // è¿™é‡Œæ‹¼å‡ºé™æ€èµ„æºçš„å®Œæ•´è·¯å¾„ï¼Œæ³¨æ„ windows ä¸‹ä½¿ç”¨ filepath.Joinï¼Œä¼šå¯¼è‡´æ‰¾ä¸åˆ°æ–‡ä»¶ return r.fs.Open(fullName) } html.go ä¸­å®ç°äº† HtmlHandler ç”¨æ¥æ¸²æŸ“ index.htmlï¼š\npackage apiserver import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;project/resources\u0026#34; ) type HtmlHandler struct{} func NewHtmlHandler() *HtmlHandler { return \u0026amp;HtmlHandler{} } // RedirectIndex é‡å®šå‘ func (h *HtmlHandler) RedirectIndex(c *gin.Context) { c.Redirect(http.StatusFound, \u0026#34;/\u0026#34;) return } func (h *HtmlHandler) Index(c *gin.Context) { c.Header(\u0026#34;content-type\u0026#34;, \u0026#34;text/html;charset=utf-8\u0026#34;) c.String(200, string(resources.Html)) return } router.go ä¸­é…ç½®è·¯ç”±ï¼š\nfunc installController(g *gin.Engine) { html := NewHtmlHandler() g.GET(\u0026#34;/\u0026#34;, html.Index) g.StaticFS(\u0026#34;/static\u0026#34;, http.FS(NewResource(\u0026#34;dist/stat-web\u0026#34;))) g.StaticFS(\u0026#34;/assets\u0026#34;, http.FS(NewResource(\u0026#34;dist/stat-web/assets\u0026#34;))) g.NoRoute(html.RedirectIndex) // API æ¥å£ v1 := g.Group(\u0026#34;/api/v1\u0026#34;) { // ... } } ä¸Šé¢çš„è·¯ç”± g.StaticFS(\u0026quot;/static\u0026quot;, http.FS(NewResource(\u0026quot;dist/stat-web\u0026quot;))) ï¼Œè·¯å¾„ä¹‹æ‰€ä»¥æ˜¯ /static æ˜¯å› ä¸ºåœ¨æ‰“åŒ… Angular é¡¹ç›®æ—¶ä½¿ç”¨äº† --deploy-urlï¼š\nassets ç›®å½•ä¸‹ä¼šæœ‰ iconï¼Œimageï¼Œjson ç­‰é™æ€èµ„æºã€‚\næ³¨æ„ index.html ä¸­ link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/x-icon\u0026quot; href=\u0026quot;assets/favicon.ico\u0026quot;ï¼Œhref çš„è·¯å¾„æ˜¯ assets/favicon.icoï¼Œ deploy-url å¹¶ä¸ä¼šç»™ href=\u0026quot;assets/favicon.ico\u0026quot; æ·»åŠ  static å‰ç¼€ã€‚æ‰€ä»¥å¦‚æœæ˜¯ href=\u0026quot;favicon.ico\u0026quot;ï¼Œç¼–è¯‘åä¼šæ‰¾ä¸åˆ°è¯¥æ–‡ä»¶ã€‚\nng build \u0026lt;project\u0026gt; --configuration production --deploy-url /static/ --deploy-url å°†è¢«å¼ƒç”¨ï¼Œä¹‹åéœ€è¦è€ƒè™‘å…¶ä»–æ–¹å¼ã€‚æš‚æ—¶ä¸ä½¿ç”¨ --base-href æ˜¯å› ä¸ºï¼š deploy url å’Œ base href éƒ½å¯ç”¨äºåˆå§‹è„šæœ¬ã€æ ·å¼è¡¨ã€æƒ°æ€§è„šæœ¬å’Œ css èµ„æºã€‚ ä½†æ˜¯ï¼Œå®šä¹‰ base href æœ‰ä¸€äº›ç‹¬æœ‰çš„ä½œç”¨ã€‚ base href å¯ç”¨äºå®šä½ç›¸å¯¹è·¯å¾„æ¨¡æ¿ (HTML) èµ„äº§å’Œé’ˆå¯¹ç›¸å¯¹è·¯å¾„çš„ fetch/XMLHttpRequestsã€‚base href ä¹Ÿå¯ç”¨äºå®šä¹‰ Angular è·¯ç”±å™¨çš„é»˜è®¤åŸºåœ°å€ã€‚\n"},{"id":32,"href":"/golang-learn/docs/basic/09_pointer/","title":"æŒ‡é’ˆ","section":"ğŸš è¯­è¨€åŸºç¡€","content":" æŒ‡é’ˆ # æŒ‡é’ˆå’Œå†…å­˜åœ°å€ä¸èƒ½æ··ä¸ºä¸€è°ˆã€‚å†…å­˜åœ°å€æ˜¯å†…å­˜ä¸­æ¯ä¸ªå­—èŠ‚å•å…ƒçš„å”¯ä¸€ç¼–å·ï¼Œè€ŒæŒ‡é’ˆæ˜¯ä¸€ä¸ªå®ä½“ã€‚æŒ‡é’ˆä¹Ÿä¼šåˆ†é…å†…å­˜ç©ºé—´ï¼Œç›¸å½“äºä¸€ä¸ªä¿å­˜å†…å­˜åœ°å€çš„æ•´å½¢å˜é‡ã€‚\næŒ‡é’ˆçš„é™åˆ¶ # æŒ‡é’ˆä¸èƒ½å‚ä¸è¿ç®— # package main import \u0026#34;fmt\u0026#34; func main() { a := 1 b := a fmt.Println(b) b = \u0026amp;a + 1 } ä¸Šé¢çš„ä»£ç ç¼–è¯‘æ—¶ä¼šæŠ¥é”™ï¼šInvalid operation: \u0026amp;a + 1 (mismatched types *int and untyped int)ã€‚\nè¯´æ˜ Go æ˜¯ä¸å…è®¸å¯¹æŒ‡é’ˆè¿›è¡Œè¿ç®—çš„ã€‚\nä¸åŒç±»å‹çš„æŒ‡é’ˆä¸å…è®¸ç›¸äº’è½¬æ¢ # package main func main() {\tvar a int = 100 var f *float64 f = \u0026amp;a } ä¸Šé¢çš„ä»£ç ç¼–è¯‘æ—¶ä¼šæŠ¥é”™ï¼šCannot use '\u0026amp;a' (type *int) as the type *float64ã€‚\nä¸åŒç±»å‹çš„æŒ‡é’ˆä¸èƒ½æ¯”è¾ƒ # å› ä¸ºä¸åŒç±»å‹çš„æŒ‡é’ˆä¹‹é—´ä¸èƒ½è½¬æ¢ï¼Œæ‰€ä»¥ä¹Ÿä¸èƒ½èµ‹å€¼ã€‚\nä¸åŒç±»å‹çš„æŒ‡é’ˆå˜é‡ä¸èƒ½ç›¸äº’èµ‹å€¼ # åŒæ ·çš„ç”±äºä¸åŒç±»å‹çš„æŒ‡é’ˆä¹‹é—´ä¸èƒ½è½¬æ¢ï¼Œæ‰€ä»¥ä¹Ÿæ²¡æ³•ä½¿ç”¨ == æˆ–è€… != è¿›è¡Œæ¯”è¾ƒã€‚\nuintptr ç±»å‹ # uintptr åªæ˜¯ä¸€ä¸ªæ— ç¬¦å·æ•´å‹ï¼Œç”¨äºå­˜å‚¨å†…å­˜åœ°å€çš„æ•´å½¢å˜é‡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå’Œæ™®é€šçš„æ•´å‹ä¸€æ ·ï¼Œæ˜¯ä¼šè¢« GC å›æ”¶çš„ã€‚\nunsafe.Pointer # ç”±äº Go æŒ‡é’ˆçš„é™åˆ¶ï¼Œæ‰€ä»¥ Go æä¾›äº†å¯ä»¥è¿›è¡Œç±»å‹è½¬æ¢çš„é€šç”¨æŒ‡é’ˆ unsafe.Pointerã€‚\nunsafe.Pointer æ˜¯ç‰¹åˆ«å®šä¹‰çš„ä¸€ç§æŒ‡é’ˆç±»å‹ï¼Œå®ƒæŒ‡å‘çš„å¯¹è±¡å¦‚æœè¿˜æœ‰ç”¨ï¼Œé‚£ä¹ˆæ˜¯ä¸ä¼šè¢« GC å›æ”¶çš„ã€‚\nunsafe.Pointer æ˜¯å„ç§æŒ‡é’ˆç›¸äº’è½¬æ¢çš„æ¡¥æ¢ï¼š\nä»»ä½•ç±»å‹çš„æŒ‡é’ˆ *T å¯ä»¥å’Œ unsafe.Pointer ç›¸äº’è½¬æ¢ã€‚ uintptr å¯ä»¥å’Œ unsafe.Pointer ç›¸äº’è½¬æ¢ã€‚ æŒ‡é’ˆç±»å‹è½¬æ¢ç¤ºä¾‹ï¼š\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { v1 := uint(10) v2 := int(11) fmt.Println(reflect.TypeOf(v1)) // uint fmt.Println(reflect.TypeOf(v2)) // int fmt.Println(reflect.TypeOf(\u0026amp;v1)) // *uint fmt.Println(reflect.TypeOf(\u0026amp;v2)) // *int p := \u0026amp;v1 // ä½¿ç”¨ unsafe.Pointer è¿›è¡Œç±»å‹è½¬æ¢ï¼Œå°† *int è½¬ä¸º *uint p = (*uint)(unsafe.Pointer(\u0026amp;v2)) fmt.Println(reflect.TypeOf(p)) // *unit fmt.Println(*p) // 11 } "},{"id":33,"href":"/golang-learn/docs/concurrency/10_sema/","title":"ä¿¡å·é‡","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" ä¿¡å·é‡ # ä¿¡å·é‡ï¼ˆSemaphoreï¼‰æ˜¯ä¸€ç§ç”¨äºå®ç°å¤šè¿›ç¨‹æˆ–å¤šçº¿ç¨‹ä¹‹é—´åŒæ­¥å’Œäº’æ–¥çš„æœºåˆ¶ã€‚\nä¿¡å·é‡å¯ä»¥ç®€å•ç†è§£ä¸ºä¸€ä¸ªæ•´å‹æ•°ï¼ŒåŒ…å«ä¸¤ç§æ“ä½œï¼šPï¼ˆProberenï¼Œæµ‹è¯•ï¼‰æ“ä½œå’Œ Vï¼ˆVerhogenï¼Œå¢åŠ ï¼‰æ“ä½œã€‚å…¶ä¸­ï¼ŒP æ“ä½œä¼šå°è¯•è·å–ä¸€ä¸ªä¿¡å·é‡ï¼Œå¦‚æœä¿¡å·é‡çš„å€¼å¤§äº 0ï¼Œåˆ™å°†ä¿¡å·é‡çš„å€¼å‡ 1 å¹¶ ç»§ç»­æ‰§è¡Œã€‚å¦åˆ™ï¼Œå½“å‰è¿›ç¨‹æˆ–çº¿ç¨‹å°±ä¼šè¢«é˜»å¡ï¼Œç›´åˆ°æœ‰å…¶ä»–è¿›ç¨‹æˆ–çº¿ç¨‹é‡Šæ”¾è¿™ä¸ªä¿¡å·é‡ä¸ºæ­¢ã€‚V æ“ä½œåˆ™æ˜¯é‡Šæ”¾ä¸€ä¸ªä¿¡å·é‡ï¼Œå°†ä¿¡å·é‡çš„å€¼åŠ  1ã€‚\nP æ“ä½œå’Œ V æ“ä½œå¯ä»¥çœ‹åšæ˜¯å¯¹èµ„æºçš„è·å–å’Œé‡Šæ”¾ã€‚\nGo çš„ WaitGroup å’Œ Metux éƒ½æ˜¯é€šè¿‡ä¿¡å·é‡æ¥æ§åˆ¶ goroutine çš„é˜»å¡å’Œå”¤é†’ï¼Œä¾‹å¦‚ Mutex ç»“æ„ä½“ä¸­çš„ semaï¼š\ntype Mutex struct { state int32 sema uint32 } Metux æœ¬è´¨ä¸Šå°±æ˜¯åŸºäºä¿¡å·é‡ï¼ˆsemaï¼‰+ åŸå­æ“ä½œæ¥å®ç°å¹¶å‘æ§åˆ¶çš„ã€‚\nGo æ“ä½œä¿¡å·é‡çš„æ–¹æ³•ï¼š\n// src/sync/runtime.go // é˜»å¡ç­‰å¾…ç›´åˆ° s å¤§äº 0ï¼Œç„¶åç«‹åˆ»å°† s å‡å» 1 func runtime_Semacquire(s *uint32) // ç±»ä¼¼äº runtime_Semacquire // å¦‚æœ lifo ä¸º trueï¼Œwaiter å°†ä¼šè¢«æ’å…¥åˆ°é˜Ÿåˆ—çš„å¤´éƒ¨ï¼Œå¦åˆ™æ’å…¥åˆ°é˜Ÿåˆ—å°¾éƒ¨ // skipframes æ˜¯è·Ÿè¸ªè¿‡ç¨‹ä¸­è¦çœç•¥çš„å¸§æ•°ï¼Œä»è¿™é‡Œå¼€å§‹è®¡ç®— func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int) // å°† s å¢åŠ  1ï¼Œç„¶åé€šçŸ¥é˜»å¡åœ¨ runtime_Semacquire çš„ goroutine // å¦‚æœ handoff ä¸º trueï¼Œä¼ é€’ä¿¡å·åˆ°é˜Ÿåˆ—å¤´éƒ¨çš„ waiter // skipframes æ˜¯è·Ÿè¸ªè¿‡ç¨‹ä¸­è¦çœç•¥çš„å¸§æ•°ï¼Œä»è¿™é‡Œå¼€å§‹è®¡ç®— func runtime_Semrelease(s *uint32, handoff bool, skipframes int) Acquire å’Œ Release åˆ†åˆ«å¯¹åº”äº† P æ“ä½œå’Œ V æ“ä½œã€‚\nAcquire ä¿¡å·é‡ # // src/runtime/sema.go //go:linkname sync_runtime_Semacquire sync.runtime_Semacquire func sync_runtime_Semacquire(addr *uint32) { semacquire1(addr, false, semaBlockProfile, 0, waitReasonSemacquire) } //go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex func sync_runtime_SemacquireMutex(addr *uint32, lifo bool, skipframes int) { semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes, waitReasonSyncMutexLock) } runtime_Semacquire å’Œ runtime_SemacquireMutex æœ€ç»ˆéƒ½æ˜¯è°ƒç”¨äº† semacquire1 å‡½æ•°ï¼š\nfunc semacquire1(addr *uint32, lifo bool, profile semaProfileFlags, skipframes int, reason waitReason) { gp := getg() if gp != gp.m.curg { throw(\u0026#34;semacquire not on the G stack\u0026#34;) } // Easy case. // ä¿¡å·é‡å¤§äº 0ï¼Œç›´æ¥è¿”å› if cansemacquire(addr) { return } // Harder case: // æ„é€ ä¸€ä¸ª sudog s := acquireSudog() // å°†ä¿¡å·é‡çš„åœ°å€æ”¾åˆ°åˆ° semtable ä¸­ // è¿”å›ä¸€ä¸ª semaRoot ç±»å‹ root := semtable.rootFor(addr) t0 := int64(0) s.releasetime = 0 s.acquiretime = 0 s.ticket = 0 // ... for { lockWithRank(\u0026amp;root.lock, lockRankRoot) // ç­‰å¾…è®¡æ•° +1 root.nwait.Add(1) // å†æ¬¡æ£€æŸ¥ä¿¡å·é‡æ˜¯å¦å¤§äº 0ï¼Œé¿å…é”™è¯¯å”¤é†’ if cansemacquire(addr) { root.nwait.Add(-1) unlock(\u0026amp;root.lock) break } // å°†å½“å‰ goroutine æ”¾å…¥åˆ° semaRoot çš„ç­‰å¾…è€…é˜Ÿåˆ— root.queue(addr, s, lifo) // æŒ‚èµ·å½“å‰ goroutine goparkunlock(\u0026amp;root.lock, reason, traceBlockSync, 4+skipframes) if s.ticket != 0 || cansemacquire(addr) { break } } if s.releasetime \u0026gt; 0 { blockevent(s.releasetime-t0, 3+skipframes) } releaseSudog(s) } cansemacquire å°±æ˜¯åˆ¤æ–­ä¿¡å·é‡çš„å€¼ï¼Œè‹¥ç­‰äº 0ï¼Œåˆ™ç›´æ¥è¿”å› falseï¼Œå¦åˆ™ï¼ŒCAS æ“ä½œä¿¡å·é‡ -1ï¼ŒæˆåŠŸåˆ™è¿”å› trueï¼š\nfunc cansemacquire(addr *uint32) bool { for { v := atomic.Load(addr) // ç­‰äº 0ï¼Œè¡¨ç¤ºæ²¡æœ‰èµ„æº if v == 0 { return false } if atomic.Cas(addr, v, v-1) { return true } } } semtable æ˜¯ä¸€ä¸ª semTable ç±»å‹ï¼ŒsemTable.rootFor è¿”å›çš„æ˜¯ä¸€ä¸ª semaRoot ç±»å‹ï¼š\n// src/runtime/sema.go type semaRoot struct { lock mutex treap *sudog // ç­‰å¾…è€…é˜Ÿåˆ—ï¼ˆå¹³è¡¡æ ‘ï¼‰çš„æ ¹èŠ‚ç‚¹ nwait atomic.Uint32 // ç­‰å¾…è€…çš„æ•°é‡ } var semtable semTable type semTable [semTabSize]struct { root semaRoot pad [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot{})]byte } // rootFor æœ¬è´¨ä¸Šå°±æ˜¯å°† semaRoot ä¸ä¿¡å·é‡ç»‘å®š func (t *semTable) rootFor(addr *uint32) *semaRoot { return \u0026amp;t[(uintptr(unsafe.Pointer(addr))\u0026gt;\u0026gt;3)%semTabSize].root } Release ä¿¡å·é‡ # // src/runtime/sema.go //go:linkname sync_runtime_Semrelease sync.runtime_Semrelease func sync_runtime_Semrelease(addr *uint32, handoff bool, skipframes int) { semrelease1(addr, handoff, skipframes) } runtime_Semrelease æœ€ç»ˆæ˜¯è°ƒç”¨äº† semrelease1ï¼š\nfunc semrelease1(addr *uint32, handoff bool, skipframes int) { // å–å‡ºä¿¡å·é‡å¯¹åº”çš„ semaRoot root := semtable.rootFor(addr) // ä¿¡å·é‡ +1 atomic.Xadd(addr, 1) // Easy case // æ²¡æœ‰ç­‰å¾…è€…ï¼Œç›´æ¥è¿”å› if root.nwait.Load() == 0 { return } // Harder case lockWithRank(\u0026amp;root.lock, lockRankRoot) // å†æ¬¡æ£€æŸ¥ç­‰å¾…è€…è®¡æ•° if root.nwait.Load() == 0 { // è®¡æ•°å·²ç»è¢«å…¶ä»– goroutine æ¶ˆè´¹ï¼Œä¸éœ€è¦å”¤é†’å…¶ä»– goroutine unlock(\u0026amp;root.lock) return } // é˜Ÿå½“å‰ä¿¡å·é‡ä¸Šçš„ sudog s, t0, tailtime := root.dequeue(addr) if s != nil { // ç­‰å¾…è€…è®¡æ•° -1 root.nwait.Add(-1) } unlock(\u0026amp;root.lock) if s != nil { // May be slow or even yield, so unlock first // ... // å”¤é†’ goroutine readyWithTime(s, 5+skipframes) if s.ticket == 1 \u0026amp;\u0026amp; getg().m.locks == 0 { goyield() } } } readyWithTime çš„å®ç°ï¼š\nfunc readyWithTime(s *sudog, traceskip int) { if s.releasetime != 0 { s.releasetime = cputicks() } // è®¾ç½® goroutine çš„çŠ¶æ€ä¸º runnable ç­‰å¾…è¢«é‡æ–°è°ƒåº¦ goready(s.g, traceskip) } semaphore æ‰©å±•åº“ # å‰é¢ Go å¯¹ä¿¡å·é‡çš„å®ç°éƒ½æ˜¯éšè—åœ¨ runtime ä¸­çš„ï¼Œå¹¶æ²¡æœ‰æ ‡å‡†åº“æ¥ä¾›å¤–éƒ¨ä½¿ç”¨ã€‚ä¸è¿‡ Go çš„æ‰©å±•åº“ golang.org/x/sync æä¾›äº† semaphore åŒ…å®ç°çš„ä¿¡å·é‡æ“ä½œã€‚\nä½¿ç”¨ func NewWeighted(n int64) *Weighted æ¥åˆ›å»ºä¿¡å·é‡ã€‚\nWeighted æœ‰ä¸‰ä¸ªæ–¹æ³•ï¼š\nAcquire(ctx contex.Context, n int64) errorï¼šå¯¹åº” P æ“ä½œï¼Œå¯ä»¥ä¸€æ¬¡è·å– n ä¸ªèµ„æºï¼Œå¦‚æœæ²¡æœ‰è¶³å¤Ÿå¤šçš„èµ„æºï¼Œè°ƒç”¨è€…å°±ä¼šè¢«é˜»å¡ã€‚ Release(n int64)ï¼šå¯¹åº” V æ“ä½œï¼Œå¯ä»¥é‡Šæ”¾ n ä¸ªèµ„æºã€‚ TryAcquire(n int64) boolï¼šå°è¯•è·å– n ä¸ªèµ„æºï¼Œä½†æ˜¯å®ƒä¸ä¼šé˜»å¡ï¼ŒæˆåŠŸè·å– n ä¸ªèµ„æºåˆ™è¿”å› trueã€‚å¦åˆ™ä¸€ä¸ªä¹Ÿä¸è·å–ï¼Œè¿”å› falseã€‚ ä½¿ç”¨ # var ( maxWorkers = runtime.GOMAXPROCS(0) // worker æ•°é‡å’Œ CPU æ ¸æ•°ä¸€æ · sema = semaphore.NewWeighted(int64(maxWorkers)) // ä¿¡å·é‡ task = make([]int, maxWorkers*4) // ä»»åŠ¡æ•°ï¼Œæ˜¯ worker çš„å››å€ ) func main() { ctx := context.Background() for i := range task { // å¦‚æœæ²¡æœ‰ worker å¯ç”¨ï¼Œä¼šé˜»å¡åœ¨è¿™é‡Œï¼Œç›´åˆ°æŸä¸ª worker è¢«é‡Šæ”¾ if err := sema.Acquire(ctx, 1); err != nil { break } // å¯åŠ¨ worker goroutine go func(i int) { defer sema.Release(1) time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿä¸€ä¸ªè€—æ—¶æ“ä½œ task[i] = i + 1 }(i) } // è·å–æœ€å¤§è®¡æ•°å€¼çš„ä¿¡å·é‡ï¼Œè¿™æ ·èƒ½ç¡®ä¿å‰é¢çš„ worker éƒ½æ‰§è¡Œå®Œ if err := sema.Acquire(ctx, int64(maxWorkers)); err != nil { log.Printf(\u0026#34;è·å–æ‰€æœ‰çš„ worker å¤±è´¥: %v\u0026#34;, err) } fmt.Println(task) } åŸç† # Weighted æ˜¯ä½¿ç”¨äº’æ–¥é”å’Œ List å®ç°çš„ï¼Œä¿¡å·é‡ semaphore.Weighted çš„ç»“æ„ä½“ï¼š\ntype Weighted struct { size int64 // æœ€å¤§èµ„æºæ•° cur int64 // å½“å‰å·²è¢«ä½¿ç”¨çš„èµ„æº mu sync.Mutex // äº’æ–¥é”ï¼Œä¿è¯å¹¶å‘å®‰å…¨ waiters list.List // ç­‰å¾…è€…é˜Ÿåˆ— } List å®ç°äº†ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œç­‰å¾…è€…çš„é€šçŸ¥æ˜¯é€šè¿‡ channel å®ç°çš„ã€‚\nAcquire å®ç°ï¼š\nfunc (s *Weighted) Acquire(ctx context.Context, n int64) error { s.mu.Lock() // å‰©ä½™çš„èµ„æºå¤§äº nï¼Œç›´æ¥è¿”å› if s.size-s.cur \u0026gt;= n \u0026amp;\u0026amp; s.waiters.Len() == 0 { // å·²è¢«ä½¿ç”¨çš„èµ„æº +n s.cur += n s.mu.Unlock() return nil } // è¯·æ±‚çš„èµ„æºæ•° n å¤§äºæœ€å¤§çš„èµ„æºæ•° size if n \u0026gt; s.size { s.mu.Unlock() // ä¾èµ– ctx çš„çŠ¶æ€è¿”å›ï¼Œå¦åˆ™ä¼šä¸€ç›´é˜»å¡ \u0026lt;-ctx.Done() return ctx.Err() } // èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜èµ„æºä¸è¶³ // æŠŠè°ƒç”¨è€…åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ // åˆ›å»ºä¸€ä¸ª ready chan,ä»¥ä¾¿è¢«é€šçŸ¥å”¤é†’ ready := make(chan struct{}) w := waiter{n: n, ready: ready} // æ’å…¥åˆ°é˜Ÿåˆ—å°¾éƒ¨ï¼Œelem æ˜¯æ–°æ’å…¥çš„å…ƒç´  elem := s.waiters.PushBack(w) s.mu.Unlock() // é˜»å¡ç­‰å¾…ï¼Œç›´åˆ° ctx è¢«å–æ¶ˆæˆ–è€…è¶…æ—¶ï¼Œæˆ–è€…è¢«å”¤é†’ select { case \u0026lt;-ctx.Done(): // ctx è¢«å–æ¶ˆæˆ–è€…è¶…æ—¶ err := ctx.Err() s.mu.Lock() select { case \u0026lt;-ready: // è¢«å”¤é†’äº†ï¼Œé‚£ä¹ˆå°±å¿½ç•¥ ctx çš„çŠ¶æ€ err = nil default: // s.waiters.Front() å–å‡ºé˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ª ç­‰å¾…è€… isFront := s.waiters.Front() == elem // ç›´æ¥ç§»é™¤å½“å‰ ç­‰å¾…è€… s.waiters.Remove(elem) // è¿˜æœ‰èµ„æºï¼Œé€šçŸ¥å…¶å®ƒçš„ ç­‰å¾…è€… if isFront \u0026amp;\u0026amp; s.size \u0026gt; s.cur { s.notifyWaiters() } } s.mu.Unlock() return err case \u0026lt;-ready: // è¢«å”¤é†’äº† return nil } } Release çš„å®ç°ï¼š\nfunc (s *Weighted) Release(n int64) { s.mu.Lock() // å·²è¢«ä½¿ç”¨çš„èµ„æº -n s.cur -= n if s.cur \u0026lt; 0 { s.mu.Unlock() panic(\u0026#34;semaphore: released more than held\u0026#34;) } // å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­ç­‰å¾…è€… s.notifyWaiters() s.mu.Unlock() } notifyWaiters å°±æ˜¯éå†ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ç­‰å¾…è€…ï¼Œå¦‚æœèµ„æºä¸å¤Ÿï¼Œæˆ–è€…ç­‰å¾…é˜Ÿåˆ—æ˜¯ç©ºçš„ï¼Œå°±è¿”å›ï¼š\nfunc (s *Weighted) notifyWaiters() { for { next := s.waiters.Front() // æ²¡æœ‰ç­‰å¾…è€…äº† if next == nil { break // No more waiters blocked. } w := next.Value.(waiter) // èµ„æºä¸è¶³ï¼Œé€€å‡º // s.waiters.Front() æ˜¯ä»¥å…ˆå…¥å…ˆå‡ºçš„æ–¹å¼å–å‡ºç­‰å¾…è€…ï¼Œå¦‚æœç¬¬ä¸€ä¸ªç­‰å¾…è€…æ²¡æœ‰è¶³å¤Ÿçš„èµ„æºï¼Œé‚£ä¹ˆé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰ç­‰å¾…è€…éƒ½ä¼šç»§ç»­ç­‰å¾… if s.size-s.cur \u0026lt; w.n { break } // èµ„æºè¶³å¤Ÿ // å·²è¢«ä½¿ç”¨çš„èµ„æº +n s.cur += w.n // å°†ç­‰å¾…è€…ç§»å‡ºé˜Ÿåˆ— s.waiters.Remove(next) // å…³é—­ channelï¼Œå”¤é†’ç­‰å¾…è€… close(w.ready) } } "},{"id":34,"href":"/golang-learn/docs/concurrency/11_singleflight/","title":"SingleFlight","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" SingleFlight # Go çš„æ‰©å±•åº“ golang.org/x/sync æä¾›äº† singleflight åŒ…ï¼Œå®ƒçš„ä½œç”¨åœ¨å¤„ç†å¤šä¸ª goroutine åŒæ—¶è°ƒç”¨åŒä¸€ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œåªè®©ä¸€ä¸ª goroutine å»è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œç­‰åˆ°è¿™ä¸ª goroutine è¿”å›ç»“æœæ—¶ï¼Œå†æŠŠç»“ æœè¿”å›ç»™è¿™å‡ ä¸ª goroutineï¼Œè¿™æ ·å¯ä»¥å‡å°‘å¹¶å‘è°ƒç”¨çš„æ•°é‡ã€‚\nä¸€ä¸ªå¸¸è§çš„ä½¿ç”¨åœºæ™¯ï¼šåœ¨ä½¿ç”¨ Redis å¯¹æ•°æ®åº“ä¸­çš„æ•°æ®è¿›è¡Œç¼“å­˜ï¼Œå¦‚æœå‘ç”Ÿç¼“å­˜å‡»ç©¿ï¼Œå¤§é‡çš„æµé‡éƒ½ä¼šæ‰“åˆ°åç«¯æ•°æ®åº“ä¸Šï¼Œå¯¼è‡´åç«¯æœåŠ¡å“åº”å»¶æ—¶ç­‰é—®é¢˜ã€‚ singleflight å¯ä»¥å°†å¯¹åŒä¸€ä¸ª key çš„å¤šä¸ªè¯·æ±‚åˆå¹¶ä¸ºä¸€ä¸ªï¼Œå‡è½»åç«¯æœåŠ¡çš„å‹åŠ›ã€‚\nä½¿ç”¨ # package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/sync/singleflight\u0026#34; ) func GetValueFromRedis(key string) string { fmt.Println(\u0026#34;query ...\u0026#34;) time.Sleep(10 * time.Second) // æ¨¡æ‹Ÿä¸€ä¸ªæ¯”è¾ƒè€—æ—¶çš„æ“ä½œ return \u0026#34;singleflight demo\u0026#34; } func main() { requestGroup := new(singleflight.Group) cachekey := \u0026#34;demokey\u0026#34; go func() { v1, _, shared := requestGroup.Do(cachekey, func() (interface{}, error) { ret := GetValueFromRedis(cachekey) return ret, nil }) fmt.Printf(\u0026#34;1st call: v1: %v, shared: %v\\n\u0026#34;, v1, shared) }() time.Sleep(2 * time.Second) // é‡å¤æŸ¥è¯¢ keyï¼Œç¬¬ä¸€æ¬¡æŸ¥è¯¢è¿˜æœªç»“æŸ v2, _, shared := requestGroup.Do(cachekey, func() (interface{}, error) { ret := GetValueFromRedis(cachekey) return ret, nil }) fmt.Printf(\u0026#34;2nd call: v2:%v, shared:%v\\n\u0026#34;, v2, shared) } è¾“å‡ºï¼š\nquery ... 1st call: v1: singleflight demo, shared:true 2nd call: v2: singleflight demo, shared:true query ... åªæ‰“å°äº†ä¸€æ¬¡ï¼Œè¯·æ±‚è¢«åˆå¹¶äº†ã€‚\nsingleflight.Group æä¾›äº†ä¸‰ä¸ªæ–¹æ³•ï¼š\nDoï¼šæ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ª keyï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚åŒä¸€ä¸ª key å¯¹åº”çš„å‡½æ•°ï¼Œåœ¨åŒä¸€æ—¶é—´åªä¼šæœ‰ä¸€ä¸ªåœ¨æ‰§è¡Œï¼Œå…¶ä»–çš„å¹¶å‘æ‰§è¡Œçš„è¯·æ±‚ä¼šç­‰å¾…ã€‚å½“ç¬¬ä¸€ä¸ªæ‰§è¡Œçš„å‡½æ•°è¿”å›ç»“æœ å…¶ä»–çš„å¹¶å‘è¯·æ±‚ä¼šä½¿ç”¨è¿™ä¸ªç»“æœã€‚ DoChanï¼šå’Œ Do æ–¹æ³•å·®ä¸å¤šï¼Œåªä¸è¿‡æ˜¯è¿”å›ä¸€ä¸ª channelï¼Œå½“æ‰§è¡Œçš„å‡½æ•°è¿”å›ç»“æœæ—¶ï¼Œå°±å¯ä»¥ä»è¿™ä¸ª channel ä¸­æ¥æ”¶è¿™ä¸ªç»“æœã€‚ Forgetï¼šåœ¨ Group çš„æ˜ å°„è¡¨ä¸­åˆ é™¤æŸä¸ª keyã€‚æ¥ä¸‹æ¥è¿™ä¸ª key çš„è¯·æ±‚å°±ä¸ä¼šç­‰å¾…å‰ä¸€ä¸ªæœªå®Œæˆçš„å‡½æ•°çš„è¿”å›ç»“æœäº†ã€‚ åŸç† # singleflight.Group çš„ç»“æ„ä½“ï¼š\ntype Group struct { mu sync.Mutex m map[string]*call } // ä»£è¡¨ä¸€ä¸ªæ­£åœ¨å¤„ç†çš„è¯·æ±‚ï¼Œæˆ–è€…å·²ç»å¤„ç†å®Œçš„è¯·æ±‚ type call struct { wg sync.WaitGroup // val å’Œ err åªä¼šåœ¨æ‰§è¡Œä¼ å…¥çš„å‡½æ•°æ—¶èµ‹å€¼ä¸€æ¬¡å¹¶åœ¨ WaitGroup.Wait è¿”å›æ—¶è¢«è¯»å– val interface{} err error // æŠ‘åˆ¶çš„è¯·æ±‚æ•°é‡ dups int // ç”¨äºåŒæ­¥ç»“æœ chans []chan\u0026lt;- Result } Do çš„å®ç°ï¼š\nfunc (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) { g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { // å­˜åœ¨ç›¸åŒçš„ key c.dups++ g.mu.Unlock() c.wg.Wait() // ç­‰å¾…è¿™ä¸ª key çš„ç¬¬ä¸€ä¸ªè¯·æ±‚å®Œæˆ return c.val, c.err, true // ä½¿ç”¨ key çš„è¯·æ±‚ç»“æœ } // ç¬¬ä¸€ä¸ªè¯·æ±‚ï¼Œåˆ›å»ºä¸€ä¸ª call c := new(call) c.wg.Add(1) // å°† key æ”¾åˆ° map g.m[key] = c g.mu.Unlock() // æ‰§è¡Œå‡½æ•° g.doCall(c, key, fn) return c.val, c.err, c.dups \u0026gt; 0 } func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) { // æ‰§è¡Œå‡½æ•° // å°†å‡½æ•°çš„è¿”å›å€¼èµ‹å€¼ç»™ c.val å’Œ c.err c.val, c.err = fn() // å½“å‰å‡½æ•°å·²ç»æ‰§è¡Œå®Œæˆï¼Œé€šçŸ¥æ‰€æœ‰ç­‰å¾…ç»“æœçš„ goroutine å¯ä»¥ä» call ç»“æ„ä½“ä¸­å–å‡ºè¿”å›å€¼å¹¶è¿”å›äº† c.wg.Done() g.mu.Lock() // ä» map ä¸­åˆ é™¤å·²ç»æ‰§è¡Œä¸€æ¬¡çš„ key delete(g.m, key) // å°†ç»“æœé€šè¿‡ channel åŒæ­¥ç»™ä½¿ç”¨ DoChan çš„ goroutine for _, ch := range c.chans { ch \u0026lt;- Result{c.val, c.err, c.dups \u0026gt; 0} } g.mu.Unlock() } "},{"id":35,"href":"/golang-learn/docs/concurrency/12_errorgroup/","title":"ErrGroup","section":"âš¡ å¹¶å‘ç¼–ç¨‹","content":" ErrGroup # Go çš„æ‰©å±•åº“ golang.org/x/sync æä¾›äº† errgroup åŒ…ï¼Œå®ƒæ˜¯åŸºäº WaitGroup å®ç°çš„ï¼ŒåŠŸèƒ½ä¸Šå’Œ WaitGroup ç±»ä¼¼ï¼Œä¸è¿‡å¯ä»¥é€šè¿‡ä¸Šä¸‹æ–‡å–æ¶ˆï¼Œæ§åˆ¶å¹¶å‘æ•°é‡ï¼Œè¿˜èƒ½è¿”å›é”™è¯¯ã€‚\nä½¿ç”¨ # æœ€ç®€å•çš„ä½¿ç”¨æ–¹å¼ï¼š\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; ) func main() { var g errgroup.Group // g, ctx := errgroup.WithContext(context.Background()) g.Go(func() error { time.Sleep(5 * time.Second) fmt.Println(\u0026#34;exec 1\u0026#34;) return nil }) g.Go(func() error { time.Sleep(10 * time.Second) fmt.Println(\u0026#34;exec 2\u0026#34;) return errors.New(\u0026#34;failed to exec 2\u0026#34;) }) if err := g.Wait(); err == nil { fmt.Println(\u0026#34;exec done\u0026#34;) } else { fmt.Println(\u0026#34;failed: \u0026#34;, err) } } errgroup.WithContext è¿”å›ä¸€ä¸ª Group å®ä¾‹ï¼ŒåŒæ—¶è¿˜ä¼šè¿”å›ä¸€ä¸ªä½¿ç”¨ context.WithCancel(ctx) ç”Ÿæˆçš„æ–° Contextã€‚ Group.Go æ–¹æ³•èƒ½å¤Ÿåˆ›å»ºä¸€ä¸ª goroutine å¹¶åœ¨å…¶ä¸­æ‰§è¡Œä¼ å…¥çš„å‡½æ•° Group.Wait ä¼šç­‰å¾…æ‰€æœ‰ goroutine å…¨éƒ¨è¿”å›ï¼Œè¯¥æ–¹æ³•çš„ä¸åŒè¿”å›ç»“æœä¹Ÿæœ‰ä¸åŒçš„å«ä¹‰ï¼š å¦‚æœè¿”å› errorï¼Œé‚£ä¹ˆè¿™ç»„ goroutine è‡³å°‘æœ‰ä¸€ä¸ªè¿”å›äº† errorã€‚ å¦‚æœè¿”å› nilï¼Œè¡¨ç¤ºæ‰€æœ‰ goroutine éƒ½æˆåŠŸæ‰§è¡Œã€‚ é™åˆ¶ goroutine çš„å¹¶å‘æ•°é‡ # package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; ) func main() { var g errgroup.Group g.SetLimit(2) g.TryGo(func() error { time.Sleep(5 * time.Second) fmt.Println(\u0026#34;exec 1\u0026#34;) return nil }) g.TryGo(func() error { time.Sleep(10 * time.Second) fmt.Println(\u0026#34;exec 2\u0026#34;) return errors.New(\u0026#34;failed to exec 2\u0026#34;) }) if err := g.Wait(); err == nil { fmt.Println(\u0026#34;exec done\u0026#34;) } else { fmt.Println(\u0026#34;failed: \u0026#34;, err) } } Group.SetLimit è®¾ç½®å¹¶å‘æ•°é‡ã€‚ Group.TryGo æ›¿æ¢ Group.Go æ–¹æ³•ã€‚ åŸç† # errgroup.Group çš„ç»“æ„ä½“ï¼š\ntype Group struct { cancel func(error) // åˆ›å»º context.Context æ—¶è¿”å›çš„å–æ¶ˆå‡½æ•°ï¼Œç”¨äºåœ¨å¤šä¸ª goroutine ä¹‹é—´åŒæ­¥å–æ¶ˆä¿¡å· wg sync.WaitGroup // ç”¨äºç­‰å¾…ä¸€ç»„ goroutine çš„å®Œæˆ sem chan token // åˆ©ç”¨è¿™ä¸ª channel çš„ç¼“å†²åŒºå¤§å°ï¼Œæ¥æ§åˆ¶å¹¶å‘çš„æ•°é‡ errOnce sync.Once // ä¿è¯åªæ¥æ”¶ä¸€ä¸ª goroutine è¿”å›çš„é”™è¯¯ err error } errgroup çš„å®ç°å¾ˆç®€å•ï¼š\nfunc (g *Group) done() { if g.sem != nil { // ä» channel è·å–ä¸€ä¸ªå€¼ï¼Œé‡Šæ”¾èµ„æº \u0026lt;-g.sem } // WaitGroup å¹¶å‘æ•°é‡ -1 g.wg.Done() } // golang/sync/errgroup/errgroup.go func WithContext(ctx context.Context) (*Group, context.Context) { ctx, cancel := withCancelCause(ctx) return \u0026amp;Group{cancel: cancel}, ctx } func (g *Group) Go(f func() error) { // g.sem çš„å€¼ä¸ä¸º nilï¼Œè¯´æ˜è°ƒç”¨äº† SetLimit è®¾ç½®å¹¶å‘æ•°é‡ if g.sem != nil { // å°è¯•ä» channel å‘é€ä¸€ä¸ªå€¼ // - å‘é€æˆåŠŸï¼Œç¼“å†²åŒºè¿˜æ²¡æœ‰æ»¡ï¼Œæ„å‘³ç€å¹¶å‘æ•°è¿˜æ²¡æœ‰è¾¾åˆ° SetLimit è®¾ç½®çš„æ•°é‡ // - å‘é€ä¸æˆåŠŸï¼Œç¼“å†²åŒºå·²æ»¡ï¼Œé˜»å¡åœ¨è¿™é‡Œï¼Œç­‰å¾…å…¶ä»– goroutine é‡Šæ”¾ä¸€ä¸ªèµ„æº g.sem \u0026lt;- token{} } // è°ƒç”¨ WaitGroup.Add å¹¶å‘æ•°é‡ +1 g.wg.Add(1) // åˆ›å»ºæ–°çš„ goroutine è¿è¡Œä¼ å…¥çš„å‡½æ•° go func() { defer g.done() if err := f(); err != nil { g.errOnce.Do(func() { // è¿”å›é”™è¯¯æ—¶ï¼Œè°ƒç”¨ context çš„ cancel å¹¶å¯¹ err èµ‹å€¼ g.err = err if g.cancel != nil { g.cancel(g.err) } }) } }() } func (g *Group) Wait() error { // åªæ˜¯è°ƒç”¨äº† WaitGroup.Wait g.wg.Wait() // åœ¨æ‰€æœ‰ goroutine å®Œæˆæ—¶ï¼Œå–æ¶ˆ context if g.cancel != nil { g.cancel(g.err) } return g.err } é™åˆ¶ goroutine å¹¶å‘æ•°é‡çš„å®ç°ï¼š\nfunc (g *Group) SetLimit(n int) { // å°äº 0 æ—¶ï¼Œç›´æ¥ç»™ g.sem èµ‹å€¼ä¸º nilï¼Œè¡¨ç¤ºä¸é™åˆ¶å¹¶å‘æ•°é‡ if n \u0026lt; 0 { g.sem = nil return } // å·²æœ‰ goroutine è¿è¡Œæ—¶ï¼Œä¸èƒ½åœ¨è®¾ç½®å¹¶å‘æ•°é‡ if len(g.sem) != 0 { panic(fmt.Errorf(\u0026#34;errgroup: modify limit while %v goroutines in the group are still active\u0026#34;, len(g.sem))) } // åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º n çš„æœ‰ç¼“å†² channel g.sem = make(chan token, n) } func (g *Group) TryGo(f func() error) bool { // ä¸ Go æ–¹æ³•çš„ä¸»è¦åŒºåˆ«ï¼Œå°±åœ¨å¯¹ sem çš„å¤„ç†ä¸Š // å°è¯•è·å–èµ„æºï¼Œå½“æ— æ³•æ‹¿åˆ°èµ„æºæ—¶ï¼Œç›´æ¥è¿”å› falseï¼Œè¡¨ç¤ºæ‰§è¡Œå¤±è´¥ if g.sem != nil { select { case g.sem \u0026lt;- token{}: // Note: this allows barging iff channels in general allow barging. default: return false } } // è°ƒç”¨ WaitGroup.Add å¹¶å‘ä»»åŠ¡ +1 g.wg.Add(1) go func() { defer g.done() if err := f(); err != nil { g.errOnce.Do(func() { g.err = err if g.cancel != nil { g.cancel(g.err) } }) } }() return true } "}]