<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>主要内容 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/</link><description>Recent content in 主要内容 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 编译</title><link>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</guid><description>Go 编译 # 条件编译 # Go 支持两种条件编译方式：
编译标签（build tag） 文件后缀 编译标签 # 编译标签的规则：
空格表示：AND 逗号表示：OR ! 表示：NOT 换行表示：AND 每个条件项的名字用 &amp;ldquo;字母+数字&amp;rdquo; 表示。主要支持以下几种条件：
操作系统，例如：windows、linux 等，对应 runtime.GOOS 的值。 计算机架构，例如：amd64、386，对应 runtime.GOARCH 的值。 编译器，例如：gccgo、gc，是否开启 CGO,cgo。 Go 版本，例如：go1.19、go1.20 等。 自定义的标签，例如：编译时通过指定 -tags 传入的值。 //go:build ignore，编译时自动忽略该文件 go:build 之后必须有空行，否则会被编译器当做普通注释。
//go:build linux,386 darwin,!cgo package testpkg 运算表达式为：(linux &amp;amp;&amp;amp; 386) || (darwin &amp;amp;&amp;amp; !cgo)。
自定义 tag 只需要在 go build 指令后用 -tags 指定编译条件即可
go build -tags mytag1 mytag2 对于 -tags，多个标签既可以用逗号分隔，也可以用空格分隔，但它们都表示&amp;quot;与&amp;quot;的关系。早期 go 版本用空格分隔，后来改成了用逗号分隔，但空格依然可以识别。</description></item><item><title>互斥锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</guid><description>互斥锁 # Go 的标准库 sync 提供了两种锁类型：sync.Mutex 和 sync.RWMutex，前者是互斥锁（排他锁），后者是读写锁。
互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。
Go 定义的锁接口只有两个方法：
type Locker interface { Lock() // 请求锁 Unlock() // 释放锁 } 使用 # import &amp;#34;sync&amp;#34; var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() defer mu.Unlock() balance = balance + amount } func Balance() int { mu.Lock() defer mu.Unlock() b := balance return b } 当已经有 goroutine 调用 Lock 方法获得了这个锁，再有 goroutine 请求这个锁就会阻塞在 Lock 方法的调用上， 直到持有这个锁的 goroutine 调用 UnLock 释放这个锁。</description></item><item><title>基础数据类型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</guid><description>数值类型 # 整型 # uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数 # float32 和 float64 的算术规范由 IEEE-754 浮点数国际标准定义。</description></item><item><title>项目的目录结构</title><link>https://shipengqi.github.io/golang-learn/docs/project/01_structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/01_structure/</guid><description> 项目的目录结构 # 平铺式结构 # project-layout #</description></item><item><title>Commit 规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/02_commitizen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/02_commitizen/</guid><description> Commit 规范 #</description></item><item><title>Go 数据竞争检测器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</guid><description>Go 数据竞争检测器 # 数据竞争是并发系统中最常见，同时也最难处理的 Bug 类型之一。数据竞争会在两个 goroutine 并发访问同一个变量，且至少有一个访问为写入时产生。
这个数据竞争的例子可导致程序崩溃和内存数据损坏（memory corruption）。
package main import &amp;#34;fmt&amp;#34; func main() { c := make(chan bool) m := make(map[string]string) go func() { m[&amp;#34;1&amp;#34;] = &amp;#34;a&amp;#34; // 第一个冲突的访问 c &amp;lt;- true }() m[&amp;#34;2&amp;#34;] = &amp;#34;b&amp;#34; // 第二个冲突的访问 &amp;lt;-c for k, v := range m { fmt.Println(k, v) } } 运行 go run -race ./main.go 或者 go build -race ./main.go 编译后再运行会抛出类似的错误：
================== WARNING: DATA RACE Write at 0x00c00010a090 by goroutine 7: runtime.</description></item><item><title>数组</title><link>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</guid><description> 数组 # 数组是一个由固定长度，相同类型的元素组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，并且可以利用索引快速访问数组中的元素。
初始化 # arr1 := [3]int{1, 2, 3} arr2 := [...]int{1, 2, 3} // `...` 省略号，表示数组的长度是根据初始化值的个数来计算 数组的长度在编译阶段确定，初始化之后大小就无法改变。
数组是否应该在堆栈中初始化在编译期就确定了。
根据数组大小：
当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上。 当元素数量大于 4 个时，会将数组中的元素放置到静态区，并在运行时取出。</description></item><item><title>读写锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</guid><description>读写锁 # 读写互斥锁 sync.RWMutex 是细粒度的互斥锁，一般来说有几种情况：
读锁之间不互斥 写锁之间是互斥的 写锁与读锁是互斥的 sync.RWMutex 类型中的 Lock 方法和 Unlock 方法用于对写锁进行锁定和解锁，RLock 方法和 RUnlock 方法则分别用于对读锁进行锁定和解锁。
原理 # type RWMutex struct { w Mutex // 复用互斥锁提供的能力，解决多个 writer 的竞争 writerSem uint32 // writer 的信号量 readerSem uint32 // reader 的信号量 readerCount atomic.Int32 // 正在执行的 reader 的数量 readerWait atomic.Int32 // 当写操作被阻塞时需要等待 read 完成的 reader 的数量 } const rwmutexMaxReaders = 1 &amp;lt;&amp;lt; 30 rwmutexMaxReaders：定义了最大的 reader 数量。
RLock 和 RUnlock # 移除了 race 等无关紧要的代码：</description></item><item><title>WaitGroup</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</guid><description>WaitGroup # sync.WaitGroup 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。
使用 # 并发发送 HTTP 请求的示例：
requests := []*Request{...} wg := &amp;amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r) }(request) } wg.Wait() WaitGroup 提供了三个方法：
Add：用来设置 WaitGroup 的计数值。 Done：用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。 Wait：调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。 不要把 Add 和 Wait 方法的调用放在不同的 goroutine 中执行，以免 Add 还未执行，Wait 已经退出：
var wg sync.WaitGroup go func(){ wg.</description></item><item><title>切片</title><link>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</guid><description>切片 # 切片 (slice) 在使用上和数组差不多，区别是切片是可变长的，定义的时候不需要指定 size。
切片可以看做是对数组的一层简单的封装，切片的底层数据结构中，包含了一个数组。
切片的结构体：
// src/reflect/value.go type SliceHeader struct { Data uintptr // 指向底层数组 Len int // 当前切片长度 Cap int // 当前切片容量 } 注意 Cap 也是底层数组的长度。Data 是一块连续的内存，可以存储切片 Cap 大小的所有元素。
如图，虽然 slice 的 Len 是 5，但是底层数组的长度是 10，也就是 Cap。
初始化 # 初始化切片有三种方式：
使用 make // len 是切片的初始长度 // capacity 为可选参数, 指定容量 s := make([]int, len, capacity) 使用字面量 arr :=[]int{1,2,3} 使用下标截取数组或者切片的一部分，这里可以传入三个参数 [low:high:max]，max - low 是新的切片的容量 cap。 numbers := []int{0,1,2,3,4,5,6,7,8} s := numbers[1:4] // [1 2 3] s := numbers[4:] // [4 5 6 7 8] s := numbers[:3]) // [0 1 2] 《Go 学习笔记》 第四版 中的示例：</description></item><item><title>版本规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/03_gsemver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/03_gsemver/</guid><description>版本规范 # gsemver 是一个用 Go（Golang）开发的命令行工具，它使用 git commit 来自动生成符合 semver 2.0.0 规范的下一个版本。
安装 # $ go install github.com/arnaud-deprez/gsemver@latest 使用 # 下面的命令会使用 git commit 生成下一个 version：
gsemver bump 配置 # 你可以使用一个配置文件来定义你自己的规则。默认情况下，会寻找 .gsemver.yaml 或 $HOME/.gsemver.yaml，可以通过 --config（或 -c）选项来指定你自己的配置文件。</description></item><item><title>Git 工作流程</title><link>https://shipengqi.github.io/golang-learn/docs/project/04_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/04_flow/</guid><description> Git 工作流程 #</description></item><item><title>Go 性能分析</title><link>https://shipengqi.github.io/golang-learn/docs/practice/04_pprof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/04_pprof/</guid><description>Go 性能分析 # PProf 是 Go 提供的用于可视化和分析性能分析数据的工具。
runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析 主要可以用于：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期 时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 性能分析 # 分析 HTTP Server # Web # import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; ) var datas []string func Add(str string) string { data := []byte(str) sData := string(data) datas = append(datas, sData) return sData } func main() { go func() { for { log.</description></item><item><title>哈希表</title><link>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</guid><description>哈希表 # map 是一个无序的 key/value 对的集合，同一个 key 只会出现一次。
哈希表的设计原理 # 哈希表其实是数组的扩展。哈希表是利用数组可以根据下标随机访问（时间复杂度是 O(1)）这一特性来实现快速查找的。
哈希函数 # 哈希表是通过哈希函数将 key 转化为数组的下标，然后将数据存储在数组下标对应的位置。查询时，也是同样的使用哈希函数计算出数组下标，从下标对应的位置取出数据。
哈希函数的基本要求：
哈希函数计算出来的值是一个非负整数。 如果 key1 == key2 那么 hash(key1) == hash(key2) 如果 key1 != key2 那么 hash(key1) != hash(key2) 第三点，想要实现一个不同的 key 对应的哈希值绝对不一样的哈希函数，几乎是不可能的，也就说无法避免哈希冲突。
常用的处理哈希冲突的方法有两种：开放寻址法和链表法。
开放寻址法 # 开放寻址法核心思想是，如果出现了哈希冲突，就重新探测一个空闲位置，将其插入。
上图蓝色表示已经插入的元素，key9 哈希后得到的数组下标为 6，但是已经有数据了，产生了冲突。那么就按顺序向后查找直到找到一个空闲的位置，如果到数组的尾部都没有找到空闲的位置，就从头开始继续找。 上图最终找到位置 1 并插入元素。
查找的逻辑和插入类似，从哈希函数计算出来的下标位置开始查找，比较数组中下标位置的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。直到找到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。
可以看出当数组中空闲位置不多的时候，哈希冲突的概率就会大大提高。装载因子（load factor）就是用来表示空位的多少。
装载因子=已插入的元素个数/哈希表的长度 装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。
链表法 # 链表法是最常见的哈希冲突的解决办法。在哈希表中，每个桶（bucket）会对应一条链表，所有哈希值相同的元素都放到相同桶对应的链表中。
插入时，哈希函数计算后得出存放在几号桶，然后遍历桶中的链表了：
找到键相同的键值对，则更新键对应的值； 没有找到键相同的键值对，则在链表的末尾追加新的键值对 链表法实现的哈希表的装载因子：
装载因子=已插入的元素个数/桶数量 Go map 原理 # 表示 map 的结构体是 hmap：</description></item><item><title>条件变量</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</guid><description>条件变量 # Go 标准库提供了条件变量 sync.Cond 它可以让一组的 goroutine 都在满足特定条件时被唤醒。
sync.Cond 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 for {} 进行忙碌等待相比，sync.Cond 能够让出处理器的使用权，提高 CPU 的利用率。
sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么？
互斥锁 sync.Mutex 通常用来保护临界区和共享资源，条件变量 sync.Cond 用来协调想要访问共享资源的 goroutine。
sync.Cond 经常用在多个 goroutine 等待，一个 goroutine 通知的场景。
比如有一个 goroutine 在异步地接收数据，剩下的多个 goroutine 必须等待这个协程接收完数据，才能读取到正确的数据。这个时候，就需要有个全局的变量来标志第一 个 goroutine 数据是否接受完毕，剩下的 goroutine，反复检查该变量的值，直到满足要求。
当然也可以创建多个 channel，每个 goroutine 阻塞在一个 channel 上，由接收数据的 goroutine 在数据接收完毕后，逐个通知。但是这种方式更复杂一点。
使用 # NewCond 用来创建 sync.Cond 实例，sync.Cond 暴露了几个方法：
Broadcast 用来唤醒所有等待条件变量的 goroutine，无需锁保护。 Signal 唤醒一个 goroutine。 Wait 调用 Wait 会自动释放锁，并挂起调用者所在的 goroutine，也就是当前 goroutine 会阻塞在 Wait 方法调用的地方。如果其他 goroutine 调用了 Signal 或 Broadcast 唤醒 了该 goroutine，那么 Wait 方法在结束阻塞时，会重新加锁，并且继续执行 Wait 后面的代码。 var status int64 func main() { c := sync.</description></item><item><title>API 风格</title><link>https://shipengqi.github.io/golang-learn/docs/project/05_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/05_api/</guid><description> API 风格 # RESTful API # RPC #</description></item><item><title>Go 性能优化</title><link>https://shipengqi.github.io/golang-learn/docs/practice/05_performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/05_performance/</guid><description>Go 性能优化 # JSON 优化 # Go 官方的 encoding/json 是通过反射来实现的。性能相对有些慢。 可以使用第三方库来替代标准库：
json-iterator/go，完全兼容标准库，性能有很大提升。 go-json，完全兼容标准库，性能强于 json-iterator/go。 sonic，字节开发的的 JSON 序列化/反序列化库，速度快，但是对硬件有一些要求。 实际开发中可以根据编译标签来选择 JSON 库，参考 component-base/json。
使用空结构体 # 在 Go 中空结构体 struct{} 不占据内存空间：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { fmt.Println(unsafe.Sizeof(struct{}{})) // 0 } 空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用，可以节省资源。
集合 Set # 要实现一个 Set，通常会使用 map 来实现，比如 map[string]bool。 但是对于集合来说， 只需要 map 的键，而不需要值。将值设置为 bool 类型，就会多占据 1 个字节。这个时候就可以使用空结构体 map[string]struct{}。
channel 通知 # 有时候使用 channel 不需要发送任何的数据，只用来通知 goroutine 执行任务，或结束等。这个时候就可以使用空结构体。
内存对齐 # 为什么需要内存对齐？ # CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如：</description></item><item><title>Once</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</guid><description>Once # Go 标准库中 sync.Once 可以保证 Go 程序运行期间的某段代码只会执行一次。常常用于单例对象的初始化场景。
使用 # sync.Once 只有一个对外唯一暴露的方法 Do，可以多次调用，但是只第一次调用时会执行一次。
func main() { o := &amp;amp;sync.Once{} for i := 0; i &amp;lt; 10; i++ { o.Do(func() { fmt.Println(&amp;#34;only once&amp;#34;) }) } } 运行：
$ go run main.go only once 利用 channel 实现 Once # 下面的代码也可以达到执行一次的效果，不过重复执行会导致 panic：
var setonce chan struct{} func initialize() { // channel 不可以重复关闭，否则会 panic close(a.setonce) // 初始化 // ... } 原理 # sync.Once 的实现：</description></item><item><title>函数</title><link>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</guid><description>函数 # 参数传递 # 函数的参数传递有两种方式：
值传递：当传一个参数值到被调用的函数里面时，实际上是传了这个值的副本，被调用方和调用方两者持有不相关的两份数据。 引用传递：当传一个参数值到被调用的函数里面时，实际是传了参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。 Go 使用的是值传递，不管参数是基本类型，结构体还是指针，都会对传递的参数进行拷贝，区别无非是拷贝的目标对象还是拷贝指针。拷贝指针，也就是会同时出现两个指针指向原有的内存空间。
package main import &amp;#34;fmt&amp;#34; type foo struct { i int } func printFunc(a foo, b, c *foo) { a.i = 31 b.i = 41 c = &amp;amp;foo{i: 60} fmt.Printf(&amp;#34;print function - a=(%d, %p) b=(%v, %p) c=(%v, %p)\n&amp;#34;, a, &amp;amp;a, b, &amp;amp;b, c, &amp;amp;c) } func main() { a := foo{i: 30} b := &amp;amp;foo{i: 40} c := &amp;amp;foo{i: 50} fmt.Printf(&amp;#34;before calling - a=(%d, %p) b=(%v, %p) c=(%v, %p)\n&amp;#34;, a, &amp;amp;a, b, &amp;amp;b, c, &amp;amp;c) printFunc(a, b, c) fmt.</description></item><item><title>API 文档</title><link>https://shipengqi.github.io/golang-learn/docs/project/06_api_doc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/06_api_doc/</guid><description> API 文档 #</description></item><item><title>Go Trace</title><link>https://shipengqi.github.io/golang-learn/docs/practice/06_trace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/06_trace/</guid><description>Go Trace # Go PProf 很难完成 Goroutine 的分析。这就需要使用 go tool trace 命令。
go tool pprof 可以跟踪运行缓慢的函数，或者找到大部分 CPU 时间花费在哪里。 go tool trace 更适合于找出程序在一段时间内正在做什么，而不是总体上的开销。
package main import ( &amp;#34;os&amp;#34; &amp;#34;runtime/trace&amp;#34; ) func main() { f, err := os.Create(&amp;#34;trace.out&amp;#34;) if err != nil { panic(err) } defer f.Close() err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() ch := make(chan string) go func() { ch &amp;lt;- &amp;#34;hello&amp;#34; }() // read from channel &amp;lt;-ch } 生成跟踪文件：</description></item><item><title>Pool</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</guid><description>Pool # Go 从 1.3 版本开始提供了对象重用的机制，即 sync.Pool。sync.Pool 用来保存可以被重复使用的临时对象，避免了重复创建和销毁临时对象带来的消耗，降低 GC 压力，提高性能。
sync.Pool 是可伸缩的，也是并发安全的。可以在多个 goroutine 中并发调用 sync.Pool 存取对象。
使用 # var buffers = sync.Pool{ New: func() interface{} { return new(bytes.Buffer) }, } func GetBuffer() *bytes.Buffer { return buffers.Get().(*bytes.Buffer) } func PutBuffer(buf *bytes.Buffer) { buf.Reset() buffers.Put(buf) } New：类型是 func() interface{}，用来创建新的元素。 Get：从 Pool 中取出一个元素，如果没有更多的空闲元素，就调用 New 创建新的元素。如果没有设置 New 那么可能返回 nil。 Put：将一个元素放回 Pool 中，使该元素可以重复使用，如果 Put 的值是 nil，会被忽略。
可以先 Put，再 Get 么？ # 不可以。
type item struct { value int } func main() { pool := sync.</description></item><item><title>Context</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</guid><description>Context # Go 1.7 版本中正式引入新标准库 context。主要的作用是在在一组 goroutine 之间传递共享的值、取消信号、deadline 等。
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline — 返回当前 context 的截止时间。 Done — 返回一个只读的 channel，可用于识别当前 channel 是否已经被关闭，其原因可能是到期，也可能是被取消了。多次调用 Done 方法会返回同一个 channel。 Err — 返回当前 context 被关闭的原因。 如果 context 被取消，会返回 Canceled 错误。 如果 context 超时，会返回 DeadlineExceeded 错误。 Value — 返回当前 context 对应所存储的 context信息，可以用来传递请求特定的数据。 创建 context：
Background：创建一个空的 context，一般用在主函数、初始化、测试以及创建 root context 的时候。 TODO：创建一个空的 context，不知道要传递一些什么上下文信息的时候，就用这个。 WithCancel：基于 parent context 创建一个可以取消的新 context。 WithTimeout：基于 parent context 创建一个具有超时时间的新 context。 WithDeadline：和 WithTimeout 一样，只不过参数是截止时间（超时时间加上当前时间）。 WithValue：基于某个 context 创建并存储对应的上下文信息。 最常用的场景，使用 context 来取消一个 goroutine 的运行：</description></item><item><title>Go CoreDump 调试</title><link>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</guid><description>Go CoreDump 调试 # Go 也可以开启类似 C++ CoreDump 功能，CoreDump 是异常退出程序的内存快照。程序崩溃时，可以帮助定位 crash 发生的原因。
如何生成 CoreDump 文件 # GOTRACEBACK 可以控制程序崩溃时输出的详细程度。 可选的值：
none 不显示任何 goroutine 栈 trace。 single, 默认选项，显示当前 goroutine 栈 trace。 all 显示所有用户创建的 goroutine 栈 trace。 system 显示所有 goroutine 栈 trace,甚至运行时的 trace。 crash 类似 system, 而且还会生成 core dump。 可以设置 export GOTRACEBACK=crash 来生成 core dump。
编译时要确保使用编译器标志 -N 和 -l 来构建二进制文件,它会禁用编译器优化，编译器优化可能会使调试更加困难。
$ go build -gcflags=all=&amp;#34;-N -l&amp;#34; 如果 coredump 没有生成，可能是 coredump size 配置为 0，如下命令将 coredump 配置为 1MB 大小：</description></item><item><title>make</title><link>https://shipengqi.github.io/golang-learn/docs/project/07_make/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/07_make/</guid><description>make # 项目管理</description></item><item><title>Go Modules</title><link>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</guid><description>Go Modules # Golang 在 1.11 推出了 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，解决了 GOPATH 的问题，相当于弃用了 GOPATH。
Go Module 机制 # Go Module 不同于基于 GOPATH 和 Vendor 的项目构建，其主要是通过 $GOPATH/pkg/mod 下缓存的模块来对项目进行构建。 同一个模块版本的数据只缓存一份，所有其他模块共享使用。
可以使用 go clean -modcache 清理所有已缓存的模块版本数据。
GO111MODULE # Go Module 目前是可选的，可以通过环境变量 GO111MODULE 来控制是否启用，GO111MODULE 有三种类型:
on 所有的构建，都使用 Module 机制 off 所有的构建，都不使用 Module 机制，而是使用 GOPATH 和 Vendor auto 在 GOPATH 下的项目，不使用 Module 机制，不在 GOPATH 下的项目使用 GOPROXY # GOPROXY 用于设置 Go Module 代理。使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它的值是一个以 , 分割的 Go module proxy 列表。Golang 1.</description></item><item><title>原子操作</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</guid><description>原子操作 # 原子操作就是执行过程中不能被中断的操作。
Go 的标准库 sync/atomic 提供了一些实现原子操作的方法：
Add CompareAndSwap（简称 CAS） Load Swap Store 这些函数针对的数据类型有：
int32 int64 uint32 uint64 uintptr unsafe 包中的 Pointer 以 Add 为例，上面类型对应的原子操作函数为：
func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) unsafe.Pointer 类型，并未提供进行原子加法操作的函数。
sync/atomic 包还提供了一个名为 Value 的类型，它可以被用来存储（Store）和加载（Load）任意类型的值。
它只有两个指针方法：
Store Load。 尽量不要向原子值中存储引用类型的值。</description></item><item><title>基于 GitHub Actions 的 CI/CD</title><link>https://shipengqi.github.io/golang-learn/docs/project/08_github_actions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/08_github_actions/</guid><description>基于 GitHub Actions 的 CI/CD # 静态代码检查 # GitHub Actions 是 GitHub 为托管在 github.com 站点的项目提供的持续集成服务。
在构建持续集成任务时，我们会在任务中心完成各种操作，比如克隆代码、编译代码、运行单元测试、构建和发布镜像等。GitHub 把这些操作称为 Actions。
Actions 是可以共享的，开发者可以将 Actions 上传到 GitHub 的 Actions 市场。 一个 awesome actions 仓库，里面也有不少的 Action。如果需要某个 Action，直接引用他人写好的 Action 即可。 整个持续集成过程，就变成了一个 Actions 的组合。
Action 其实是一个独立的脚本，可以将 Action 存放在 GitHub 代码仓库中，通过 &amp;lt;userName&amp;gt;/&amp;lt;repoName&amp;gt; 的语法引用 Action。例如， actions/checkout@v2 表示 https://github.com/actions/checkout 这个仓库，tag 是 v2。
GitHub Actions 术语：
workflow：一个 .yml 文件对应一个 workflow，也就是一次持续集成。一个 GitHub 仓库可以包含多个 workflow，只要是在 .github/workflow 目录下的 .yml 文件都会被 GitHub 执行。 job：一个 workflow 由一个或多个 job 构成，每个 job 代表一个持续集成任务。 step：每个 job 由多个 step 构成，一步步完成。 action：每个 step 可以依次执行一个或多个命令（action）。 on：一个 workflow 的触发条件，决定了当前的 workflow 在什么时候被执行。 workflow 文件 # GitHub Actions 配置文件存放在代码仓库的 .</description></item><item><title>Channel</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</guid><description>Channel # Don’t communicate by sharing memory; share memory by communicating. 不要通过共享内存来通信，通过通信来共享内存。 这是 Go 语言最重要的编程理念。goroutine 通过 channel 向另一个 goroutine 发送消息，channel 和 goroutine 结合，可以实现用通信代替共享内存的 CSP （Communicating Sequential Process）模型。
使用 # 创建 channel：
// 无缓冲 channel ch := make(chan int) // 带缓冲 channel，缓冲区为 3 ch = make(chan int, 3) channel 的零值是 nil。
无缓冲 channel # 无缓冲 channel 也叫做同步 channel：
一个 goroutine 基于一个无缓冲 channel 发送数据，那么就会阻塞，直到另一个 goroutine 在相同的 channel 上执行接收操作。 一个 goroutine 基于一个无缓冲 channel 先执行了接收操作，也会阻塞，直到另一个 goroutine 在相同的 channel 上执行发送操作 带缓冲 channel # 带缓冲的 channel 有一个缓冲区：</description></item><item><title>Gin 静态服务器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</guid><description>Gin 如何实现前端网页的静态服务器 # Gin 作为 Web 框架提供 API 接口非常方便，但是在同一个项目中，既提供 API 接口，又要作为前端网页的静态服务器，就比较麻烦。通常 Angular (React/Vue) 项目需要在 Nginx 或者 Tomcat 转发才可以。有些小项目并不需要前后端分离，如何解决？
利用 embed 标签 # Go 的 1.16 版本增加了 embed 的标签，可以利用这个标签将静态资源打包到二进制文件中。
. ├── config ├── controller ├── model ├── options ├── pkg │ └── response │ └── response.go ├── resources │ ├── dist │ └── html.go ├── html.go ├── resource.go ├── router.go ├── server.go └── store ├── audited.go ├── groups.go ├── mysql.go ├── settings.</description></item><item><title>指针</title><link>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</guid><description>指针 # 指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个保存内存地址的整形变量。
指针的限制 # 指针不能参与运算 # package main import &amp;#34;fmt&amp;#34; func main() { a := 1 b := a fmt.Println(b) b = &amp;amp;a + 1 } 上面的代码编译时会报错：Invalid operation: &amp;amp;a + 1 (mismatched types *int and untyped int)。
说明 Go 是不允许对指针进行运算的。
不同类型的指针不允许相互转换 # package main func main() { var a int = 100 var f *float64 f = &amp;amp;a } 上面的代码编译时会报错：Cannot use '&amp;amp;a' (type *int) as the type *float64。</description></item><item><title>信号量</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/10_sema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/10_sema/</guid><description>信号量 # 信号量（Semaphore）是一种用于实现多进程或多线程之间同步和互斥的机制。
信号量可以简单理解为一个整型数，包含两种操作：P（Proberen，测试）操作和 V（Verhogen，增加）操作。其中，P 操作会尝试获取一个信号量，如果信号量的值大于 0，则将信号量的值减 1 并 继续执行。否则，当前进程或线程就会被阻塞，直到有其他进程或线程释放这个信号量为止。V 操作则是释放一个信号量，将信号量的值加 1。
P 操作和 V 操作可以看做是对资源的获取和释放。
Go 的 WaitGroup 和 Metux 都是通过信号量来控制 goroutine 的阻塞和唤醒，例如 Mutex 结构体中的 sema：
type Mutex struct { state int32 sema uint32 } Metux 本质上就是基于信号量（sema）+ 原子操作来实现并发控制的。
Go 操作信号量的方法：
// src/sync/runtime.go // 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1 func runtime_Semacquire(s *uint32) // 类似于 runtime_Semacquire // 如果 lifo 为 true，waiter 将会被插入到队列的头部，否则插入到队列尾部 // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int) // 将 s 增加 1，然后通知阻塞在 runtime_Semacquire 的 goroutine // 如果 handoff 为 true，传递信号到队列头部的 waiter // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_Semrelease(s *uint32, handoff bool, skipframes int) Acquire 和 Release 分别对应了 P 操作和 V 操作。</description></item><item><title>SingleFlight</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/11_singleflight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/11_singleflight/</guid><description>SingleFlight # Go 的扩展库 golang.org/x/sync 提供了 singleflight 包，它的作用在处理多个 goroutine 同时调用同一个函数的时候，只让一个 goroutine 去调用这个函数，等到这个 goroutine 返回结果时，再把结 果返回给这几个 goroutine，这样可以减少并发调用的数量。
一个常见的使用场景：在使用 Redis 对数据库中的数据进行缓存，如果发生缓存击穿，大量的流量都会打到后端数据库上，导致后端服务响应延时等问题。 singleflight 可以将对同一个 key 的多个请求合并为一个，减轻后端服务的压力。
使用 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; &amp;#34;golang.org/x/sync/singleflight&amp;#34; ) func GetValueFromRedis(key string) string { fmt.Println(&amp;#34;query ...&amp;#34;) time.Sleep(10 * time.Second) // 模拟一个比较耗时的操作 return &amp;#34;singleflight demo&amp;#34; } func main() { requestGroup := new(singleflight.Group) cachekey := &amp;#34;demokey&amp;#34; go func() { v1, _, shared := requestGroup.Do(cachekey, func() (interface{}, error) { ret := GetValueFromRedis(cachekey) return ret, nil }) fmt.</description></item><item><title>ErrGroup</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/12_errorgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/12_errorgroup/</guid><description>ErrGroup # Go 的扩展库 golang.org/x/sync 提供了 errgroup 包，它是基于 WaitGroup 实现的，功能上和 WaitGroup 类似，不过可以通过上下文取消，控制并发数量，还能返回错误。
使用 # 最简单的使用方式：
package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; &amp;#34;golang.org/x/sync/errgroup&amp;#34; ) func main() { var g errgroup.Group // g, ctx := errgroup.WithContext(context.Background()) g.Go(func() error { time.Sleep(5 * time.Second) fmt.Println(&amp;#34;exec 1&amp;#34;) return nil }) g.Go(func() error { time.Sleep(10 * time.Second) fmt.Println(&amp;#34;exec 2&amp;#34;) return errors.New(&amp;#34;failed to exec 2&amp;#34;) }) if err := g.Wait(); err == nil { fmt.Println(&amp;#34;exec done&amp;#34;) } else { fmt.</description></item></channel></rss>