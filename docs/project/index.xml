<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🛠️ Go 工程实践 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/docs/project/</link><description>Recent content in 🛠️ Go 工程实践 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/docs/project/index.xml" rel="self" type="application/rss+xml"/><item><title>项目规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/01_specs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/01_specs/</guid><description>项目规范 # 对于多人协作的项目，每个人的开发习惯都不相同，没有统一的规范，会造成很多问题。比如：代码风格不统一，目录结构杂乱无章，API 定义不统一（URL 和错误码）。
一个好的规范可以提高软件质量，提高开发效率，降低维护成本。
选择开源协议 # 开源项目需要选择一个开源协议，如果不准备开源，就用不到开源协议。
开源许可证，大概有几十种，可分为两大类：
宽松式（permissive）许可证：最基本的类型，对用户几乎没有限制，用户可以修改代码后闭源。例如 MIT，Apache 2.0 等。 Copyleft 许可证：比宽松式许可证的限制要多，修改源码后不可以闭源。例如 GPL，Mozilla（MPL）等。 如何选择自己项目的开源许可证，可以根据下面的图示：
图片来自于阮一峰的网络日志
文档规范 # README # README.md 是开发者了解一个项目时阅读的第一个文档，会放在项目的根目录下。主要是用来介绍项目的功能、安装、部署和使用。
# 项目名称 &amp;lt;!-- 项目描述、Logo 和 Badges --&amp;gt; ## Overview &amp;lt;!-- 描述项目的核心功能 --&amp;gt; ## Getting started ### Installation &amp;lt;!-- 如何安装 --&amp;gt; ### Usage &amp;lt;!-- 用法 --&amp;gt; ## Contributing &amp;lt;!-- 如何提交代码 --&amp;gt; 也可以使用快速生成 README 文档的在线工具 readme.so。
项目文档 # 项目文档一般会放在 /docs 目录下。项目文档一般有两类：
开发文档：用来说明项目的开发流程，如何搭建开发环境、构建、测试、部署等。 用户文档：针对用户的使用文档，一般包括功能介绍文档、安装文档、API 文档、最佳实践、操作指南、常见问题等。 文档最好包含英文和中文 2 个版本。</description></item><item><title>项目的目录结构</title><link>https://shipengqi.github.io/golang-learn/docs/project/02_structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/02_structure/</guid><description>项目的目录结构 # 一个好的目录结构设计应该是易维护、易扩展的。至少要满足以下几个要求：
命名清晰：目录命名要清晰、简洁，能清晰地表达出该目录实现的功能，并且目录名最好用单数。单数足以说明这个目录的功能，避免单复混用。 功能明确：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有很高的辨识度。当需要新增一个功能时，能够非常清楚地知道把这个功能放在哪个目录下。 全面性：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等。 可预测性：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。 可扩展性：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能。 根据项目的功能，目录结构可以分为两种：
平铺式目录结构 结构化目录结构 平铺式目录结构 # 当一个项目是一个工具库时，适合使用平铺式目录结构。项目的代码都存放在项目的根目录下，可以减少项目引用路径的长度。例如 github.com/golang/glog：
$ ls glog/ glog_file.go glog_flags.go glog.go glog_test.go go.mod go.sum LICENSE README 结构化目录结构 # 当一个项目是一个应用时，适合使用结构化目录结构。目前 Go 社区比较推荐的结构化目录结构是 project-layout。
下面是一套结合 project-layout 总结出的目录结构：
├── api # 存放不同类型的 API 定义文件 │ └── swagger # Swagger API 文档 ├── cmd # cmd 下可以包含多个组件目录，组件目录下存放各个组件的 main 包 │ └── apiserver │ └── apiserver.go ├── chart # helm chart 文件 ├── conf # 项目部署的配置文件 ├── docs # 项目文档 │ ├── dev │ │ ├── en-US │ │ └── zh-CN │ ├── guide │ │ ├── en-US │ │ └── zh-CN │ └── README.</description></item><item><title>代码规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/03_code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/03_code/</guid><description>代码规范 # 好的代码规范非常重要，可以提高代码的可读性，减少 bug，提高开发效率。
Go 官方提供的代码规范：
Go Code Review Comments Effective Go Uber 开源的 Go 编码规范：
Uber Go Guide Go 也提供了一些代码检查工具，例如 golint，goimports，go vet 等，但是这些工具检查的不够全面。
golangci-lint 是一个更加强大的静态代码检查工具。
golangci-lint # golangci-lint 的运行速度非常快，因为它可以并行的运行 linters，并且重用 Go 的构建缓存，缓存分析结果。
golangci-lint 集成了大量的 linters，不需要额外安装，可以直接使用。
安装 # $ go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.55.2 # 验证是否安装成功 $ golangci-lint version 更多安装方式。
使用 # run 命令执行代码检查：
$ golangci-lint run linters 命令打印出 golangci-lint 所支持的 linters：
$ golangci-lint linters 配置 # golangci-lint 有两种配置方式：命令行选项和配置文件。
golangci-lint 会在当前工作目录下的以下路径中查找配置文件：</description></item><item><title>Commit 规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/04_commitizen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/04_commitizen/</guid><description>Commit 规范 # 多人协作开发一个项目时，如果 Commit Message 五花八门，时间久了，提交的历史变得很难看，而且过于简单的 Commit Message，可读性较差。
一个好的 Commit 规范可以使 Commit Message 的可读性更好，并且可以实现自动化。
一个好的 Commit Message 应该满足以下要求：
清晰地描述 commit 的变更内容。 可以基于这些 Commit Message 进行过滤查找，比如只查找某个版本新增的功能：git log --oneline --grep &amp;quot;^feat|^fix&amp;quot;。 可以基于规范化的 Commit Message 生成 Change Log。 可以依据某些类型的 Commit Message 触发构建或者发布流程，比如当类型为 feat、fix 时触发 CI 流程。 确定语义化版本的版本号。比如 fix 类型可以映射为 PATCH 版本，feat 类型可以映射为 MINOR 版本。带有 BREAKING CHANGE 的 commit，可以映射为 MAJOR 版本。 目前，开源社区有多种 Commit 规范，例如 jQuery、Angular 等。Angular 规范是使用最广泛的，格式清晰易读。
Angular 规范 # Angular 规范中，Commit Message 包含三个部分：Header、Body 和 Footer。格式如下：</description></item><item><title>版本规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/05_version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/05_version/</guid><description>版本规范 # Go 官方推荐的版本规范是 semver（Semantic Versioning），也就是语义化版本。这个规范是 GitHub 起草的一个具有指导意义的、统一的版本号表示规范。
semver 是一种清晰可读的，明确反应版本信息的版本格式：
主版本号.次版本号.修订号 主版本号：做了不兼容的 API 修改。 次版本号：向下兼容的新增功能以及修改。 修订号： 向下兼容的问题修复。 例如 v1.2.3。
semver 还有先行版本号和编译版本号，格式为 X.Y.Z[-先行版本号][+编译版本号]。
例如 v1.2.3-alpha.1+001，alpha.1 就是先行版本号，001 是编译版本号。
先行版本号，意味着该版本不稳定，可能存在兼容性问题，可以用 . 作为分隔符。 编译版本号，一般是编译器在编译过程中自动生成的。 先行版本号和编译版本号只能是字母、数字，并且不可以有空格。
如何确定版本号？ # 在实际开发的时候，可以使用 0.1.0 作为第一个开发版本号，并在后续的每次发行时递增次版本号。 当软件是一个稳定的版本，并且第一次对外发布时，版本号应该是 1.0.0。 严格按照 Angular 规范提交代码，版本号可以按照下面的规则来确定： fix 类型的 commit 可以将修订号 +1。 feat 类型的 commit 可以将次版本号 +1。 带有 BREAKING CHANGE 的 commit 可以将主版本号 +1。 如何处理将要弃用的功能? # 弃用已存在的功能，在软件开发中是常规操作，如果要弃用某个功能，要做到两点：
更新用户文档，通知用户。 发布新的次版本，要包含舍弃的功能，直到发布新的主版本，目的是让用户能够平滑的迁移到新的 API。 自动生成语义化版本 # gsemver 是一个用 Go 实现的命令行工具，它使用 git commit 来自动生成符合 semver 2.</description></item><item><title>API 文档</title><link>https://shipengqi.github.io/golang-learn/docs/project/06_api_doc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/06_api_doc/</guid><description>API 文档 # 使用 Swagger 生成 API 文档 # Swagger 是基于 OpenAPI 规范的 API 文档工具。
OpenAPI 是一个 API 规范，它的前身就是 Swagger 规范，目前最新的 OpenAPI 规范是 OpenAPI 3.0（也就是 Swagger 2.0 规范）。
Swagger 编辑器 # Swagger 编辑是一个在线的 API 文档编辑器，可以在其中编写 OpenAPI 规范，并实时预览 API 文档。
基于代码自动生成 Swagger 文档 # Go 生成 Swagger 文档常用的工具有两个，分别是 swag 和 go-swagger。
推荐使用 go-swagger：
go-swagger 提供了更灵活、更多的功能来描述 API，可以生成客户端和服务器端代码。 使用 swag 的话，每一个 API 都需要有一个冗长的注释，有时候代码注释比代码还要长，但是通过 go-swagger 可以将代码和注释分开编写，可以使代码保持简洁，清晰易读，而且可以把 API 定义放在一个目录中，方便管理。 安装 go-swagger # $ go get -u github.</description></item><item><title>Git 工作流程</title><link>https://shipengqi.github.io/golang-learn/docs/project/07_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/07_flow/</guid><description>Git 工作流程 # 涉及到多人协作的项目，多个开发者向同一个仓库提交代码，如果处理不好会出现代码丢失，冲突等问题。所以一个规范的工作流程，可以让开发者更有效地合作，使项目更好地发展下去。
最常用的工作流程有三种：
Git Flow GitHub Flow Forking Flow Git Flow # Git Flow 是最早出现的一种工作流程。
Git Flow 存在两种长期分支：
master：这个分支永远是稳定的发布版本，不能直接在该分支上开发。每次合并一个 hotfix/release 分支，都在 master 上打一个版本标签。 develop：日常开发的分支，存放最新的开发版。同样不能在这个分支上直接开发，这个分支只做合并操作。 三种短期分支：
feature branch：用于功能开发，基于 develop 创建新的 feature 分支，可以命名为 feat/xxx-xx。开发完成之后，合并到 develop 并删除。 hotfix branch：补丁分支，在维护阶段用于紧急的 bug 修复。基于 master 创建，可以命名为 hotfix/xxx-xx。完成后合并到 master 分支并，然后在 master 打上标签删除并删除 hotfix 分支。一般 develop 也需要合并 hotfix 分支。 release branch：预发布分支，在发布阶段，基于 develop 创建，可以命名为 release/xxx-xx。 例如 v1.0.0 版本开发完成后，代码已经全部合并到 develop 分支。发布之前，基于 develop 创建release/1.0.0 分支，基于 release/1.0.0 进行测试，如果发现 bug，就在 release/1.</description></item><item><title>项目管理</title><link>https://shipengqi.github.io/golang-learn/docs/project/08_make/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/08_make/</guid><description>项目管理 # Go 项目通常使用 Makefile 作为项目管理工具。
通常 Go 项目的 Makefile 应该包括：格式化代码、静态代码检查、单元测试、代码构建、文件清理、帮助等功能。
学习 Makefile 的语法，推荐学习《跟我一起写 Makefile》 (PDF 重制版)。
Makefile 结构 # 随着项目越来越大，需要管理的功能就会越来越多，如果全部放在一个 Makefile 中，会导致 Makefile 过大，难以维护，可读性差。所以设计 Makefile 结构时，最好采用分层的设计。
项目根目录下的 Makefile 来聚合子目录下的 Makefile 命令。将复杂的 shell 命令封装在 shell 脚本中，供 Makefile 直接调用，而一些简单的命令则可以直接集成在 Makefile 中。
示例；
.PHONY: all all: modules lint test build # ============================================================================== # Includes include hack/include/common.mk # make sure include common.mk at the first include line include hack/include/go.mk include hack/include/release.mk # ============================================================================== # Targets ## build: build binary file.</description></item><item><title>GitHub Actions</title><link>https://shipengqi.github.io/golang-learn/docs/project/09_actions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/09_actions/</guid><description>基于 GitHub Actions 的 CI/CD # GitHub Actions 是 GitHub 为托管在 github.com 站点的项目提供的持续集成服务。
在构建持续集成任务时，需要完成很多操作，比如克隆代码、编译代码、运行单元测试、构建和发布镜像等。GitHub 把这些操作称为 Actions。
Actions 是可以共享的，开发者可以将 Actions 上传到 GitHub 的 Actions 市场。如果需要某个 Action，直接引用即可。 整个持续集成过程，就变成了一个 Actions 的组合。
Action 其实是一个独立的脚本，可以将 Action 存放在 GitHub 代码仓库中，通过 &amp;lt;userName&amp;gt;/&amp;lt;repoName&amp;gt; 的语法引用 Action。例如，actions/checkout@v2 表示 https://github.com/actions/checkout 这个仓库，tag 是 v2。
GitHub Actions 术语 # workflow：一个 .yml 文件对应一个 workflow，也就是一次持续集成。一个 GitHub 仓库可以包含多个 workflow，只要是在 .github/workflow 目录下的 .yml 文件都会被 GitHub 执行。 job：一个 workflow 由一个或多个 job 构成，每个 job 代表一个持续集成任务。 step：每个 job 由多个 step 构成，一步步完成。 action：每个 step 可以依次执行一个或多个命令（action）。 on：一个 workflow 的触发条件，决定了当前的 workflow 在什么时候被执行。 workflow # GitHub Actions 配置文件存放在代码仓库的 .</description></item><item><title>GitHub Dependabot</title><link>https://shipengqi.github.io/golang-learn/docs/project/10_dependabot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/10_dependabot/</guid><description>GitHub Dependabot # GitHub Dependabot 是 GitHub 提供的一个工具，它可以帮助检测项目所使用的 dependency 中是否有可以更新的版本，如果有，它可以自动创建 PR 实现自动更新。
GitHub Dependabot 的配置文件 dependabot.yml 必须存放在代码仓库的 .github 目录下。在添加或更新 dependabot.yml 文件时，会立即触发版本更新检查。
version: 2 updates: - package-ecosystem: &amp;#34;gomod&amp;#34; directory: &amp;#34;/&amp;#34; schedule: interval: &amp;#34;daily&amp;#34; time: &amp;#34;08:00&amp;#34; labels: - &amp;#34;dependencies&amp;#34; commit-message: prefix: &amp;#34;feat&amp;#34; include: &amp;#34;scope&amp;#34; 上面的示例，interval: &amp;quot;daily&amp;quot; time: &amp;quot;08:00&amp;quot; 表示每天八点会触发版本更新检查。
dependabot.yml 文件中两个必须的字段：version 和 updates。该文件必须以 version: 2 开头。
updates # updates 用来配置 Dependabot 如何更新版本或项目的依赖项，常用的选项：
选项 required 安全更新 版本更新 说明 package-ecosystem yes no yes 要使用的包管理器 directory yes yes yes package manifests 位置 schedule.</description></item><item><title>GitHub 模板</title><link>https://shipengqi.github.io/golang-learn/docs/project/11_templates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/11_templates/</guid><description>GitHub 模板 # 使用 Issue 和 PR 模板可以让贡献者有针对性的提供某类问题的准确信息。
PR Template # PR 模板可以在任意的目录下，如果有多个 PR 模板，需要创建一个 PULL_REQUEST_TEMPLATE 目录。
例如，可以在 repo 的根目录下创建 pull_request_template.md，也可以在放在 .github 目录中 .github/pull_request_template.md。
pull_request_template.md:
Thank you for contributing to crtctl! # Please add a summary of your change # Does your change fix a particular issue? Fixes #(issue) Issue Template # Issue 模板存储在 repo 的 .github/ISSUE_TEMPLATE 目录中。文件名不区分大小写，扩展名为 .md。
ISSUE_TEMPLATE/bug_report.md
--- name: Bug Report about: Tell us about a problem you are experiencing --- **What steps did you take and what happened:** [A clear and concise description of what the bug is, and what commands you ran.</description></item><item><title>GoReleaser</title><link>https://shipengqi.github.io/golang-learn/docs/project/12_goreleaser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/12_goreleaser/</guid><description>GoReleaser # GoReleaser 是用 Go 编写项目的自动发布工具，支持交叉编译，并且支持发布到 Github，Gitlab 和 Gitea。
安装 # go install github.com/goreleaser/goreleaser@latest 更多安装方式。
使用 # 生成配置文件 .goreleaser.yaml，一般这个文件放在项目的根目录下：
goreleaser init 下面的命令可以发布一个 &amp;ldquo;仅限本地&amp;rdquo; 的 release，一般用来测试 release 命令是否可以正常运行。
goreleaser release --snapshot --rm-dist 修改 .goreleaser.yaml 配置后，可以用 check 命令检查配置：
goreleaser check --single-target 只为特定的 GOOS/GOARCH 构建二进制文件，这对本地开发很有用：
goreleaser build --single-target 发布一个 release # 如果要发布到 Github，需要导出一个环境变量 GITHUB_TOKEN，它应该包含一个有效的 GitHub token 与 repo 范围。它将被用来部署发布到你的 GitHub 仓库。创建一个新的 GitHub 令牌。
write:packages 权限是 GITHUB_TOKEN 需要的最小权限。
GoReleaser 会使用 repo 的最新 Git 标签。</description></item><item><title>错误处理</title><link>https://shipengqi.github.io/golang-learn/docs/project/14_error/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/14_error/</guid><description> 错误处理 #</description></item><item><title>Casbin</title><link>https://shipengqi.github.io/golang-learn/docs/project/16_casbin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/16_casbin/</guid><description>Casbin 是基于 Go 语言的开源权限控制库。支持 ACL，RBAC，ABAC 等常用的访问控制模型。
Casbin 只负责访问控制，不负责验证用户的用户名、密码，应该有专门的组件负责身份认证，再配合 Casbin 进行访问控制。 Casbin 只存储用户和角色之间的映射关系，不存储用户、角色等信息。 Casbin 的访问控制模型核心叫做 PERM（Policy、Effect、Request、Matcher） 元模型。
PERM 元模型 # PERM（Policy、Effect、Request、Matcher）可以简单理解为，当一个请求（Request）进来，需要通过策略匹配器（Matcher）去匹配存储在数据库中或者 csv 文件中的策略规则，拿到所有匹配的策略规则的结果（eft）之后，在使用 Effect 定义中的表达式进行计算，最终返回一个 true （通过）或 false（拒绝）。
Request # Request 代表请求。
请求的定义，这个定义的是 e.Enforce(...) 函数中的参数：
[request_definition] r = sub, obj, act sub：代表访问资源的实体，一般就是指用户。 obj：要访问的资源。 act：对资源执行的操作。 这里是定义你的请求格式。如果你不需要指定资源，你可以定义：
[request_definition] r = sub, act 或者如果你有两个访问实体，你可以定义：
[request_definition] r = sub, sub2, obj, act Policy # Policy 代表策略。
定义访问策略模型，这个定义的是数据库中或者 csv 文件中策略规则的格式：
[policy_definition] p = sub, obj, act, eft p2 = sub, act eft：表示策略的结果，一般为空，默认是 allow。eft 只接受两个值是 allow 或 deny。 策略规则，策略规则一般存储在数据库中，也可以在 csv 文件中：</description></item></channel></rss>