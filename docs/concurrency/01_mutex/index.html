<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="互斥锁 # Go 的标准库 sync 提供了两种锁类型：sync.Mutex 和 sync.RWMutex，前者是互斥锁（排他锁），后者是读写锁。
互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。
Go 定义的锁接口只有两个方法：
type Locker interface { Lock() // 请求锁 Unlock() // 释放锁 } 使用 # import &#34;sync&#34; var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() defer mu.Unlock() balance = balance + amount } func Balance() int { mu.Lock() defer mu.Unlock() b := balance return b } 当已经有 goroutine 调用 Lock 方法获得了这个锁，再有 goroutine 请求这个锁就会阻塞在 Lock 方法的调用上， 直到持有这个锁的 goroutine 调用 UnLock 释放这个锁。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="互斥锁"><meta property="og:description" content="互斥锁 # Go 的标准库 sync 提供了两种锁类型：sync.Mutex 和 sync.RWMutex，前者是互斥锁（排他锁），后者是读写锁。
互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。
Go 定义的锁接口只有两个方法：
type Locker interface { Lock() // 请求锁 Unlock() // 释放锁 } 使用 # import &#34;sync&#34; var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() defer mu.Unlock() balance = balance + amount } func Balance() int { mu.Lock() defer mu.Unlock() b := balance return b } 当已经有 goroutine 调用 Lock 方法获得了这个锁，再有 goroutine 请求这个锁就会阻塞在 Lock 方法的调用上， 直到持有这个锁的 goroutine 调用 UnLock 释放这个锁。"><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-27T21:09:02+08:00"><title>互斥锁 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.9c656a69f0b12ad1b59282775751d4b2d3243b4cac00002847e176b3252bddf1.js integrity="sha256-nGVqafCxKtG1koJ3V1HUstMkO0ysAAAoR+F2syUr3fE=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础数据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/ class=active>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li><li><a href=/golang-learn/docs/concurrency/12_errorgroup/>ErrGroup</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go Core Dump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li></ul></li><li><span>🛠️ Go 工程实践</span><ul><li><a href=/golang-learn/docs/project/01_specs/>项目规范</a></li><li><a href=/golang-learn/docs/project/02_structure/>项目的目录结构</a></li><li><a href=/golang-learn/docs/project/03_code/>代码规范</a></li><li><a href=/golang-learn/docs/project/04_commitizen/>Commit 规范</a></li><li><a href=/golang-learn/docs/project/05_version/>版本规范</a></li><li><a href=/golang-learn/docs/project/06_api_doc/>API 文档</a></li><li><a href=/golang-learn/docs/project/07_flow/>Git 工作流程</a></li><li><a href=/golang-learn/docs/project/08_make/>项目管理</a></li><li><a href=/golang-learn/docs/project/09_actions/>GitHub Actions</a></li><li><a href=/golang-learn/docs/project/10_dependabot/>GitHub Dependabot</a></li><li><a href=/golang-learn/docs/project/11_templates/>GitHub 模板</a></li><li><a href=/golang-learn/docs/project/12_goreleaser/>GoReleaser</a></li></ul></li><li><a href=/golang-learn/docs/advance/>🔍 底层原理</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>互斥锁</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#互斥锁>互斥锁</a><ul><li><a href=#使用>使用</a><ul><li><a href=#为什么一定要加锁>为什么一定要加锁？</a></li></ul></li><li><a href=#原理>原理</a><ul><li><a href=#饥饿模式>饥饿模式</a></li><li><a href=#lock>Lock</a></li><li><a href=#unlock>Unlock</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=互斥锁>互斥锁
<a class=anchor href=#%e4%ba%92%e6%96%a5%e9%94%81>#</a></h1><p>Go 的标准库 <code>sync</code> 提供了两种锁类型：<code>sync.Mutex</code> 和 <code>sync.RWMutex</code>，前者是互斥锁（排他锁），后者是读写锁。</p><p>互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。</p><p>Go 定义的锁接口只有两个方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Locker</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Lock</span>() <span style=color:#75715e>// 请求锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Unlock</span>() <span style=color:#75715e>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=使用>使用
<a class=anchor href=#%e4%bd%bf%e7%94%a8>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mu</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span> <span style=color:#75715e>// guards balance 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>balance</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Deposit</span>(<span style=color:#a6e22e>amount</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>balance</span> = <span style=color:#a6e22e>balance</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>amount</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Balance</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>balance</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当已经有 goroutine 调用 <code>Lock</code> 方法获得了这个锁，再有 goroutine 请求这个锁就会阻塞在 <code>Lock</code> 方法的调用上，
直到持有这个锁的 goroutine 调用 <code>UnLock</code> 释放这个锁。</p><p><strong>使用 <code>defer</code> 来 <code>UnLock</code> 锁，确保在函数返回之后或者发生错误返回时一定会执行 <code>UnLock</code></strong>。</p><h3 id=为什么一定要加锁>为什么一定要加锁？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%80%e5%ae%9a%e8%a6%81%e5%8a%a0%e9%94%81>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>count</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 WaitGroup 等待 10 个 goroutine 完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 对变量 count 执行 10 次加 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#ae81ff>1000</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 等待 10 个 goroutine 完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>count</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的例子中期望的最后计数的结果是 <code>10 * 1000 = 10000</code>。但是每次运行都可能得到不同的结果，基本上不会得到的一万的结果。</p><p>这是因为，<code>count++</code> 不是一个原子操作，它至少包含 3 个步骤</p><ol><li>读取变量 count 的当前值，</li><li>对这个值加 1，</li><li>把结果保存到 count 中。</li></ol><p>因为不是原子操作，就会有数据竞争的问题。例如，两个 goroutine 同时读取到 count 的值为 8888，接着各自按照自己的逻辑加 1，值变成了 8889，把这个结果再写回到 count 变量。
此时总数只增加了 1，但是应该是增加 2 才对。这是并发访问共享数据的常见问题。</p><p>数据竞争的问题可以再编译时通过数据竞争检测器（race detector）工具发现计数器程序的问题以及修复方法。</p><h2 id=原理>原理
<a class=anchor href=#%e5%8e%9f%e7%90%86>#</a></h2><p><code>sync.Mutex</code> 的结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/sync/mutex.go#L34
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>state</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sema</span>  <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>state</code> 和 <code>sema</code> 加起来占用 8 个字节。</p><p><code>state</code> 是一个复合型的字段，包含多个意义：</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/132b0f97ec250e221f725cbeb2d5c323a35f1cfe/go/mutex-state.png alt=mutex-state></p><p>在默认状态下，互斥锁的所有状态位都是 0，<code>int32</code> 中的不同位分别表示了不同的状态：</p><ul><li><code>locked</code>：表示这个锁是否被持有</li><li><code>woken</code>：表示是否从有唤醒的 goroutine</li><li><code>starving</code>：表示此锁是否进入饥饿状态</li><li><code>waitersCount</code>：表示等待此锁的 goroutine 的数量</li></ul><h3 id=饥饿模式>饥饿模式
<a class=anchor href=#%e9%a5%a5%e9%a5%bf%e6%a8%a1%e5%bc%8f>#</a></h3><p>请求锁的 goroutine 有两类，一类是新来请求锁的 goroutine，另一类是被唤醒的等待请求锁的 goroutine。</p><p>由于新来的 goroutine 也参与竞争锁，极端情况下，等待中的 goroutine 可能一直获取不到锁，这就是<strong>饥饿问题</strong>。</p><p>为了解决饥饿，Go 1.9 中为 mutex 增加了<strong>饥饿模式</strong>。</p><p>在正常模式下，等待中的 goroutine 会按照先进先出的顺序获取锁。但是如果新来的 goroutine 竞争锁，等待中的 goroutine 大概率是获取不到锁的。一旦 goroutine 超
过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式，保证锁的公平性。</p><p>在饥饿模式中，互斥锁会直接交给等待队列最前面的 goroutine。新来的 goroutine 在该状态下不能获取锁、也不会进入自旋状态，只会在队列的末尾等待。</p><p>下面两种情况，mutex 会切换为正常模式:</p><ul><li>一个 goroutine 获得了锁并且它在队列的末尾</li><li>一个 goroutine 等待的时间少于 1ms</li></ul><h3 id=lock>Lock
<a class=anchor href=#lock>#</a></h3><p><code>Lock</code> 的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mutexLocked</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mutexWoken</span> <span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mutexStarving</span> <span style=color:#75715e>// 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mutexWaiterShift</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>starvationThresholdNs</span> = <span style=color:#ae81ff>1e6</span> <span style=color:#75715e>// 1000000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>Lock</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fast path: grab unlocked mutex.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 没有 goroutine 持有锁，也没有等待的 goroutine，当前 goroutine 可以直接获得锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>mutexLocked</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enabled</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>m</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Slow path (outlined so that the fast path can be inlined)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 通过自旋等方式竞争锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockSlow</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>lockSlow</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>waitStartTime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>starving</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span> <span style=color:#75715e>// 当前 goroutine 的饥饿标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>awoke</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span> <span style=color:#75715e>// 唤醒标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>iter</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 自旋次数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>old</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span> <span style=color:#75715e>// 当前锁的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 锁是非饥饿模式并且还没被释放，尝试自旋
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>mutexLocked</span>|<span style=color:#a6e22e>mutexStarving</span>) <span style=color:#f92672>==</span> <span style=color:#a6e22e>mutexLocked</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>runtime_canSpin</span>(<span style=color:#a6e22e>iter</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 尝试设置 mutexWoken 标志来通知解锁，以避免唤醒其他阻塞的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>awoke</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mutexWoken</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#a6e22e>mutexWaiterShift</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> 
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>old</span>|<span style=color:#a6e22e>mutexWoken</span>) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>awoke</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>runtime_doSpin</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>iter</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>old</span> = <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span> <span style=color:#75715e>// 再次获取锁的状态，后面会检查锁是否被释放了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>new</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>old</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mutexStarving</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>new</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>mutexLocked</span> <span style=color:#75715e>// 非饥饿状态，加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>mutexLocked</span>|<span style=color:#a6e22e>mutexStarving</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>new</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>mutexWaiterShift</span> <span style=color:#75715e>// waiter 数量加 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>starving</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mutexLocked</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>new</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>mutexStarving</span> <span style=color:#75715e>// 设置饥饿状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>awoke</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// The goroutine has been woken from sleep, 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// so we need to reset the flag in either case. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>new</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mutexWoken</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;sync: inconsistent mutex state&#34;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>new</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#a6e22e>mutexWoken</span> <span style=color:#75715e>// 新状态清除唤醒标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置新状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 再次检查，原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>mutexLocked</span>|<span style=color:#a6e22e>mutexStarving</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span> <span style=color:#75715e>// locked the mutex with CAS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 处理饥饿状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 如果之前就在该队列里面，就加入到队列头
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>queueLifo</span> : <span style=color:#a6e22e>waitStartTime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>waitStartTime</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>waitStartTime</span> = <span style=color:#a6e22e>runtime_nanotime</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>            <span style=color:#75715e>// runtime_SemacquireMutex 通过信号量保证资源不会被两个 goroutine 获取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// runtime_SemacquireMutex 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 也就是这里会阻塞等待
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 一旦当前 goroutine 可以获取信号量，它就会立刻返回，剩余代码也会继续执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>runtime_SemacquireMutex</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>sema</span>, <span style=color:#a6e22e>queueLifo</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 在饥饿模式下，当前 goroutine 会获得锁，如果等待队列中只存在当前 goroutine，锁还会从饥饿模式中退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>starving</span> = <span style=color:#a6e22e>starving</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>runtime_nanotime</span>()<span style=color:#f92672>-</span><span style=color:#a6e22e>waitStartTime</span> &gt; <span style=color:#a6e22e>starvationThresholdNs</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>old</span> = <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mutexStarving</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>mutexLocked</span>|<span style=color:#a6e22e>mutexWoken</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#a6e22e>mutexWaiterShift</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;sync: inconsistent mutex state&#34;</span>)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>delta</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>mutexLocked</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#a6e22e>mutexWaiterShift</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>starving</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#a6e22e>mutexWaiterShift</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>delta</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>mutexStarving</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>delta</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>awoke</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>iter</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>old</span> = <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>m</span>))
</span></span><span style=display:flex><span>	}	
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=自旋>自旋
<a class=anchor href=#%e8%87%aa%e6%97%8b>#</a></h4><p>自旋是一种多线程同步机制，<strong>当前的进程在进入自旋的过程中会一直保持 CPU 的占用</strong>，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 goroutine 的切换，使用恰当
会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 goroutine 进入自旋的条件非常苛刻：</p><ol><li><code>old&(mutexLocked|mutexStarving) == mutexLocked</code> 只有在普通模式</li><li><code>runtime_canSpin(iter)</code> 为真：<ul><li>运行在多 CPU 的机器上</li><li>自旋的次数小于四次</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空</li></ul></li></ol><p>进入自旋会调用 <code>runtime_doSpin()</code>，并执行 30 次的 PAUSE 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:linkname sync_runtime_doSpin sync.runtime_doSpin
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:nosplit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_doSpin</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>procyield</span>(<span style=color:#a6e22e>active_spin_cnt</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>procyield</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>cycles</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>again</span>:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PAUSE</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SUBL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>JNZ</span>	<span style=color:#a6e22e>again</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><h3 id=unlock>Unlock
<a class=anchor href=#unlock>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>Unlock</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Release</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>m</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Fast path: drop lock bit.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// new == 0 成功释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>new</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>mutexLocked</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>new</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Outlined slow path to allow inlining the fast path.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>unlockSlow</span>(<span style=color:#a6e22e>new</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>unlockSlow</span>(<span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int32</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>new</span><span style=color:#f92672>+</span><span style=color:#a6e22e>mutexLocked</span>)<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mutexLocked</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// unlock 一个未加锁的锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>fatal</span>(<span style=color:#e6db74>&#34;sync: unlock of unlocked mutex&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>new</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mutexStarving</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 正常模式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>old</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>new</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 不存在等待者 或者 mutexLocked、mutexStarving、mutexWoken 状态不都为 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 则不需要唤醒其他等待者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#a6e22e>mutexWaiterShift</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>old</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>mutexLocked</span>|<span style=color:#a6e22e>mutexWoken</span>|<span style=color:#a6e22e>mutexStarving</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 存在等待者，通过 runtime_Semrelease 唤醒等待者并移交锁的所有权
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>new</span> = (<span style=color:#a6e22e>old</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#a6e22e>mutexWaiterShift</span>) | <span style=color:#a6e22e>mutexWoken</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span>) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>runtime_Semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>sema</span>, <span style=color:#66d9ef>false</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>old</span> = <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 饥饿模式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 直接调用 runtime_Semrelease 将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时还不会退出饥饿状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>runtime_Semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>sema</span>, <span style=color:#66d9ef>true</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/71b3cd60afb327324631b06ed0522cc3c6479070 title='Last modified by PengQi Shi | November 27, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 27, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/concurrency/01_mutex.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#互斥锁>互斥锁</a><ul><li><a href=#使用>使用</a><ul><li><a href=#为什么一定要加锁>为什么一定要加锁？</a></li></ul></li><li><a href=#原理>原理</a><ul><li><a href=#饥饿模式>饥饿模式</a></li><li><a href=#lock>Lock</a></li><li><a href=#unlock>Unlock</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>