---
title: 读写锁
weight: 2
---

# 读写锁

如果有多个 goroutine 读取变量，那么是并发安全的，这个时候使用 `sync.Mutex` 加锁就没有必要。可以使
用 `sync.RWMutex` 读写锁（多读单写锁）。

**读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护**。

一个读写锁中实际上包含了两个锁，即：**读锁**和**写锁**。`sync.RWMutex` 类型中的 `Lock` 方法和 `Unlock` 方法用于对写锁进行锁定和解锁，
`RLock` 方法和 `RUnlock` 方法则分别用于对读锁进行锁定和解锁。

对于某个受到读写锁保护的共享资源，

1. 多个写操作不能同时进行
2. 写操作和读操作不能同时进行
3. 多个读操作可以同时进行

```go
var mu sync.RWMutex
var balance int
func Balance() int {
  mu.RLock() // readers lock
  defer mu.RUnlock()
  return balance
}
```

**为什么只读操作也需要加锁**？

```go
var x, y int
go func() {
  x = 1 // A1
  fmt.Print("y:", y, " ") // A2
}()
go func() {
  y = 1                   // B1
  fmt.Print("x:", x, " ") // B2
}()
```

上面的代码打印的结果可能是：

```bash
y:0 x:1
x:0 y:1
x:1 y:1
y:1 x:1

# 还可能是
x:0 y:0
y:0 x:0
```

为什么会有 `x:0 y:0` 这种结果，在一个 goroutine 中，语句的执行顺序可以保证，在声明的例子，可以保证
执行 `x = 1` 后打印 `y:`，但是不能保证打印 `y:` 时，另一个 goroutine 中 `y = 1` 是否已经执行。

所以可能的话，将变量限定在 goroutine 内部；如果是多个 goroutine 都需要访问的变量，使用互斥条件来访问。

### 注意事项

- 不要重复锁定互斥锁；**对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine 的**。这个 goroutine 所执行的流程，
  会一直停滞在调用该互斥锁的 `Lock` 方法的那行代码上。直到该互斥锁的 `Unlock`方法被调用，并且这里的锁定操作成功完成，后续的代码
  （也就是临界区中的代码）才会开始执行。这也正是互斥锁能够保护临界区的原因所在。
- 不要忘记解锁互斥锁，必要时使用 `defer` 语句；避免重复锁定。
- 不要对尚未锁定或者已解锁的互斥锁解锁；**解锁“读写锁中未被锁定的写锁”，会立即引发 panic**，对于其中的读锁也是如此，并且同
  样是不可恢复的。
- **不要在多个函数之间直接传递互斥锁。一旦，你把一个互斥锁同时用在了多个地方，就必然会有更多的 goroutine 争用这把锁**。
  这不但会让你的程序变慢，还会大大增加死锁（`deadlock`）的可能性。

所谓的**死锁**，指的就是当前程序中的主 goroutine，以及我们启用的那些 goroutine 都已经被阻塞。这些 goroutine 可以被统
称为用户级的 goroutine。这就相当于整个程序都已经停滞不前了。

Go 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 goroutine 都处于等待状态，就会自行抛出一个带有如下
信息的 panic：`fatal error: all goroutines are asleep - deadlock!`

**注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用 recover 函数对它们起不到任何作用。
也就是说，一旦产生死锁，程序必然崩溃**。

**最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区**。