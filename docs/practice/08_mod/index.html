<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go Modules # Go 在 1.11 推出了 Go Modules，这是一个新的包管理器，解决了 GOPATH 存在的问题。并且 Go 1.13 起不再推荐使用 GOPATH。
Go Modules 机制 # Go Modules 将依赖缓存放在 $GOPATH/pkg/mod 目录，并且同一个依赖的版本，只会缓存一份，供所有项目使用。
启用 Go Modules # Go 1.11 引入了环境变量 GO111MODULE 来控制是否启用 Go Modules，GO111MODULE 有三个值可选：
on 启用 Go Modules off 禁用 Go Modules auto，在 GOPATH 下的项目，使用 GOPATH，否则启用 Go Modules。 Go 1.16 之前 GO111MODULE 的默认值是 auto，Go 1.16 起 GO111MODULE 的默认值为 on。
初始化 # 初始化 Go Modules 项目，首先要开启 Go Modules，然后在项目目录下运行："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Go Modules"><meta property="og:description" content="Go Modules # Go 在 1.11 推出了 Go Modules，这是一个新的包管理器，解决了 GOPATH 存在的问题。并且 Go 1.13 起不再推荐使用 GOPATH。
Go Modules 机制 # Go Modules 将依赖缓存放在 $GOPATH/pkg/mod 目录，并且同一个依赖的版本，只会缓存一份，供所有项目使用。
启用 Go Modules # Go 1.11 引入了环境变量 GO111MODULE 来控制是否启用 Go Modules，GO111MODULE 有三个值可选：
on 启用 Go Modules off 禁用 Go Modules auto，在 GOPATH 下的项目，使用 GOPATH，否则启用 Go Modules。 Go 1.16 之前 GO111MODULE 的默认值是 auto，Go 1.16 起 GO111MODULE 的默认值为 on。
初始化 # 初始化 Go Modules 项目，首先要开启 Go Modules，然后在项目目录下运行："><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/practice/08_mod/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-12-03T21:59:10+08:00"><title>Go Modules | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.85ac43de481b0867c3ed54a5a2263e836d58519eeddb4df16af262f7ed157d12.js integrity="sha256-haxD3kgbCGfD7VSloiY+g21YUZ7t203xavJi9+0VfRI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础数据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li><li><a href=/golang-learn/docs/concurrency/12_errorgroup/>ErrGroup</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go Core Dump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/ class=active>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li></ul></li><li><span>🛠️ Go 工程实践</span><ul><li><a href=/golang-learn/docs/project/01_specs/>项目规范</a></li><li><a href=/golang-learn/docs/project/02_structure/>项目的目录结构</a></li><li><a href=/golang-learn/docs/project/03_code/>代码规范</a></li><li><a href=/golang-learn/docs/project/04_commitizen/>Commit 规范</a></li><li><a href=/golang-learn/docs/project/05_version/>版本规范</a></li><li><a href=/golang-learn/docs/project/06_api_doc/>API 文档</a></li><li><a href=/golang-learn/docs/project/07_flow/>Git 工作流程</a></li><li><a href=/golang-learn/docs/project/08_make/>项目管理</a></li><li><a href=/golang-learn/docs/project/09_actions/>GitHub Actions</a></li><li><a href=/golang-learn/docs/project/10_dependabot/>GitHub Dependabot</a></li><li><a href=/golang-learn/docs/project/11_templates/>GitHub 模板</a></li><li><a href=/golang-learn/docs/project/12_goreleaser/>GoReleaser</a></li></ul></li><li><a href=/golang-learn/docs/advance/>🔍 底层原理</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go Modules</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#go-modules>Go Modules</a><ul><li><a href=#go-modules-机制>Go Modules 机制</a><ul><li><a href=#启用-go-modules>启用 Go Modules</a></li><li><a href=#初始化>初始化</a></li><li><a href=#下载依赖>下载依赖</a></li><li><a href=#go-modules-代理>Go Modules 代理</a></li><li><a href=#goprivate>GOPRIVATE</a></li><li><a href=#gomod-文件>go.mod 文件</a></li><li><a href=#gosum-文件>go.sum 文件</a></li></ul></li><li><a href=#go-mod-命令>go mod 命令</a><ul><li><a href=#迁移回-vendor-模式>迁移回 vendor 模式</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#设置-http-proxy-却仍然无法下载依赖>设置 HTTP Proxy 却仍然无法下载依赖</a></li><li><a href=#清理缓存>清理缓存</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=go-modules>Go Modules
<a class=anchor href=#go-modules>#</a></h1><p>Go 在 1.11 推出了 Go Modules，这是一个新的包管理器，解决了 <code>GOPATH</code> 存在的问题。并且 Go 1.13 起不再推荐使用 GOPATH。</p><h2 id=go-modules-机制>Go Modules 机制
<a class=anchor href=#go-modules-%e6%9c%ba%e5%88%b6>#</a></h2><p>Go Modules 将依赖缓存放在 <code>$GOPATH/pkg/mod</code> 目录，并且<strong>同一个依赖的版本，只会缓存一份，供所有项目使用</strong>。</p><h3 id=启用-go-modules>启用 Go Modules
<a class=anchor href=#%e5%90%af%e7%94%a8-go-modules>#</a></h3><p>Go 1.11 引入了环境变量 <code>GO111MODULE</code> 来控制是否启用 Go Modules，<code>GO111MODULE</code> 有三个值可选：</p><ul><li><code>on</code> 启用 Go Modules</li><li><code>off</code> 禁用 Go Modules</li><li><code>auto</code>，在 <code>GOPATH</code> 下的项目，使用 <code>GOPATH</code>，否则启用 Go Modules。</li></ul><p>Go 1.16 之前 <code>GO111MODULE</code> 的默认值是 <code>auto</code>，Go 1.16 起 <code>GO111MODULE</code> 的默认值为 <code>on</code>。</p><h3 id=初始化>初始化
<a class=anchor href=#%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h3><p>初始化 Go Modules 项目，首先要开启 Go Modules，然后在项目目录下运行：</p><pre tabindex=0><code>$ go mod init &lt;project-path&gt;
</code></pre><h3 id=下载依赖>下载依赖
<a class=anchor href=#%e4%b8%8b%e8%bd%bd%e4%be%9d%e8%b5%96>#</a></h3><p>下载依赖使用 <code>go get</code> 命令，命令格式为 <code>go get &lt;package[@version]></code>。</p><ul><li><code>go get golang.org/x/test@latest</code>，<code>@latest</code> 表示选择最新的稳定版本，例如 <code>v1.2.3</code>。如果没有稳定版本，选择最新的预发布版本，例如 <code>v1.2.3-alpha.1</code>。
如果依赖没有 tag，那么选择最新的 commit。</li><li><code>go get golang.org/x/test</code> 同上。</li><li><code>go get golang.org/x/test@v1.2.3</code> 下载 tag 为 <code>v1.2.3</code> 的版本。</li><li><code>go get golang.org/x/test@v0</code> 下载 tag 前缀为 <code>v0</code> 的版本。</li><li><code>go get golang.org/x/test@master</code> 下载 master 分支上最新的 commit。</li><li><code>go get golang.org/x/test@37s237s</code> 下载哈希值为 <code>37s237s</code> 的 commit，如果该 commit 存在对应的 tag，转换为 tag 并下载。</li></ul><p><code>go get -u</code> 更新现有的依赖。</p><h3 id=go-modules-代理>Go Modules 代理
<a class=anchor href=#go-modules-%e4%bb%a3%e7%90%86>#</a></h3><p>国内是无法访问 <code>golang.org</code> 的，Go 1.13 引入了环境变量 <code>GOPROXY</code>，可以用来设置 Go Modules 的代理。</p><p><code>GOPROXY</code> 的默认值为 <code>https://proxy.golang.org,direct</code>，<code>GOPROXY</code> 可以设置多个，用 <code>,</code> 分隔。</p><p>执行 <code>go get/install</code> 时会优先从代理服务器下载依赖。如果从一个代理服务器下载失败，当遇见 <code>direct</code> 时，表示回源到依赖的源地址去下载。</p><h4 id=设置-goproxy>设置 GOPROXY
<a class=anchor href=#%e8%ae%be%e7%bd%ae-goproxy>#</a></h4><p>使用 <code>go env -w GOPROXY=https://goproxy.cn,direct</code> 命令来设置 <code>GOPROXY</code> 的值。</p><h3 id=goprivate>GOPRIVATE
<a class=anchor href=#goprivate>#</a></h3><p>如果项目有一个私有依赖，设置 <code>GOPROXY</code> 也无法访问，可以使用 <code>GOPRIVATE</code>。</p><p>比如 <code>GOPRIVATE=corp.example.com,github.com/pookt/demo</code> 表示前缀可以匹配 <code>corp.example.com</code> 或者 <code>github.com/pookt/demo</code> 的依赖都会被认为是私有依赖。</p><p><code>GOPRIVATE</code> 支持通配符，例如 <code>*.example.com</code>。</p><p><code>GOPRIVATE</code> 较为特殊，它的值将作为 <code>GONOPROXY</code> 和 <code>GONOSUMDB</code> 的默认值。所以只使用 <code>GOPRIVATE</code> 就足够。</p><h3 id=gomod-文件>go.mod 文件
<a class=anchor href=#gomod-%e6%96%87%e4%bb%b6>#</a></h3><p><code>go.mod</code> 是 Go Modules 项目所必须的最重要的文件，描述了当前项目的元信息，目前有 5 个关键字：</p><ul><li><code>module</code>：定义当前项目的模块路径。</li><li><code>go</code>：预期的 Go 版本。</li><li><code>require</code>：指定项目的依赖版本，格式为<code>&lt;依赖的路径> &lt;版本> [// indirect]</code>。</li><li><code>exclude</code>：排除一个特定的依赖版本。</li><li><code>replace</code>：将一个依赖版本替换为另外一个依赖版本，格式为 <code>module => newmodule</code>。</li></ul><pre tabindex=0><code>module example.com/foobar

go 1.13

require (
    example.com/apple v0.1.2
    example.com/pear v1.2.3
    example.com/watermelon v3.3.10+incompatible
    example.com/banana/v2 v2.3.4 // indirect
    example.com/pineapple v0.0.0-20190924185754-1b0db40df49a
)

exclude example.com/banana v1.2.4
replace example.com/apple v0.1.2 =&gt; example.com/rda v0.1.0 
replace example.com/banana =&gt; example.com/hugebanana
</code></pre><h4 id=replace>replace
<a class=anchor href=#replace>#</a></h4><p><code>replace</code> 是用来将一个依赖版本替换为另外一个依赖版本，格式为 <code>module => newmodule</code>。</p><ul><li><code>newmodule</code> 可以是本地相对路径，例如 <code>github.com/gin-gonic/gin => ./gin</code>。</li><li><code>newmodule</code> 也可以是本地绝对路径，例如 <code>github.com/gin-gonic/gin => /home/root/gin</code>。</li><li><code>newmodule</code> 可以是网络路径，例如 <code>golang.org/x/text v0.3.2 => github.com/golang/text v0.3.2</code>。</li></ul><h4 id=依赖的导入路径说明>依赖的导入路径说明
<a class=anchor href=#%e4%be%9d%e8%b5%96%e7%9a%84%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84%e8%af%b4%e6%98%8e>#</a></h4><p>上面示例中 <code>example.com/banana/v2 v2.3.4</code>，<code>example.com/banana/v2</code> 的导入路径有 <code>/v2</code> 为什么其他依赖的导入路径没有 <code>/v0</code> 或者 <code>/v1</code>。</p><p>因为 Go modules 在主版本号为 <code>v0</code> 和 <code>v1</code> 的情况下省略了版本号，不需要在模块导入路径包含主版本的信息。而在主版本号为 <code>v2</code> 及以上则需要在导入路径末尾加上主版本号。</p><h4 id=v000-xxx-是什么版本>v0.0.0-xxx 是什么版本
<a class=anchor href=#v000-xxx-%e6%98%af%e4%bb%80%e4%b9%88%e7%89%88%e6%9c%ac>#</a></h4><p>Go 拉去的依赖如果没有 tag，那么选择最新的 commit。例如上面示例中的 <code>example.com/pineapple v0.0.0-20190924185754-1b0db40df49a</code>。</p><p><code>v0.0.0</code> 是因为 <code>example.com/pineapple</code> 这个依赖不存在 tag，<code>20190924185754</code> 最新一次 commit 的 commit 时间，<code>1b0db40df49a</code> 是 commit 的哈希值。</p><h4 id=indirect>indirect
<a class=anchor href=#indirect>#</a></h4><p>上面示例中的 <code>example.com/banana/v2 v2.3.4 // indirect</code>。<code>indirect</code> 表示该依赖为间接依赖。</p><p>通常上 <code>go.mod</code> 中出现的都应该是直接依赖，但是下面的两种情况会在 <code>go.mod</code> 中添加间接依赖：</p><ul><li>当前项目的某个直接依赖没有使用 Go Modules。</li><li>当前项目的某个直接依赖的 <code>go.mod</code> 文件中缺失某个依赖，那么这个缺失的依赖会被添加在当前项目的 <code>go.mod</code> 文件中，作为间接依赖。</li></ul><h4 id=incompatible>incompatible
<a class=anchor href=#incompatible>#</a></h4><p>上面示例中的 <code>example.com/watermelon v3.3.10+incompatible</code>。<code>incompatible</code> 表示该依赖的路径跟版本不符合规范，<code>v3.3.10</code> 版本按照规范，引用路径应该为 <code>example.com/watermelon/v3</code>。
所以 Go 会在版本后加上 <code>+incompatible</code>。</p><h3 id=gosum-文件>go.sum 文件
<a class=anchor href=#gosum-%e6%96%87%e4%bb%b6>#</a></h3><p><code>go.sum</code> 列出了当前项目所有直接或间接依赖的版本，记录每个依赖的哈希值，目的是为了保证项目所依赖的版本不会被篡改。</p><h2 id=go-mod-命令>go mod 命令
<a class=anchor href=#go-mod-%e5%91%bd%e4%bb%a4>#</a></h2><p><code>go mod</code> 常用的几个子命令：</p><ul><li><code>init</code>：初始化 <code>go.mod</code> 文件</li><li><code>tidy</code>：自动添加项目依赖，并移除无用的依赖</li><li><code>download</code>：下载依赖到本地缓存。</li><li><code>graph</code>：查看现有的依赖结构</li><li><code>why</code>：查看为什么需要一个依赖</li></ul><h3 id=迁移回-vendor-模式>迁移回 vendor 模式
<a class=anchor href=#%e8%bf%81%e7%a7%bb%e5%9b%9e-vendor-%e6%a8%a1%e5%bc%8f>#</a></h3><p><code>go mod vendor</code> 可以将 Go Modules 迁移回到模式。</p><p>这个命令并只是单纯地把 <code>go.sum</code> 中的所有依赖下载到 <code>vendor</code> 目录里。</p><p>再使用 <code>go build -mod=vendor</code> 来构建项目，因为在 Go Modules 模式下 <code>go build</code> 是屏蔽 vendor 机制的。</p><p>注意发布时需要带上 vendor 目录。</p><h2 id=其他>其他
<a class=anchor href=#%e5%85%b6%e4%bb%96>#</a></h2><h3 id=设置-http-proxy-却仍然无法下载依赖>设置 HTTP Proxy 却仍然无法下载依赖
<a class=anchor href=#%e8%ae%be%e7%bd%ae-http-proxy-%e5%8d%b4%e4%bb%8d%e7%84%b6%e6%97%a0%e6%b3%95%e4%b8%8b%e8%bd%bd%e4%be%9d%e8%b5%96>#</a></h3><p>通常如果设置了 HTTP Proxy，<code>go get/install</code> 会使用指定的代理去下载依赖，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># windows</span>
</span></span><span style=display:flex><span>set http_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>set https_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># linux</span>
</span></span><span style=display:flex><span>export http_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>export https_proxy<span style=color:#f92672>=</span>http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span></code></pre></div><p>但是，如果拉取的依赖是使用 Git 作为源控制管理器，那么还需要配置 Git 的 Proxy，否则还是无法下载依赖：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git config --global http.proxy http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span><span style=display:flex><span>git config --global https.proxy http://<span style=color:#f92672>[</span>user<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>pass<span style=color:#f92672>]</span>@<span style=color:#f92672>[</span>proxy_ip<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>proxy_port<span style=color:#f92672>]</span>/
</span></span></code></pre></div><h3 id=清理缓存>清理缓存
<a class=anchor href=#%e6%b8%85%e7%90%86%e7%bc%93%e5%ad%98>#</a></h3><p><code>go clean -modcache</code> 可以用来清理所有缓存的依赖。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/2693fbeb9296c498083681526ce91c2a5190c392 title='Last modified by PengQi Shi | December 3, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 3, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/practice/08_mod.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#go-modules>Go Modules</a><ul><li><a href=#go-modules-机制>Go Modules 机制</a><ul><li><a href=#启用-go-modules>启用 Go Modules</a></li><li><a href=#初始化>初始化</a></li><li><a href=#下载依赖>下载依赖</a></li><li><a href=#go-modules-代理>Go Modules 代理</a></li><li><a href=#goprivate>GOPRIVATE</a></li><li><a href=#gomod-文件>go.mod 文件</a></li><li><a href=#gosum-文件>go.sum 文件</a></li></ul></li><li><a href=#go-mod-命令>go mod 命令</a><ul><li><a href=#迁移回-vendor-模式>迁移回 vendor 模式</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#设置-http-proxy-却仍然无法下载依赖>设置 HTTP Proxy 却仍然无法下载依赖</a></li><li><a href=#清理缓存>清理缓存</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>