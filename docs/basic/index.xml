<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🍚 语言基础 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/docs/basic/</link><description>Recent content in 🍚 语言基础 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/docs/basic/index.xml" rel="self" type="application/rss+xml"/><item><title>基础据类型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</guid><description>数值类型 # 整型 # uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数 # float32，IEEE-754 32 位浮点型数，math.</description></item><item><title>数组</title><link>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</guid><description>数组 # 数组是一个由固定长度，并且相同类型的元素组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素。
存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。
Go 是值传递，所以函数参数变量接收的是一个值的副本。这种机制，在传递一个大数组时，效率较低。这个时候可以显示的传入一个数组指针（其他语言其实是隐式的指针传递）。
func test(ptr *[32]byte) { *ptr = [32]byte{} } 初始化 # arr1 := [3]int{1, 2, 3} arr2 := [...]int{1, 2, 3} // `...` 省略号，表示数组的长度是根据初始化值的个数来计算 数组的长度在编译阶段确定，初始化之后大小就无法改变。
// NewArray returns a new fixed-length array Type. func NewArray(elem *Type, bound int64) *Type { if bound &amp;lt; 0 { base.Fatalf(&amp;#34;NewArray: invalid bound %v&amp;#34;, bound) } t := newType(TARRAY) t.extra = &amp;amp;Array{Elem: elem, Bound: bound} if elem.HasShape() { t.</description></item><item><title>切片</title><link>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</guid><description>切片 # slice 的语法和数组很像，由于数组长度是固定的，所以使用 slice 相比数组会更灵活，slice 是动态的。
切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型。
定义切片，和定义数组的区别就是不需要指定 SIZE：
var 变量名 []类型 一个 slice 由三个部分构成：指针、长度和容量。长度不能超过容量。 一个切片在未初始化之前默认为 nil，长度为 0。
初始化切片：
// 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3.其 cap=len=3 s :=[]int {1,2,3} // 初始化切片 s,是数组 arr 的引用 s := arr[:] // 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片 s := arr[startIndex:endIndex] // 缺省 endIndex 时将表示一直到 arr 的最后一个元素 s := arr[startIndex:] // 缺省 startIndex 时将表示从 arr 的第一个元素开始 s := arr[:endIndex] // 使用 make 函数来创建切片 // len 是数组的长度并且也是切片的初始长度 // capacity 为可选参数, 指定容量 s := make([]int, len, capacity) len() 和 cap() # len获取切片长度。 cap计算切片的最大容量 append() 和 copy() # append 向切片追加新元素 copy 拷贝切片 append 的使用 # 使用 append 函数时要注意，append 总是从 slice 的尾部开始追加数据。比如下面的代码：</description></item><item><title>map</title><link>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</guid><description>map # map 是一个无序的 key/value 对的集合。map 是引用类型。这意味着它拥有对底层数据结构的引用， 就像指针一样。它底层的数据结构是 hash table 或 hash map。
map 作为引用类型是非常好的，因为无论 map 有多大，都只会有一个副本。
定义 map，使用 map 关键字：
/* 声明变量，默认 map 是 nil */ var 变量名 map[键类型]值类型 /* 使用 make 函数 */ 变量名 := make(map[键类型]值类型) /* 字面值的语法创建 */ 变量名 := map[键类型]值类型{ key1: value1, key2: value2, ... } 一个 map 在未初始化之前默认为 nil。 通过索引下标 key 来访问 map 中对应的 value
age, ok := ages[&amp;#34;bob&amp;#34;] if !ok { /* &amp;#34;bob&amp;#34; is not a key in this map; age == 0.</description></item><item><title>函数</title><link>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</guid><description>函数 # 声明函数 # func 关键字声明函数：
func 函数名(形式参数列表) (返回值列表) { 函数体 } 如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。如果一个函数声明没有返回值列表，那么这个 函数不会返回任何值。
// 两个 int 类型参数 返回一个 int 类型的值 func max(num1, num2 int) int { /* 定义局部变量 */ var result int if (num1 &amp;gt; num2) { result = num1 } else { result = num2 } return result } // 返回多个类型的值 func swap(x int, y string) (string, int) { return y, x } // 有名返回值 func Size(rect image.</description></item><item><title>接口</title><link>https://shipengqi.github.io/golang-learn/docs/basic/06_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/06_interface/</guid><description>接口 # Go 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实 现了这个接口，无须显示声明。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。
一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。
接口的零值就是它的类型和值的部分都是 nil。
简单的说，interface 是一组 method 的组合，我们通过 interface 来定义对象的一组行为。
定义接口：
type 接口名 interface { 方法名1 [返回类型] 方法名2 [返回类型] 方法名3 [返回类型] ... } /* 定义结构体 */ type struct_name struct { /* variables */ } /* 实现接口方法 */ func (struct_name_variable struct_name) 方法名1() [返回类型] { /* 方法实现 */ } ... func (struct_name_variable struct_name) 方法名2() [返回类型] { /* 方法实现*/ } 实例：
type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.</description></item><item><title>反射</title><link>https://shipengqi.github.io/golang-learn/docs/basic/07_reflect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/07_reflect/</guid><description>反射 # 反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道 这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。
reflect.TypeOf # reflect.TypeOf 获取类型信息。 reflect.TypeOf 接受任意的 interface{} 类型, 并以 reflect.Type 形式返回其动态类型：
t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; type X int func main() { var a X = 20 t := reflect.TypeOf(a) fmt.Println(t.Name(), t.Kind()) // X int } 上面的代码，注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型。所以在判断类型时， 要选择正确的方式。
type X int type Y int func main() { var a, b X = 10, 20 var c Y = 30 ta, tb, tc := reflect.</description></item><item><title>泛型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/08_generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/08_generic/</guid><description> 泛型 #</description></item><item><title>指针</title><link>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</guid><description>指针 # 指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个 保存内存地址的整形变量。
x := 1 p := &amp;amp;x // p, of type *int, points to x fmt.Println(*p) // &amp;#34;1&amp;#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &amp;#34;2&amp;#34; 上面的代码，初始化一个变量 x，&amp;amp; 是取地址操作，&amp;amp;x 就是取变量 x 的内存地址，那么 p 就是一个指针， 类型是 *int，p 这个指针保存了变量 x 的内存地址。接下来 *p 表示读取指针指向的变量的值，也就是变量 x 的值 1。 *p也可以被赋值。
任何类型的指针的零值都是 nil。当指针指向同一个变量或者 nil 时是相等的。 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
指向指针的指针 # var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;amp;a /* 指向指针 ptr 地址 */ pptr = &amp;amp;ptr /* 获取 pptr 的值 */ fmt.</description></item><item><title>range</title><link>https://shipengqi.github.io/golang-learn/docs/basic/10_range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/10_range/</guid><description>range # 带有 range 子句的 for 语句会先把被遍历的字符串值拆成一个字节序列（注意是字节序列），然后再试图找出这个字节序列中 包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。
这样的 for 语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码 值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 rune。
str := &amp;#34;Go 爱好者 &amp;#34; for i, c := range str { fmt.Printf(&amp;#34;%d: %q [% x]\n&amp;#34;, i, c, []byte(string(c))) } 完整的打印内容如下：
0: &amp;#39;G&amp;#39; [47] 1: &amp;#39;o&amp;#39; [6f] 2: &amp;#39;爱&amp;#39; [e7 88 b1] 5: &amp;#39;好&amp;#39; [e5 a5 bd] 8: &amp;#39;者&amp;#39; [e8 80 85] 注意了，&amp;lsquo;爱&amp;rsquo;是由三个字节共同表达的，所以第四个 Unicode 字符&amp;rsquo;好&amp;rsquo;对应的索引值并不是 3，而是 2 加 3 后得到的 5。</description></item><item><title>select</title><link>https://shipengqi.github.io/golang-learn/docs/basic/11_select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/11_select/</guid><description>select # select 类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。
当条件满足时，select 会去通信并执行 case 之后的语句，这时候其它通信是不会执行的。 如果多个 case 同时满足条件，select 会随机地选择一个执行。如果没有 case 可运行，它将阻塞，直到有 case 可运行。
一个默认的子句应该总是可运行的。
select { case communication clause: ... case communication clause: ... default: /* 可选 */ ... } for range 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。for range 会复制目标数据。可改用数组指针或者切片。
range 关键字右边的位置上的代码被称为 range 表达式。
range 表达式只会在 for 语句开始执行时被求值一次，无论后边会有多少次迭代； range 表达式的求值结果会被复制，也就是说，被迭代的对象是 range 表达式结果值的副本而不是原值。 for range 在性能比 for 稍差，因为 for range 会进行值拷贝。 字符串的复制成本很小，切片，字典，通道等引用类型本身是指针的封装，复制成本也很小，无序专门优化。
如果 range 的目标表达式是函数，也只会运行一次。
numbers1 := []int{1, 2, 3, 4, 5, 6} for i := range numbers1 { if i == 3 { numbers1[i] |= i } } fmt.</description></item><item><title>defer</title><link>https://shipengqi.github.io/golang-learn/docs/basic/12_defer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/12_defer/</guid><description> defer #</description></item><item><title>panic</title><link>https://shipengqi.github.io/golang-learn/docs/basic/13_panic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/13_panic/</guid><description>panic # Panic 异常 # Go 运行时错误会引起 painc 异常。 一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（defer 机制）。随后，程序崩溃 并输出日志信息。
由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使 用 Go 提供的错误机制，而不是 panic，尽量避免程序的崩溃。
panic 函数 # panic 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 panic。
panic 详情中都有什么 # panic: runtime error: index out of range goroutine 1 [running]: main.main() /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d exit status 2 第一行是 panic: runtime error: index out of range。其中的 runtime error 的含义是，这是一个 runtime 代码包中 抛出的 panic。
goroutine 1 [running]，它表示有一个 ID 为1的 goroutine 在此 panic 被引发的时候正在运行。这里的 ID 其实并不重要。</description></item><item><title>make 和 new</title><link>https://shipengqi.github.io/golang-learn/docs/basic/14_make_new/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/14_make_new/</guid><description> make 和 new #</description></item><item><title>面向对象</title><link>https://shipengqi.github.io/golang-learn/docs/basic/15_oop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/15_oop/</guid><description>面向对象 # GO 支持面向对象编程。
方法 # 方法声明：
func (变量名 类型) 方法名() [返回类型]{ /* 函数体*/ } 实例：
/* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&amp;#34;Area of Circle(c1) = &amp;#34;, c1.getArea()) } // 该 method 属于 Circle 类型对象中的方法 // 这里的 c 叫作方法的接收器，类似 Javascript 的 this func (c Circle) getArea() float64 { // c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.</description></item></channel></rss>