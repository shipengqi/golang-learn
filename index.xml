<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>主要内容 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/</link><description>Recent content in 主要内容 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 编译</title><link>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</guid><description>Go 编译 # 条件编译 # Go 支持两种条件编译方式：
编译标签（build tag） 文件后缀 编译标签 # 编译标签的规则：
空格表示：AND 逗号表示：OR` ! 表示：NOT 换行表示：AND 每个条件项的名字用 &amp;ldquo;字母+数字&amp;rdquo; 表示。主要支持以下几种条件：
操作系统，例如：windows、linux 等，对应 runtime.GOOS 的值。 计算机架构，例如：amd64、386，对应 runtime.GOARCH 的值。 编译器，例如：gccgo、gc，是否开启 CGO,cgo。 Go 版本，例如：go1.19、go1.20 等。 自定义的标签，例如：编译时通过指定 -tags 传入的值。 //go:build ignore，编译时自动忽略该文件 go:build 之后必须有空行，否则会被编译器当做普通注释。
//go:build linux,386 darwin,!cgo package testpkg 运算表达式为：(linux &amp;amp;&amp;amp; 386) || (darwin &amp;amp;&amp;amp; !cgo)。
自定义 tag 只需要在 go build 指令后用 -tags 指定编译条件即可
go build -tags mytag1 mytag2 对于 -tags，多个标签既可以用逗号分隔，也可以用空格分隔，但它们都表示&amp;quot;与&amp;quot;的关系。早期 go 版本用空格分隔，后来改成了用逗号分隔，但空格依然可以识别。</description></item><item><title>互斥锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</guid><description>互斥锁 # Go 的标准库 sync 提供了两种锁类型：sync.Mutex 和 sync.RWMutex，前者是互斥锁（排他锁），后者是读写锁。
互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。
Go 定义的锁接口只有两个方法：
type Locker interface { Lock() // 请求锁 Unlock() // 释放锁 } 使用 # import &amp;#34;sync&amp;#34; var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() defer mu.Unlock() balance = balance + amount } func Balance() int { mu.Lock() defer mu.Unlock() b := balance return b } 当已经有 goroutine 调用 Lock 方法获得了这个锁，再有 goroutine 请求这个锁就会阻塞在 Lock 方法的调用上， 直到持有这个锁的 goroutine 调用 UnLock 释放这个锁。</description></item><item><title>基础数据类型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</guid><description>数值类型 # 整型 # uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数 # float32 和 float64 的算术规范由 IEEE-754 浮点数国际标准定义。</description></item><item><title>项目规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/01_specs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/01_specs/</guid><description>项目规范 # 对于多人协作的项目，每个人的开发习惯都不相同，没有统一的规范，会造成很多问题。比如：代码风格不统一，目录结构杂乱无章，API 定义不统一（URL 和错误码）。
一个好的规范可以提高软件质量，提高开发效率，降低维护成本。
选择开源协议 # 开源项目需要选择一个开源协议，如果不准备开源，就用不到开源协议。
开源许可证，大概有几十种，可分为两大类：
宽松式（permissive）许可证：最基本的类型，对用户几乎没有限制，用户可以修改代码后闭源。例如 MIT，Apache 2.0 等。 Copyleft 许可证：比宽松式许可证的限制要多，修改源码后不可以闭源。例如 GPL，Mozilla（MPL）等。 如何选择自己项目的开源许可证，可以根据下面的图示：
图片来自于阮一峰的网络日志
文档规范 # README # README.md 是开发者了解一个项目时阅读的第一个文档，会放在项目的根目录下。主要是用来介绍项目的功能、安装、部署和使用。
# 项目名称 &amp;lt;!-- 项目描述、Logo 和 Badges --&amp;gt; ## Overview &amp;lt;!-- 描述项目的核心功能 --&amp;gt; ## Getting started ### Installation &amp;lt;!-- 如何安装 --&amp;gt; ### Usage &amp;lt;!-- 用法 --&amp;gt; ## Contributing &amp;lt;!-- 如何提交代码 --&amp;gt; ## License &amp;lt;!-- 开源许可证 --&amp;gt; 也可以使用 readme.so，这是一个快速生成 README 文档的在线工具。
项目文档 # 项目文档一般会放在 /docs 目录下。项目文档一般有两类：</description></item><item><title>Go 数据竞争检测器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</guid><description>Go 数据竞争检测器 # 数据竞争是并发系统中最常见，同时也最难处理的 Bug 类型之一。数据竞争会在两个 goroutine 并发访问同一个变量，且至少有一个访问为写入时产生。
下面是一个会导致程序崩溃的例子：
package main import &amp;#34;fmt&amp;#34; func main() { c := make(chan bool) m := make(map[string]string) go func() { m[&amp;#34;1&amp;#34;] = &amp;#34;a&amp;#34; // 第一个冲突的访问 c &amp;lt;- true }() m[&amp;#34;2&amp;#34;] = &amp;#34;b&amp;#34; // 第二个冲突的访问 &amp;lt;-c for k, v := range m { fmt.Println(k, v) } } 运行 go run -race ./main.go 程序会马上崩溃：
================== WARNING: DATA RACE Write at 0x00c00010a090 by goroutine 7: runtime.mapassign_faststr() /usr/local/go/src/runtime/map_faststr.</description></item><item><title>数组</title><link>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</guid><description> 数组 # 数组是一个由固定长度，相同类型的元素组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，并且可以利用索引快速访问数组中的元素。
初始化 # arr1 := [3]int{1, 2, 3} arr2 := [...]int{1, 2, 3} // `...` 省略号，表示数组的长度是根据初始化值的个数来计算 数组的长度在编译阶段确定，初始化之后大小就无法改变。
数组是否应该在堆栈中初始化在编译期就确定了。
根据数组大小：
当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上。 当元素数量大于 4 个时，会将数组中的元素放置到静态区，并在运行时取出。</description></item><item><title>读写锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</guid><description>读写锁 # 读写互斥锁 sync.RWMutex 是细粒度的互斥锁，一般来说有几种情况：
读锁之间不互斥 写锁之间是互斥的 写锁与读锁是互斥的 sync.RWMutex 类型中的 Lock 方法和 Unlock 方法用于对写锁进行锁定和解锁，RLock 方法和 RUnlock 方法则分别用于对读锁进行锁定和解锁。
原理 # type RWMutex struct { w Mutex // 复用互斥锁提供的能力，解决多个 writer 的竞争 writerSem uint32 // writer 的信号量 readerSem uint32 // reader 的信号量 readerCount atomic.Int32 // 正在执行的 reader 的数量 readerWait atomic.Int32 // 当写操作被阻塞时需要等待 read 完成的 reader 的数量 } const rwmutexMaxReaders = 1 &amp;lt;&amp;lt; 30 rwmutexMaxReaders：定义了最大的 reader 数量。
RLock 和 RUnlock # 移除了 race 等无关紧要的代码：</description></item><item><title>项目的目录结构</title><link>https://shipengqi.github.io/golang-learn/docs/project/02_structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/02_structure/</guid><description>项目的目录结构 # 一个好的目录结构设计应该是易维护、易扩展的。至少要满足以下几个要求：
命名清晰：目录命名要清晰、简洁，能清晰地表达出该目录实现的功能，并且目录名最好用单数。单数足以说明这个目录的功能，避免单复混用。 功能明确：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有很高的辨识度。当需要新增一个功能时，能够非常清楚地知道把这个功能放在哪个目录下。 全面性：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等。 可预测性：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。 可扩展性：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能。 根据项目的功能，目录结构可以分为两种：
平铺式目录结构 结构化目录结构 平铺式目录结构 # 当一个项目是一个工具库时，适合使用平铺式目录结构。项目的代码都存放在项目的根目录下，可以减少项目引用路径的长度。例如 github.com/golang/glog：
$ ls glog/ glog_file.go glog_flags.go glog.go glog_test.go go.mod go.sum LICENSE README 结构化目录结构 # 当一个项目是一个应用时，适合使用结构化目录结构。目前 Go 社区比较推荐的结构化目录结构是 project-layout。
下面是一套结合 project-layout 总结出的目录结构：
├── api # 存放不同类型的 API 定义文件 │ └── swagger # Swagger API 文档 ├── cmd # cmd 下可以包含多个组件目录，组件目录下存放各个组件的 main 包 │ └── apiserver │ └── apiserver.go ├── chart # helm chart 文件 ├── conf # 项目部署的配置文件 ├── docs # 项目文档 │ ├── dev │ │ ├── en-US │ │ └── zh-CN │ ├── guide │ │ ├── en-US │ │ └── zh-CN │ └── README.</description></item><item><title>WaitGroup</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</guid><description>WaitGroup # sync.WaitGroup 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。
使用 # 并发发送 HTTP 请求的示例：
requests := []*Request{...} wg := &amp;amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r) }(request) } wg.Wait() WaitGroup 提供了三个方法：
Add：用来设置 WaitGroup 的计数值。 Done：用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。 Wait：调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。 不要把 Add 和 Wait 方法的调用放在不同的 goroutine 中执行，以免 Add 还未执行，Wait 已经退出：
var wg sync.WaitGroup go func(){ wg.</description></item><item><title>代码规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/03_code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/03_code/</guid><description>代码规范 # 好的代码规范非常重要，可以提高代码的可读性，减少 bug，提高开发效率。
Go 官方提供的代码规范：
Go Code Review Comments Effective Go Uber 开源的 Go 编码规范：
Uber Go Guide Go 也提供了一些代码检查工具，例如 golint，goimports，go vet 等，但是这些工具检查的不够全面。
golangci-lint 是一个更加强大的静态代码检查工具。
golangci-lint # golangci-lint 的运行速度非常快，因为它可以并行的运行 linters，并且重用 Go 的构建缓存，缓存分析结果。
golangci-lint 集成了大量的 linters，不需要额外安装，可以直接使用。
安装 # $ go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.55.2 # 验证是否安装成功 $ golangci-lint version 更多安装方式。
使用 # run 命令执行代码检查：
$ golangci-lint run linters 命令打印出 golangci-lint 所支持的 linters：
$ golangci-lint linters 配置 # golangci-lint 有两种配置方式：命令行选项和配置文件。
golangci-lint 会在当前工作目录下的以下路径中查找配置文件：</description></item><item><title>切片</title><link>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</guid><description>切片 # 切片 (slice) 在使用上和数组差不多，区别是切片是可变长的，定义的时候不需要指定 size。
切片可以看做是对数组的一层简单的封装，切片的底层数据结构中，包含了一个数组。
切片的结构体：
// src/reflect/value.go type SliceHeader struct { Data uintptr // 指向底层数组 Len int // 当前切片长度 Cap int // 当前切片容量 } 注意 Cap 也是底层数组的长度。Data 是一块连续的内存，可以存储切片 Cap 大小的所有元素。
如图，虽然 slice 的 Len 是 5，但是底层数组的长度是 10，也就是 Cap。
初始化 # 初始化切片有三种方式：
使用 make // len 是切片的初始长度 // capacity 为可选参数, 指定容量 s := make([]int, len, capacity) 使用字面量 arr :=[]int{1,2,3} 使用下标截取数组或者切片的一部分，这里可以传入三个参数 [low:high:max]，max - low 是新的切片的容量 cap。 numbers := []int{0,1,2,3,4,5,6,7,8} s := numbers[1:4] // [1 2 3] s := numbers[4:] // [4 5 6 7 8] s := numbers[:3]) // [0 1 2] 《Go 学习笔记》 第四版 中的示例：</description></item><item><title>Commit 规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/04_commitizen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/04_commitizen/</guid><description>Commit 规范 # 多人协作开发一个项目时，每个开发的 Commit Message 五花八门，时间久了，提交的历史变得很难看，而且有的 Commit Message 可能过于简单，可读性较差。
一个好的 Commit 规范可以使 Commit Message 的可读性更好，并且可以实现自动化。
一个好的 Commit Message 应该满足以下要求：
清晰地描述 commit 的变更内容。 可以基于这些 Commit Message 进行过滤查找，比如只查找某个版本新增的功能：git log --oneline --grep &amp;quot;^feat|^fix&amp;quot;。 可以基于规范化的 Commit Message 生成 Change Log。 可以依据某些类型的 Commit Message 触发构建或者发布流程，比如当类型为 feat、fix 时触发 CI 流程。 确定语义化版本的版本号。比如 fix 类型可以映射为 PATCH 版本，feat 类型可以映射为 MINOR 版本。带有 BREAKING CHANGE 的 commit，可以映射为 MAJOR 版本。 目前，开源社区有多种 Commit 规范，例如 jQuery、Angular 等。Angular 规范是使用最广泛的，格式清晰易读。
Angular 规范 # Angular 规范中，Commit Message 包含三个部分：Header、Body 和 Footer。格式如下：</description></item><item><title>哈希表</title><link>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</guid><description>哈希表 # map 是一个无序的 key/value 对的集合，同一个 key 只会出现一次。
哈希表的设计原理 # 哈希表其实是数组的扩展。哈希表是利用数组可以根据下标随机访问（时间复杂度是 O(1)）这一特性来实现快速查找的。
哈希函数 # 哈希表是通过哈希函数将 key 转化为数组的下标，然后将数据存储在数组下标对应的位置。查询时，也是同样的使用哈希函数计算出数组下标，从下标对应的位置取出数据。
哈希函数的基本要求：
哈希函数计算出来的值是一个非负整数。 如果 key1 == key2 那么 hash(key1) == hash(key2) 如果 key1 != key2 那么 hash(key1) != hash(key2) 第三点，想要实现一个不同的 key 对应的哈希值绝对不一样的哈希函数，几乎是不可能的，也就说无法避免哈希冲突。
常用的处理哈希冲突的方法有两种：开放寻址法和链表法。
开放寻址法 # 开放寻址法核心思想是，如果出现了哈希冲突，就重新探测一个空闲位置，将其插入。
上图蓝色表示已经插入的元素，key9 哈希后得到的数组下标为 6，但是已经有数据了，产生了冲突。那么就按顺序向后查找直到找到一个空闲的位置，如果到数组的尾部都没有找到空闲的位置，就从头开始继续找。 上图最终找到位置 1 并插入元素。
查找的逻辑和插入类似，从哈希函数计算出来的下标位置开始查找，比较数组中下标位置的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。直到找到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。
可以看出当数组中空闲位置不多的时候，哈希冲突的概率就会大大提高。装载因子（load factor）就是用来表示空位的多少。
装载因子=已插入的元素个数/哈希表的长度 装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。
链表法 # 链表法是最常见的哈希冲突的解决办法。在哈希表中，每个桶（bucket）会对应一条链表，所有哈希值相同的元素都放到相同桶对应的链表中。
插入时，哈希函数计算后得出存放在几号桶，然后遍历桶中的链表了：
找到键相同的键值对，则更新键对应的值； 没有找到键相同的键值对，则在链表的末尾追加新的键值对 链表法实现的哈希表的装载因子：
装载因子=已插入的元素个数/桶数量 Go map 原理 # 表示 map 的结构体是 hmap：</description></item><item><title>条件变量</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</guid><description>条件变量 # Go 标准库提供了条件变量 sync.Cond 它可以让一组的 goroutine 都在满足特定条件时被唤醒。
sync.Cond 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 for {} 进行忙碌等待相比，sync.Cond 能够让出处理器的使用权，提高 CPU 的利用率。
sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么？
互斥锁 sync.Mutex 通常用来保护临界区和共享资源，条件变量 sync.Cond 用来协调想要访问共享资源的 goroutine。
sync.Cond 经常用在多个 goroutine 等待，一个 goroutine 通知的场景。
比如有一个 goroutine 在异步地接收数据，剩下的多个 goroutine 必须等待这个协程接收完数据，才能读取到正确的数据。这个时候，就需要有个全局的变量来标志第一 个 goroutine 数据是否接受完毕，剩下的 goroutine，反复检查该变量的值，直到满足要求。
当然也可以创建多个 channel，每个 goroutine 阻塞在一个 channel 上，由接收数据的 goroutine 在数据接收完毕后，逐个通知。但是这种方式更复杂一点。
使用 # NewCond 用来创建 sync.Cond 实例，sync.Cond 暴露了几个方法：
Broadcast 用来唤醒所有等待条件变量的 goroutine，无需锁保护。 Signal 唤醒一个 goroutine。 Wait 调用 Wait 会自动释放锁，并挂起调用者所在的 goroutine，也就是当前 goroutine 会阻塞在 Wait 方法调用的地方。如果其他 goroutine 调用了 Signal 或 Broadcast 唤醒 了该 goroutine，那么 Wait 方法在结束阻塞时，会重新加锁，并且继续执行 Wait 后面的代码。 var status int64 func main() { c := sync.</description></item><item><title>Go 性能优化</title><link>https://shipengqi.github.io/golang-learn/docs/practice/05_performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/05_performance/</guid><description>Go 性能优化 # JSON 优化 # Go 的标准库 encoding/json 是通过反射来实现的。性能相对有些慢。 可以使用第三方库来替代标准库：
json-iterator/go，完全兼容标准库，性能有很大提升。 go-json，完全兼容标准库，性能强于 json-iterator/go。 sonic，字节开发的的 JSON 序列化/反序列化库，速度快，但是对硬件有一些要求。 实际开发中可以根据编译标签来选择 JSON 库，参考 component-base/json。
使用空结构体 # 在 Go 中空结构体 struct{} 不占据内存空间：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { fmt.Println(unsafe.Sizeof(struct{}{})) // 0 } 空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用，可以节省资源。
集合 Set # 要实现一个 Set，通常会使用 map 来实现，比如 map[string]bool。 但是对于集合来说， 只需要 map 的键，而不需要值。将值设置为 bool 类型，就会多占据 1 个字节。这个时候就可以使用空结构体 map[string]struct{}。
channel 通知 # 有时候使用 channel 不需要发送任何的数据，只用来通知 goroutine 执行任务，或结束等。这个时候就可以使用空结构体。
内存对齐 # 为什么需要内存对齐？ # CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如：</description></item><item><title>Once</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</guid><description>Once # Go 标准库中 sync.Once 可以保证 Go 程序运行期间的某段代码只会执行一次。常常用于单例对象的初始化场景。
使用 # sync.Once 只有一个对外唯一暴露的方法 Do，可以多次调用，但是只第一次调用时会执行一次。
func main() { o := &amp;amp;sync.Once{} for i := 0; i &amp;lt; 10; i++ { o.Do(func() { fmt.Println(&amp;#34;only once&amp;#34;) }) } } 运行：
$ go run main.go only once 利用 channel 实现 Once # 下面的代码也可以达到执行一次的效果，不过重复执行会导致 panic：
var setonce chan struct{} func initialize() { // channel 不可以重复关闭，否则会 panic close(a.setonce) // 初始化 // ... } 原理 # sync.Once 的实现：</description></item><item><title>函数</title><link>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</guid><description>函数 # 参数传递 # 函数的参数传递有两种方式：
值传递：当传一个参数值到被调用的函数里面时，实际上是传了这个值的副本，被调用方和调用方两者持有不相关的两份数据。 引用传递：当传一个参数值到被调用的函数里面时，实际是传了参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。 Go 使用的是值传递，不管参数是基本类型，结构体还是指针，都会对传递的参数进行拷贝，区别无非是拷贝的目标对象还是拷贝指针。拷贝指针，也就是会同时出现两个指针指向原有的内存空间。
package main import &amp;#34;fmt&amp;#34; type foo struct { i int } func printFunc(a foo, b, c *foo) { a.i = 31 b.i = 41 c = &amp;amp;foo{i: 60} fmt.Printf(&amp;#34;print function - a=(%d, %p) b=(%v, %p) c=(%v, %p)\n&amp;#34;, a, &amp;amp;a, b, &amp;amp;b, c, &amp;amp;c) } func main() { a := foo{i: 30} b := &amp;amp;foo{i: 40} c := &amp;amp;foo{i: 50} fmt.Printf(&amp;#34;before calling - a=(%d, %p) b=(%v, %p) c=(%v, %p)\n&amp;#34;, a, &amp;amp;a, b, &amp;amp;b, c, &amp;amp;c) printFunc(a, b, c) fmt.</description></item><item><title>版本规范</title><link>https://shipengqi.github.io/golang-learn/docs/project/05_version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/05_version/</guid><description>版本规范 # Go 官方推荐的版本规范是 semver（Semantic Versioning），也就是语义化版本。这个规范是 GitHub 起草的一个具有指导意义的、统一的版本号表示规范。
semver 是一种清晰可读的，明确反应版本信息的版本格式：
主版本号.次版本号.修订号 主版本号：做了不兼容的 API 修改。 次版本号：向下兼容的新增功能以及修改。 修订号： 向下兼容的问题修复。 例如 v1.2.3。
semver 还有先行版本号和编译版本号，格式为 X.Y.Z[-先行版本号][+编译版本号]。
例如 v1.2.3-alpha.1+001，alpha.1 就是先行版本号，001 是编译版本号。
先行版本号，意味着该版本不稳定，可能存在兼容性问题，可以用 . 作为分隔符。 编译版本号，一般是编译器在编译过程中自动生成的。 先行版本号和编译版本号只能是字母、数字，并且不可以有空格。
如何确定版本号？ # 在实际开发的时候，可以使用 0.1.0 作为第一个开发版本号，并在后续的每次发行时递增次版本号。 当软件是一个稳定的版本，并且第一次对外发布时，版本号应该是 1.0.0。 严格按照 Angular 规范提交代码，版本号可以按照下面的规则来确定： fix 类型的 commit 可以将修订号 +1。 feat 类型的 commit 可以将次版本号 +1。 带有 BREAKING CHANGE 的 commit 可以将主版本号 +1。 如何处理将要弃用的功能? # 弃用已存在的功能，在软件开发中是常规操作，如果要弃用某个功能，要做到两点：
更新用户文档，通知用户。 发布新的次版本，要包含舍弃的功能，直到发布新的主版本，目的是让用户能够平滑的迁移到新的 API。 自动生成语义化版本 # gsemver 是一个用 Go 实现的命令行工具，它使用 git commit 来自动生成符合 semver 2.</description></item><item><title>API 文档</title><link>https://shipengqi.github.io/golang-learn/docs/project/06_api_doc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/06_api_doc/</guid><description>API 文档 # 使用 Swagger 生成 API 文档 # Swagger 是基于 OpenAPI 规范的 API 文档工具。
OpenAPI 是一个 API 规范，它的前身就是 Swagger 规范，目前最新的 OpenAPI 规范是 OpenAPI 3.0（也就是 Swagger 2.0 规范）。
Swagger 编辑器 # Swagger 编辑是一个在线的 API 文档编辑器，可以在其中编写 OpenAPI 规范，并实时预览 API 文档。
基于代码自动生成 Swagger 文档 # Go 生成 Swagger 文档常用的工具有两个，分别是 swag 和 go-swagger。
推荐使用 go-swagger：
go-swagger 提供了更灵活、更多的功能来描述 API，可以生成客户端和服务器端代码。 使用 swag 的话，每一个 API 都需要有一个冗长的注释，有时候代码注释比代码还要长，但是通过 go-swagger 可以将代码和注释分开编写，可以使代码保持简洁，清晰易读，而且可以把 API 定义放在一个目录中，方便管理。 安装 go-swagger # $ go get -u github.</description></item><item><title>Pool</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</guid><description>Pool # Go 从 1.3 版本开始提供了对象重用的机制，即 sync.Pool。sync.Pool 用来保存可以被重复使用的临时对象，避免了重复创建和销毁临时对象带来的消耗，降低 GC 压力，提高性能。
sync.Pool 是可伸缩的，也是并发安全的。可以在多个 goroutine 中并发调用 sync.Pool 存取对象。
使用 # var buffers = sync.Pool{ New: func() interface{} { return new(bytes.Buffer) }, } func GetBuffer() *bytes.Buffer { return buffers.Get().(*bytes.Buffer) } func PutBuffer(buf *bytes.Buffer) { buf.Reset() buffers.Put(buf) } New：类型是 func() interface{}，用来创建新的元素。 Get：从 Pool 中取出一个元素，如果没有更多的空闲元素，就调用 New 创建新的元素。如果没有设置 New 那么可能返回 nil。 Put：将一个元素放回 Pool 中，使该元素可以重复使用，如果 Put 的值是 nil，会被忽略。
可以先 Put，再 Get 么？ # 不可以。
type item struct { value int } func main() { pool := sync.</description></item><item><title>Context</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</guid><description>Context # Go 1.7 版本中正式引入新标准库 context。主要的作用是在在一组 goroutine 之间传递共享的值、取消信号、deadline 等。
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline — 返回当前 context 的截止时间。 Done — 返回一个只读的 channel，可用于识别当前 channel 是否已经被关闭，其原因可能是到期，也可能是被取消了。多次调用 Done 方法会返回同一个 channel。 Err — 返回当前 context 被关闭的原因。 如果 context 被取消，会返回 Canceled 错误。 如果 context 超时，会返回 DeadlineExceeded 错误。 Value — 返回当前 context 对应所存储的 context信息，可以用来传递请求特定的数据。 创建 context：
Background：创建一个空的 context，一般用在主函数、初始化、测试以及创建 root context 的时候。 TODO：创建一个空的 context，不知道要传递一些什么上下文信息的时候，就用这个。 WithCancel：基于 parent context 创建一个可以取消的新 context。 WithTimeout：基于 parent context 创建一个具有超时时间的新 context。 WithDeadline：和 WithTimeout 一样，只不过参数是截止时间（超时时间加上当前时间）。 WithValue：基于某个 context 创建并存储对应的上下文信息。 最常用的场景，使用 context 来取消一个 goroutine 的运行：</description></item><item><title>Git 工作流程</title><link>https://shipengqi.github.io/golang-learn/docs/project/07_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/07_flow/</guid><description>Git 工作流程 # 涉及到多人协作的项目，多个开发者向同一个仓库提交代码，如果处理不好会出现代码丢失，冲突等问题。所以一个规范的工作流程，可以让开发者更有效地合作，使项目更好地发展下去。
最常用的工作流程有三种：
Git Flow GitHub Flow Forking Flow Git Flow # Git Flow 是最早出现的一种工作流程。
Git Flow 存在两种长期分支：
master：这个分支永远是稳定的发布版本，不能直接在该分支上开发。每次合并一个 hotfix/release 分支，都在 master 上打一个版本标签。 develop：日常开发的分支，存放最新的开发版。同样不能在这个分支上直接开发，这个分支只做合并操作。 三种短期分支：
feature branch：用于功能开发，基于 develop 创建新的 feature 分支，可以命名为 feat/xxx-xx。开发完成之后，合并到 develop 并删除。 hotfix branch：补丁分支，在维护阶段用于紧急的 bug 修复。基于 master 创建，可以命名为 hotfix/xxx-xx。完成后合并到 master 分支并，然后在 master 打上标签删除并删除 hotfix 分支。一般 develop 也需要合并 hotfix 分支。 release branch：预发布分支，在发布阶段，基于 develop 创建，可以命名为 release/xxx-xx。 例如 v1.0.0 版本开发完成后，代码已经全部合并到 develop 分支。发布之前，基于 develop 创建release/1.0.0 分支，基于 release/1.0.0 进行测试，如果发现 bug，就在 release/1.</description></item><item><title>Go Core Dump 调试</title><link>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</guid><description>Go Core Dump 调试 # Go 也可以开启类似 C++ Core Dump 功能，Core Dump 是程序崩溃时的内存快照。程序崩溃时，可以帮助定位 crash 发生的原因。
开启 Core Dump 功能 # 在 Linux 中，可以通过 ulimit -c 查看 Core Dump 功能是否开启：
$ ulimit -c 0 输出为 0，表示未开启。
使用 ulimit -c [size] 来指定 core dump 文件的大小，也就是开启 Core Dump。ulimit -c unlimited 表示不限制 core dump 文件的大小。
例如，下面的命令是将 core dump 文件大小设置为 1MB：
$ ulimit -c 1048576 如何生成 Core Dump 文件 # Go 提供的环境变量 GOTRACEBACK 可以用来控制程序崩溃时输出的详细程度。可选值有：</description></item><item><title>Go Modules</title><link>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</guid><description>Go Modules # Go 在 1.11 推出了 Go Modules，这是一个新的包管理器，解决了 GOPATH 存在的问题。并且 Go 1.13 起不再推荐使用 GOPATH。
Go Modules 机制 # Go Modules 将依赖缓存放在 $GOPATH/pkg/mod 目录，并且同一个依赖的版本，只会缓存一份，供所有项目使用。
启用 Go Modules # Go 1.11 引入了环境变量 GO111MODULE 来控制是否启用 Go Modules，GO111MODULE 有三个值可选：
on 启用 Go Modules off 禁用 Go Modules auto，在 GOPATH 下的项目，使用 GOPATH，否则启用 Go Modules。 Go 1.16 之前 GO111MODULE 的默认值是 auto，Go 1.16 起 GO111MODULE 的默认值为 on。
初始化 # 初始化 Go Modules 项目，首先要开启 Go Modules，然后在项目目录下运行：</description></item><item><title>原子操作</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</guid><description>原子操作 # 原子操作就是执行过程中不能被中断的操作。
Go 的标准库 sync/atomic 提供了一些实现原子操作的方法：
Add CompareAndSwap（简称 CAS） Load Swap Store 这些函数针对的数据类型有：
int32 int64 uint32 uint64 uintptr unsafe 包中的 Pointer 以 Add 为例，上面类型对应的原子操作函数为：
func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) unsafe.Pointer 类型，并未提供进行原子加法操作的函数。
sync/atomic 包还提供了一个名为 Value 的类型，它可以被用来存储（Store）和加载（Load）任意类型的值。
它只有两个指针方法：
Store Load。 尽量不要向原子值中存储引用类型的值。</description></item><item><title>项目管理</title><link>https://shipengqi.github.io/golang-learn/docs/project/08_make/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/08_make/</guid><description>项目管理 # Go 项目通常使用 Makefile 作为项目管理工具。
通常 Go 项目的 Makefile 应该包括：格式化代码、静态代码检查、单元测试、代码构建、文件清理、帮助等功能。
学习 Makefile 的语法，推荐学习《跟我一起写 Makefile》 (PDF 重制版)。
Makefile 结构 # 随着项目越来越大，需要管理的功能就会越来越多，如果全部放在一个 Makefile 中，会导致 Makefile 过大，难以维护，可读性差。所以设计 Makefile 结构时，最好采用分层的设计。
项目根目录下的 Makefile 来聚合子目录下的 Makefile 命令。将复杂的 shell 命令封装在 shell 脚本中，供 Makefile 直接调用，而一些简单的命令则可以直接集成在 Makefile 中。
示例；
.PHONY: all all: modules lint test build # ============================================================================== # Includes include hack/include/common.mk # make sure include common.mk at the first include line include hack/include/go.mk include hack/include/release.mk # ============================================================================== # Targets ## build: build binary file.</description></item><item><title>Channel</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</guid><description>Channel # Don’t communicate by sharing memory; share memory by communicating. 不要通过共享内存来通信，通过通信来共享内存。 这是 Go 语言最重要的编程理念。goroutine 通过 channel 向另一个 goroutine 发送消息，channel 和 goroutine 结合，可以实现用通信代替共享内存的 CSP （Communicating Sequential Process）模型。
使用 # 创建 channel：
// 无缓冲 channel ch := make(chan int) // 带缓冲 channel，缓冲区为 3 ch = make(chan int, 3) channel 的零值是 nil。
无缓冲 channel # 无缓冲 channel 也叫做同步 channel：
一个 goroutine 基于一个无缓冲 channel 发送数据，那么就会阻塞，直到另一个 goroutine 在相同的 channel 上执行接收操作。 一个 goroutine 基于一个无缓冲 channel 先执行了接收操作，也会阻塞，直到另一个 goroutine 在相同的 channel 上执行发送操作 带缓冲 channel # 带缓冲的 channel 有一个缓冲区：</description></item><item><title>Gin 静态服务器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</guid><description>Gin 如何实现前端网页的静态服务器 # Gin 作为 Web 框架提供 API 非常方便，但是在同一个项目中，既提供 API，又要作为前端网页的静态服务器，就比较麻烦。通常 Angular (React/Vue) 项目需要在 Nginx 或者 Tomcat 转发才可以。有些小项目并不需要前后端分离，如何解决？
利用 embed 标签 # Go 1.16 增加了 embed 的标签，可以利用这个标签将静态资源打包到二进制文件中。
. ├── config ├── controller ├── model ├── options ├── pkg │ └── response │ └── response.go ├── resources │ ├── dist │ └── html.go ├── html.go ├── resource.go ├── router.go ├── server.go └── store ├── audited.go ├── groups.go ├── mysql.go ├── settings.go ├── store.</description></item><item><title>GitHub Actions</title><link>https://shipengqi.github.io/golang-learn/docs/project/09_actions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/09_actions/</guid><description>基于 GitHub Actions 的 CI/CD # GitHub Actions 是 GitHub 为托管在 github.com 站点的项目提供的持续集成服务。
在构建持续集成任务时，需要完成很多操作，比如克隆代码、编译代码、运行单元测试、构建和发布镜像等。GitHub 把这些操作称为 Actions。
Actions 是可以共享的，开发者可以将 Actions 上传到 GitHub 的 Actions 市场。如果需要某个 Action，直接引用即可。 整个持续集成过程，就变成了一个 Actions 的组合。
Action 其实是一个独立的脚本，可以将 Action 存放在 GitHub 代码仓库中，通过 &amp;lt;userName&amp;gt;/&amp;lt;repoName&amp;gt; 的语法引用 Action。例如，actions/checkout@v2 表示 https://github.com/actions/checkout 这个仓库，tag 是 v2。
GitHub Actions 术语 # workflow：一个 .yml 文件对应一个 workflow，也就是一次持续集成。一个 GitHub 仓库可以包含多个 workflow，只要是在 .github/workflow 目录下的 .yml 文件都会被 GitHub 执行。 job：一个 workflow 由一个或多个 job 构成，每个 job 代表一个持续集成任务。 step：每个 job 由多个 step 构成，一步步完成。 action：每个 step 可以依次执行一个或多个命令（action）。 on：一个 workflow 的触发条件，决定了当前的 workflow 在什么时候被执行。 workflow # GitHub Actions 配置文件存放在代码仓库的 .</description></item><item><title>指针</title><link>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</guid><description>指针 # 指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个保存内存地址的整形变量。
指针的限制 # 指针不能参与运算 # package main import &amp;#34;fmt&amp;#34; func main() { a := 1 b := a fmt.Println(b) b = &amp;amp;a + 1 } 上面的代码编译时会报错：Invalid operation: &amp;amp;a + 1 (mismatched types *int and untyped int)。
说明 Go 是不允许对指针进行运算的。
不同类型的指针不允许相互转换 # package main func main() { var a int = 100 var f *float64 f = &amp;amp;a } 上面的代码编译时会报错：Cannot use '&amp;amp;a' (type *int) as the type *float64。</description></item><item><title>GitHub Dependabot</title><link>https://shipengqi.github.io/golang-learn/docs/project/10_dependabot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/10_dependabot/</guid><description>GitHub Dependabot # GitHub Dependabot 是 GitHub 提供的一个工具，它可以帮助检测项目所使用的 dependency 中是否有可以更新的版本，如果有，它可以自动创建 PR 实现自动更新。
GitHub Dependabot 的配置文件 dependabot.yml 必须存放在代码仓库的 .github 目录下。在添加或更新 dependabot.yml 文件时，会立即触发版本更新检查。
version: 2 updates: - package-ecosystem: &amp;#34;gomod&amp;#34; directory: &amp;#34;/&amp;#34; schedule: interval: &amp;#34;daily&amp;#34; time: &amp;#34;08:00&amp;#34; labels: - &amp;#34;dependencies&amp;#34; commit-message: prefix: &amp;#34;feat&amp;#34; include: &amp;#34;scope&amp;#34; 上面的示例，interval: &amp;quot;daily&amp;quot; time: &amp;quot;08:00&amp;quot; 表示每天八点会触发版本更新检查。
dependabot.yml 文件中两个必须的字段：version 和 updates。该文件必须以 version: 2 开头。
updates # updates 用来配置 Dependabot 如何更新版本或项目的依赖项，常用的选项：
选项 required 安全更新 版本更新 说明 package-ecosystem yes no yes 要使用的包管理器 directory yes yes yes package manifests 位置 schedule.</description></item><item><title>信号量</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/10_sema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/10_sema/</guid><description>信号量 # 信号量（Semaphore）是一种用于实现多进程或多线程之间同步和互斥的机制。
信号量可以简单理解为一个整型数，包含两种操作：P（Proberen，测试）操作和 V（Verhogen，增加）操作。其中，P 操作会尝试获取一个信号量，如果信号量的值大于 0，则将信号量的值减 1 并 继续执行。否则，当前进程或线程就会被阻塞，直到有其他进程或线程释放这个信号量为止。V 操作则是释放一个信号量，将信号量的值加 1。
P 操作和 V 操作可以看做是对资源的获取和释放。
Go 的 WaitGroup 和 Metux 都是通过信号量来控制 goroutine 的阻塞和唤醒，例如 Mutex 结构体中的 sema：
type Mutex struct { state int32 sema uint32 } Metux 本质上就是基于信号量（sema）+ 原子操作来实现并发控制的。
Go 操作信号量的方法：
// src/sync/runtime.go // 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1 func runtime_Semacquire(s *uint32) // 类似于 runtime_Semacquire // 如果 lifo 为 true，waiter 将会被插入到队列的头部，否则插入到队列尾部 // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int) // 将 s 增加 1，然后通知阻塞在 runtime_Semacquire 的 goroutine // 如果 handoff 为 true，传递信号到队列头部的 waiter // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_Semrelease(s *uint32, handoff bool, skipframes int) Acquire 和 Release 分别对应了 P 操作和 V 操作。</description></item><item><title>GitHub 模板</title><link>https://shipengqi.github.io/golang-learn/docs/project/11_templates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/11_templates/</guid><description>GitHub 模板 # 使用 Issue 和 PR 模板可以让贡献者有针对性的提供某类问题的准确信息。
PR Template # PR 模板可以在任意的目录下，如果有多个 PR 模板，需要创建一个 PULL_REQUEST_TEMPLATE 目录。
例如，可以在 repo 的根目录下创建 pull_request_template.md，也可以在放在 .github 目录中 .github/pull_request_template.md。
pull_request_template.md:
Thank you for contributing to crtctl! # Please add a summary of your change # Does your change fix a particular issue? Fixes #(issue) Issue Template # Issue 模板存储在 repo 的 .github/ISSUE_TEMPLATE 目录中。文件名不区分大小写，扩展名为 .md。
ISSUE_TEMPLATE/bug_report.md
--- name: Bug Report about: Tell us about a problem you are experiencing --- **What steps did you take and what happened:** [A clear and concise description of what the bug is, and what commands you ran.</description></item><item><title>SingleFlight</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/11_singleflight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/11_singleflight/</guid><description>SingleFlight # Go 的扩展库 golang.org/x/sync 提供了 singleflight 包，它的作用在处理多个 goroutine 同时调用同一个函数的时候，只让一个 goroutine 去调用这个函数，等到这个 goroutine 返回结果时，再把结 果返回给这几个 goroutine，这样可以减少并发调用的数量。
一个常见的使用场景：在使用 Redis 对数据库中的数据进行缓存，如果发生缓存击穿，大量的流量都会打到后端数据库上，导致后端服务响应延时等问题。 singleflight 可以将对同一个 key 的多个请求合并为一个，减轻后端服务的压力。
使用 # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; &amp;#34;golang.org/x/sync/singleflight&amp;#34; ) func GetValueFromRedis(key string) string { fmt.Println(&amp;#34;query ...&amp;#34;) time.Sleep(10 * time.Second) // 模拟一个比较耗时的操作 return &amp;#34;singleflight demo&amp;#34; } func main() { requestGroup := new(singleflight.Group) cachekey := &amp;#34;demokey&amp;#34; go func() { v1, _, shared := requestGroup.Do(cachekey, func() (interface{}, error) { ret := GetValueFromRedis(cachekey) return ret, nil }) fmt.</description></item><item><title>ErrGroup</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/12_errorgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/12_errorgroup/</guid><description>ErrGroup # Go 的扩展库 golang.org/x/sync 提供了 errgroup 包，它是基于 WaitGroup 实现的，功能上和 WaitGroup 类似，不过可以通过上下文取消，控制并发数量，还能返回错误。
使用 # 最简单的使用方式：
package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; &amp;#34;golang.org/x/sync/errgroup&amp;#34; ) func main() { var g errgroup.Group // g, ctx := errgroup.WithContext(context.Background()) g.Go(func() error { time.Sleep(5 * time.Second) fmt.Println(&amp;#34;exec 1&amp;#34;) return nil }) g.Go(func() error { time.Sleep(10 * time.Second) fmt.Println(&amp;#34;exec 2&amp;#34;) return errors.New(&amp;#34;failed to exec 2&amp;#34;) }) if err := g.Wait(); err == nil { fmt.Println(&amp;#34;exec done&amp;#34;) } else { fmt.</description></item><item><title>GoReleaser</title><link>https://shipengqi.github.io/golang-learn/docs/project/12_goreleaser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/project/12_goreleaser/</guid><description>GoReleaser # GoReleaser 是用 Go 编写项目的自动发布工具，支持交叉编译，并且支持发布到 Github，Gitlab 和 Gitea。
安装 # go install github.com/goreleaser/goreleaser@latest 更多安装方式。
使用 # 生成配置文件 .goreleaser.yaml，一般这个文件放在项目的根目录下：
goreleaser init 下面的命令可以发布一个 &amp;ldquo;仅限本地&amp;rdquo; 的 release，一般用来测试 release 命令是否可以正常运行。
goreleaser release --snapshot --rm-dist 修改 .goreleaser.yaml 配置后，可以用 check 命令检查配置：
goreleaser check --single-target 只为特定的 GOOS/GOARCH 构建二进制文件，这对本地开发很有用：
goreleaser build --single-target 发布一个 release # 如果要发布到 Github，需要导出一个环境变量 GITHUB_TOKEN，它应该包含一个有效的 GitHub token 与 repo 范围。它将被用来部署发布到你的 GitHub 仓库。创建一个新的 GitHub 令牌。
write:packages 权限是 GITHUB_TOKEN 需要的最小权限。
GoReleaser 会使用 repo 的最新 Git 标签。</description></item></channel></rss>