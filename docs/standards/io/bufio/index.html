<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="bufio#bufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 io.Reader 和 io.Writer 对象。
bufio包中的数据类型#bufio包中的数据类型主要有：
Reader； Scanner； Writer 和 ReadWriter。 bufio.Reader#两个用于初始化 bufio.Reader 的函数：
NewReader 函数初始化的 Reader 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 4096 个字节，即：4 KB。 NewReaderSize 函数则将缓冲区尺寸的决定权抛给了使用方。 func NewReader(rd io.Reader) *Reader func NewReaderSize(rd io.Reader, size int) *Reader // 可以配置缓冲区的大小 bufio.Reader 类型值中的缓冲区的作用#缓冲区其实就是一个数据存储中介，它介于底层读取器与读取方法及其调用方之间。所谓的底层读取器是指 io.Reader。
Reader 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂 存于缓冲区之中以备后用。
缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。
type Reader struct { buf []byte rd io.Reader r, w int err error lastByte int lastRuneSize int } bufio.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="bufio" />
<meta property="og:description" content="bufio#bufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 io.Reader 和 io.Writer 对象。
bufio包中的数据类型#bufio包中的数据类型主要有：
Reader； Scanner； Writer 和 ReadWriter。 bufio.Reader#两个用于初始化 bufio.Reader 的函数：
NewReader 函数初始化的 Reader 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 4096 个字节，即：4 KB。 NewReaderSize 函数则将缓冲区尺寸的决定权抛给了使用方。 func NewReader(rd io.Reader) *Reader func NewReaderSize(rd io.Reader, size int) *Reader // 可以配置缓冲区的大小 bufio.Reader 类型值中的缓冲区的作用#缓冲区其实就是一个数据存储中介，它介于底层读取器与读取方法及其调用方之间。所谓的底层读取器是指 io.Reader。
Reader 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂 存于缓冲区之中以备后用。
缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。
type Reader struct { buf []byte rd io.Reader r, w int err error lastByte int lastRuneSize int } bufio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/golang-learn/docs/standards/io/bufio/" /><meta property="article:section" content="docs" />

<meta property="article:modified_time" content="2023-10-07T14:03:42+08:00" />
<title>bufio | Golang Learning</title>
<link rel="manifest" href="/golang-learn/manifest.json">
<link rel="icon" href="/golang-learn/favicon.png" >
<link rel="stylesheet" href="/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/golang-learn/flexsearch.min.js"></script>
  <script defer src="/golang-learn/en.search.min.9d19f3cf24b235d59b85d5a7e5dcdc41758b1caac59546ce7f048de6fd1ce8fd.js" integrity="sha256-nRnzzySyNdWbhdWn5dzcQXWLHKrFlUbOfwSN5v0c6P0=" crossorigin="anonymous"></script>

  <script defer src="/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js" integrity="sha256-6aVVKOAw5E7L4bWo2n3Y&#43;0C9KC0C3EV06BuZmmohvIQ=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/golang-learn/"><span>Golang Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>







  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/golang-learn"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/"  target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>语言基础</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/env_config/" class="">Go 环境配置</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/build/" class="">Golang 条件编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/map/" class="">map</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/slice/" class="">slice</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/scope/" class="">作用域</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/function/" class="">函数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/package/" class="">包</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/reflect/" class="">反射</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/var/" class="">变量</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/basic_data/" class="">基础据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/constant/" class="">常量</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/json/" class="">序列化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/pointer/" class="">指针</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/interface/" class="">接口</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/flow/" class="">控制语句</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/array/" class="">数组</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/test/" class="">测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/struct/" class="">结构体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/operator/" class="">运算符</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/error/" class="">错误</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/basic/oop/" class="">面向对象</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>并发编程</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/channel/" class="">channel</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/goroutine/" class="">goroutine</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/sync_lock/" class="">同步和锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/concurrent/concurrent/" class="">并发和并行</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>常用命令</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/build/" class="">build</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/doc/" class="">doc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/env/" class="">env</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/fmt/" class="">fmt</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/get/" class="">get</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/summary/" class="">Go 命令</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/golint/" class="">golint</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/install/" class="">install</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/mod/" class="">mod</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/run/" class="">run</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/test/" class="">test</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/tool/" class="">tool</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/commands/vet/" class="">vet</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>常用标准库</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>Data</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/big/" class="">big</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/container/" class="">container</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/math/" class="">math</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/data/sort/" class="">sort</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Database</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/database/sql/" class="">sql</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Io</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/bufio/" class="active">bufio</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/fmt/" class="">fmt 包</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/io/" class="">io</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/io/ioutil/" class="">ioutil</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Net</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/net/http/" class="">http</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Os</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/os/filepath/" class="">filepath</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/os/os/" class="">os</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Text</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/text/strconv/" class="">strconv</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/text/strings/" class="">strings</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/text/unicode/" class="">unicode</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/unsafe/" class="">Unsafe</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/log/" class="">log</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/standards/time/" class="">time</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>实践</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/errors/" class="">Errors</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/gin/" class="">Gin</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/ginkgo/" class="">Ginkgo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/pprof/" class="">Go PProf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/trace/" class="">Go trace</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/go-race/" class="">Go 数据竞争检测器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/go_relative_path/" class="">Go 的相对路径</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/practice/json/" class="">Json Unmarshal</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>底层原理</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/advance/scheduler/" class="">Goroutine 调度器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/advance/mm/" class="">内存分配</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/golang-learn/docs/advance/gc/" class="">垃圾回收</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/golang-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>bufio</strong>

  <label for="toc-control">
    
    <img src="/golang-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#bufio">bufio</a>
      <ul>
        <li><a href="#bufio包中的数据类型">bufio包中的数据类型</a></li>
        <li><a href="#bufioreader">bufio.Reader</a>
          <ul>
            <li><a href="#bufioreader-类型值中的缓冲区的作用">bufio.Reader 类型值中的缓冲区的作用</a></li>
            <li><a href="#bufioreader-类型读取方法">bufio.Reader 类型读取方法</a></li>
            <li><a href="#peek-方法">Peek 方法</a></li>
            <li><a href="#其他方法">其他方法</a></li>
          </ul>
        </li>
        <li><a href="#bufiowriter">bufio.Writer</a>
          <ul>
            <li><a href="#方法">方法</a></li>
            <li><a href="#bufiowriter-类型值中缓冲的数据什么时候会被写到它的底层写入器">bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器</a></li>
          </ul>
        </li>
        <li><a href="#readwriter">ReadWriter</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="bufio">
  bufio
  <a class="anchor" href="#bufio">#</a>
</h1>
<p>bufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 <code>io.Reader</code> 和 <code>io.Writer</code> 对象。</p>
<h2 id="bufio包中的数据类型">
  bufio包中的数据类型
  <a class="anchor" href="#bufio%e5%8c%85%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p>bufio包中的数据类型主要有：</p>
<ul>
<li><code>Reader</code>；</li>
<li><code>Scanner</code>；</li>
<li><code>Writer</code> 和 <code>ReadWriter</code>。</li>
</ul>
<h2 id="bufioreader">
  bufio.Reader
  <a class="anchor" href="#bufioreader">#</a>
</h2>
<p>两个用于初始化 <code>bufio.Reader</code> 的函数：</p>
<ul>
<li><code>NewReader</code> 函数初始化的 <code>Reader</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>
<li><code>NewReaderSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">rd</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewReaderSize</span>(<span style="color:#a6e22e">rd</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span> <span style="color:#75715e">// 可以配置缓冲区的大小
</span></span></span></code></pre></div><h3 id="bufioreader-类型值中的缓冲区的作用">
  bufio.Reader 类型值中的缓冲区的作用
  <a class="anchor" href="#bufioreader-%e7%b1%bb%e5%9e%8b%e5%80%bc%e4%b8%ad%e7%9a%84%e7%bc%93%e5%86%b2%e5%8c%ba%e7%9a%84%e4%bd%9c%e7%94%a8">#</a>
</h3>
<p>缓冲区其实就是一个<strong>数据存储中介，它介于底层读取器与读取方法及其调用方之间</strong>。所谓的底层读取器是指 <code>io.Reader</code>。</p>
<p><code>Reader</code> 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂
存于缓冲区之中以备后用。</p>
<p>缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Reader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">buf</span>          []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rd</span>           <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">w</span>         <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span>          <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lastByte</span>     <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lastRuneSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>bufio.Reader</code> 字段：</p>
<ul>
<li><code>buf</code>：<code>[]byte</code> 类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。</li>
<li><code>rd</code>：<code>io.Reader</code> 类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。</li>
<li><code>r</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。</li>
<li><code>w</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为 <code>nil</code>。</li>
<li><code>lastByte</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。</li>
<li><code>lastRuneSize</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字
段只会在其所属值的 <code>ReadRune</code> 方法中才会被赋予有意义的值。在其他情况下，它都会被置为 <code>-1</code>。</li>
</ul>
<h3 id="bufioreader-类型读取方法">
  bufio.Reader 类型读取方法
  <a class="anchor" href="#bufioreader-%e7%b1%bb%e5%9e%8b%e8%af%bb%e5%8f%96%e6%96%b9%e6%b3%95">#</a>
</h3>
<h4 id="readslicereadbytesreadstring-和-readline">
  ReadSlice、ReadBytes、ReadString 和 ReadLine
  <a class="anchor" href="#readslicereadbytesreadstring-%e5%92%8c-readline">#</a>
</h4>
<p>后三个方法最终都是调用 <code>ReadSlice</code> 来实现的。所以，我们先来看看 <code>ReadSlice</code> 方法。</p>
<p><strong>ReadSlice方法</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">ReadSlice</span>(<span style="color:#a6e22e">delim</span> <span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">line</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p><code>ReadSlice</code> 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 <code>slice</code>，在下次调用读操作（<code>read</code>）时，这些字节会
无效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Hello \nworld&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">ReadSlice</span>(<span style="color:#e6db74">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;the line:%s\n&#34;</span>, <span style="color:#a6e22e">line</span>) <span style="color:#75715e">// the line:Hello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">ReadSlice</span>(<span style="color:#e6db74">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;the line:%s\n&#34;</span>, <span style="color:#a6e22e">line</span>) <span style="color:#75715e">// the line:world
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">n</span>)) <span style="color:#75715e">// world
</span></span></span></code></pre></div><p>从结果可以看出，第一次 <code>ReadSlice</code> 的结果 <strong>line</strong>，在第二次调用读操作后，内容发生了变化。也就是说，<code>ReadSlice</code> 返回的 <code>[]byte</code> 是指
向 <code>Reader</code> 中的 <code>buffer</code> ，而不是 <code>copy</code> 一份返回。正因为 <code>ReadSlice</code> 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择
使用 <code>ReadBytes</code> 或者 <code>ReadString</code> 来代替。</p>
<p>注意，这里的界定符可以是任意的字符。同时，返回的结果是包含界定符本身的。</p>
<p>如果 <code>ReadSlice</code> 在找到界定符之前遇到了 <code>error</code>，它就会返回缓存中所有的数据和错误本身（经常是 <code>io.EOF</code>）。如果在找到界定符之前缓存已经
满了，<code>ReadSlice</code> 会返回 <code>bufio.ErrBufferFull</code> 错误。当且仅当返回的结果（<code>line</code>）没有以界定符结束的时候，<code>ReadSlice</code> 返
回 <code>err != nil</code>，也就是说，如果 <code>ReadSlice</code> 返回的结果 <code>line</code> 不是以界定符 <code>delim</code> 结尾，那么返回的 <code>err</code> 也一定不等于 <code>nil</code>。</p>
<p><strong>ReadBytes 方法</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">ReadBytes</span>(<span style="color:#a6e22e">delim</span> <span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">line</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p>该方法的参数和返回值类型与 <code>ReadSlice</code> 都一样。 <code>ReadBytes</code> 从输入中读取直到遇到界定符（delim）为止，返回的 <code>slice</code> 包含了从当前到
界定符的内容 <strong>（包括界定符）</strong>。</p>
<p><code>ReadBytes</code> 源码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">ReadBytes</span>(<span style="color:#a6e22e">delim</span> <span style="color:#66d9ef">byte</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Use ReadSlice to look for array,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// accumulating full buffers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">frag</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">full</span> [][]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">e</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">frag</span>, <span style="color:#a6e22e">e</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReadSlice</span>(<span style="color:#a6e22e">delim</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// got final fragment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">ErrBufferFull</span> { <span style="color:#75715e">// unexpected error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">e</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Make a copy of the buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, len(<span style="color:#a6e22e">frag</span>)) <span style="color:#75715e">// 这里把 ReadSlice 的返回值 copy 了一份，不再是指向 Reader 中的 buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		copy(<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">frag</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">full</span> = append(<span style="color:#a6e22e">full</span>, <span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Allocate new buffer to hold the full pieces and the fragment.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">full</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> len(<span style="color:#a6e22e">full</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> len(<span style="color:#a6e22e">frag</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Copy full pieces and fragment in.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">full</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> copy(<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">n</span>:], <span style="color:#a6e22e">full</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	copy(<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">n</span>:], <span style="color:#a6e22e">frag</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>ReadString 方法</strong></p>
<p><code>ReadString</code> 源码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">ReadString</span>(<span style="color:#a6e22e">delim</span> <span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">line</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bytes</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ReadBytes</span>(<span style="color:#a6e22e">delim</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> string(<span style="color:#a6e22e">bytes</span>), <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>调用了 <code>ReadBytes</code> 方法，并将结果的 <code>[]byte</code> 转为 <code>string</code> 类型。</p>
<p><strong>ReadLine 方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">ReadLine</span>() (<span style="color:#a6e22e">line</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">isPrefix</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p><code>ReadLine</code> 是一个底层的原始行读取命令。可以使用 <code>ReadBytes('\n')</code> 或者 <code>ReadString('\n')</code> 来代替这个方法。</p>
<p><strong><code>ReadLine</code> 尝试返回单独的行，不包括行尾的换行符</strong>。如果一行大于缓存，<code>isPrefix</code> 会被设置为 <code>true</code>，同时返回该行的开始部分
（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，<code>isPrefix</code> 将会是 <code>false</code> 。
跟 <code>ReadSlice</code> 一样，<strong>返回的 <code>line</code> 是 <code>buffer</code> 的引用</strong>，在下次执行 IO 操作时，<code>line</code> 会无效。</p>
<p>建议读取一行使用下面的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">ReadBytes</span>(<span style="color:#e6db74">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">line</span> = <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">TrimRight</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34;\r\n&#34;</span>)
</span></span></code></pre></div><h3 id="peek-方法">
  Peek 方法
  <a class="anchor" href="#peek-%e6%96%b9%e6%b3%95">#</a>
</h3>
<p><code>Peek</code> 是 &ldquo;窥视&rdquo; 的意思，<code>Peek</code> 一个鲜明的特点，就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">Peek</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p><strong>返回的 <code>[]byte</code> 是 <code>buffer</code> 中的引用</strong>，该切片引用缓存中前 <code>n</code> 字节数据。</p>
<p><strong><code>Peek</code> 方法、<code>ReadSlice</code> 方法和 <code>ReadLine</code> 方法都有可能会造成内容泄露。这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片，
也因为为这个原因对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。</strong>。</p>
<p>另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 <code>err != nil</code> ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。</p>
<h3 id="其他方法">
  其他方法
  <a class="anchor" href="#%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">ReadByte</span>() (<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">ReadRune</span>() (<span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>, <span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">UnreadByte</span>() <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">UnreadRune</span>() <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">WriteTo</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><h2 id="bufiowriter">
  bufio.Writer
  <a class="anchor" href="#bufiowriter">#</a>
</h2>
<p><code>bufio.Writer</code> 结构封装了一个 <code>io.Writer</code> 对象。同时实现了 <code>io.Writer</code> 接口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>		<span style="color:#75715e">// 写过程中遇到的错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>		<span style="color:#75715e">// 缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">n</span>   <span style="color:#66d9ef">int</span>			<span style="color:#75715e">// 当前缓存中的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">wr</span>  <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>	<span style="color:#75715e">// 底层的 io.Writer 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>bufio.Writer</code> 类型的字段:</p>
<ul>
<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。</li>
<li><code>buf</code>：<code>[]byte</code> 类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。</li>
<li><code>n</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>wr</code>：<code>io.Writer</code> 类型的字段，代表底层写入器。</li>
</ul>
<p>两个用于初始化 <code>bufio.Writer</code> 的函数：</p>
<ul>
<li><code>NewWriter</code> 函数初始化的 <code>Writer</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>
<li><code>NewWriterSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewWriter</span>(<span style="color:#a6e22e">wr</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewWriterSize</span>(<span style="color:#a6e22e">wr</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>, <span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span> <span style="color:#75715e">// 可以配置缓冲区的大小
</span></span></span></code></pre></div><h3 id="方法">
  方法
  <a class="anchor" href="#%e6%96%b9%e6%b3%95">#</a>
</h3>
<ul>
<li><code>Available</code> 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）</li>
<li><code>Buffered</code> 方法获取写入当前缓存中的字节数（字段 n 的值）</li>
<li><code>Flush</code> 方法将缓存中的所有数据写入底层的 io.Writer 对象中。</li>
</ul>
<p>其他实现了 <code>io</code> 包的接口方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 实现了 io.ReaderFrom 接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 实现了 io.Writer 接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">nn</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 实现了 io.ByteWriter 接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">WriteByte</span>(<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// io 中没有该方法的接口，它用于写入单个 Unicode 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 rune 的范围调用 WriteByte 或 WriteString
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">WriteRune</span>(<span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>) (<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写入字符串，如果返回写入的字节数比 len(s) 小，返回的error会解释原因
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><h3 id="bufiowriter-类型值中缓冲的数据什么时候会被写到它的底层写入器">
  bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器
  <a class="anchor" href="#bufiowriter-%e7%b1%bb%e5%9e%8b%e5%80%bc%e4%b8%ad%e7%bc%93%e5%86%b2%e7%9a%84%e6%95%b0%e6%8d%ae%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9a%e8%a2%ab%e5%86%99%e5%88%b0%e5%ae%83%e7%9a%84%e5%ba%95%e5%b1%82%e5%86%99%e5%85%a5%e5%99%a8">#</a>
</h3>
<p><code>bufio.Writer</code> 类型有一个名为 <code>Flush</code> 的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，
该方法就会把它们从缓冲区中删除掉。</p>
<p><code>bufio.Writer</code> 类型值（以下简称 <code>Writer</code> 值）拥有的所有数据写入方法都会在必要的时候调用它的 <code>Flush</code> 方法。</p>
<p>比如，<code>Write</code> 方法有时候会在把数据写进缓冲区之后，调用 <code>Flush</code> 方法，以便为后续的新数据腾出空间。<code>WriteString</code> 方法的行为与之类似。</p>
<p><code>WriteByte</code> 方法和 <code>WriteRune</code> 方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用 <code>Flush</code> 方法。</p>
<p>在<strong>通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，<code>Flush</code> 方法就一定会被调用</strong>。</p>
<h2 id="readwriter">
  ReadWriter
  <a class="anchor" href="#readwriter">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ReadWriter</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过调用 <code>bufio.NewReadWriter</code> 函数来初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewReadWriter</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ReadWriter</span>
</span></span></code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/shipengqi/golang-learn/commit/44c3ee763ef8b1ef68e8f73c9152c5aa565995fc" title='Last modified by shipengqi | October 7, 2023' target="_blank" rel="noopener">
      <img src="/golang-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>October 7, 2023</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/golang-learn/edit/master/content/content/docs/standards/io/bufio.md" target="_blank" rel="noopener">
      <img src="/golang-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#bufio">bufio</a>
      <ul>
        <li><a href="#bufio包中的数据类型">bufio包中的数据类型</a></li>
        <li><a href="#bufioreader">bufio.Reader</a>
          <ul>
            <li><a href="#bufioreader-类型值中的缓冲区的作用">bufio.Reader 类型值中的缓冲区的作用</a></li>
            <li><a href="#bufioreader-类型读取方法">bufio.Reader 类型读取方法</a></li>
            <li><a href="#peek-方法">Peek 方法</a></li>
            <li><a href="#其他方法">其他方法</a></li>
          </ul>
        </li>
        <li><a href="#bufiowriter">bufio.Writer</a>
          <ul>
            <li><a href="#方法">方法</a></li>
            <li><a href="#bufiowriter-类型值中缓冲的数据什么时候会被写到它的底层写入器">bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器</a></li>
          </ul>
        </li>
        <li><a href="#readwriter">ReadWriter</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












