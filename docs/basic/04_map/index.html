<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="map # map 是一个无序的 key/value 对的集合。map 是引用类型。这意味着它拥有对底层数据结构的引用， 就像指针一样。它底层的数据结构是 hash table 或 hash map。
map 作为引用类型是非常好的，因为无论 map 有多大，都只会有一个副本。
定义 map，使用 map 关键字：
/* 声明变量，默认 map 是 nil */ var 变量名 map[键类型]值类型 /* 使用 make 函数 */ 变量名 := make(map[键类型]值类型) /* 字面值的语法创建 */ 变量名 := map[键类型]值类型{ key1: value1, key2: value2, ... } 一个 map 在未初始化之前默认为 nil。 通过索引下标 key 来访问 map 中对应的 value
age, ok := ages[&#34;bob&#34;] if !ok { /* &#34;bob&#34; is not a key in this map; age == 0."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="map"><meta property="og:description" content="map # map 是一个无序的 key/value 对的集合。map 是引用类型。这意味着它拥有对底层数据结构的引用， 就像指针一样。它底层的数据结构是 hash table 或 hash map。
map 作为引用类型是非常好的，因为无论 map 有多大，都只会有一个副本。
定义 map，使用 map 关键字：
/* 声明变量，默认 map 是 nil */ var 变量名 map[键类型]值类型 /* 使用 make 函数 */ 变量名 := make(map[键类型]值类型) /* 字面值的语法创建 */ 变量名 := map[键类型]值类型{ key1: value1, key2: value2, ... } 一个 map 在未初始化之前默认为 nil。 通过索引下标 key 来访问 map 中对应的 value
age, ok := ages[&#34;bob&#34;] if !ok { /* &#34;bob&#34; is not a key in this map; age == 0."><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/basic/04_map/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-15T17:52:38+08:00"><title>map | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.ec43262b18c4c5bad2a2846e73f04ff636abc29077bbc6c6ffaaf560f8f9c962.js integrity="sha256-7EMmKxjExbrSooRuc/BP9jarwpB3u8bG/6r1YPj5yWI=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/ class=active>map</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_netpooler/>网络轮询器</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>map</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#map>map</a><ul><li><ul><li></li></ul></li><li><a href=#hash-表>hash 表</a></li><li><a href=#数据结构>数据结构</a></li><li><a href=#访问>访问</a></li><li><a href=#写入>写入</a></li><li><a href=#扩容>扩容</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=map>map
<a class=anchor href=#map>#</a></h1><p><code>map</code> 是一个无序的 <code>key/value</code> 对的集合。<strong><code>map</code> 是引用类型</strong>。这意味着它拥有对底层数据结构的引用，
就像指针一样。它底层的数据结构是 <code>hash table</code> 或 <code>hash map</code>。</p><p><code>map</code> 作为引用类型是非常好的，因为无论 <code>map</code> 有多大，都只会有一个副本。</p><p>定义 <code>map</code>，使用 <code>map</code> 关键字：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/* 声明变量，默认 map 是 nil */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>变量名</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>键类型</span>]<span style=color:#a6e22e>值类型</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 使用 make 函数 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>变量名</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>键类型</span>]<span style=color:#a6e22e>值类型</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 字面值的语法创建 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>变量名</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>键类型</span>]<span style=color:#a6e22e>值类型</span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>key1</span>: <span style=color:#a6e22e>value1</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>key2</span>: <span style=color:#a6e22e>value2</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一个 <code>map</code> 在未初始化之前默认为 <code>nil</code>。
通过索引下标 <code>key</code> 来访问 <code>map</code> 中对应的 <code>value</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>age</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ages</span>[<span style=color:#e6db74>&#34;bob&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> { <span style=color:#75715e>/* &#34;bob&#34; is not a key in this map; age == 0. */</span> }
</span></span></code></pre></div><p><code>ok</code> 表示操作结果，是一个布尔值。<strong>这叫做 <code>ok-idiom</code> 模式，就是在多返回值中返回一个 <code>ok</code> 布尔值，表示是否操作
成功</strong>。</p><p>使用 <code>map</code> 过程中需要注意的几点：</p><ul><li><strong><code>map</code> 是无序的，每次打印出来的 <code>map</code> 都会不一样</strong>，它不能通过 <code>index</code> 获取，而必须通过 <code>key</code> 获取</li><li><code>map</code> 的长度是不固定的，也就是和 <code>slice</code> 一样，也是一种引用类型</li><li>内置的 <code>len</code> 函数同样适用于 <code>map</code>，返回 <code>map</code> 拥有的 <code>key</code> 的数量</li><li><code>map</code> 的值可以很方便的修改，通过 <code>numbers["one"]=11</code> 可以很容易的把 <code>key</code> 为 <code>one</code> 的字典值改为 11</li><li><strong><code>map</code> 和其他基本型别不同，它不是 <code>thread-safe</code> 的</strong>，在多个 <code>go-routine</code> 存取时，必须使用 <code>mutex lock</code> 机制</li></ul><h4 id=delete>delete()
<a class=anchor href=#delete>#</a></h4><p><code>delete</code> 函数删除 <code>map</code> 元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>delete(<span style=color:#a6e22e>mapName</span>, <span style=color:#a6e22e>key</span>)
</span></span></code></pre></div><h4 id=遍历>遍历
<a class=anchor href=#%e9%81%8d%e5%8e%86>#</a></h4><p>可以使用 <code>for range</code> 遍历 <code>map</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>mapName</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>mapName</span>[<span style=color:#a6e22e>key</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong><code>Map</code> 的迭代顺序是不确定的。可以先使用 <code>sort</code> 包排序</strong>。</p><h4 id=map-为什么是无序的>map 为什么是无序的
<a class=anchor href=#map-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e6%97%a0%e5%ba%8f%e7%9a%84>#</a></h4><p>编译器对于 slice 和 map 的循环迭代有不同的实现方式，<code>for</code> 遍历 map，调用了两个方法：</p><ul><li><code>runtime.mapiterinit</code></li><li><code>runtime.mapiternext</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapiterinit</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>it</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hiter</span>) {
</span></span><span style=display:flex><span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>t</span> = <span style=color:#a6e22e>t</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>h</span> = <span style=color:#a6e22e>h</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>B</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>kind</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>kindNoPointers</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>createOverflow</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>overflow</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>oldoverflow</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>oldoverflow</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>fastrand</span>())
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> &gt; <span style=color:#ae81ff>31</span><span style=color:#f92672>-</span><span style=color:#a6e22e>bucketCntBits</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>r</span> <span style=color:#f92672>+=</span> uintptr(<span style=color:#a6e22e>fastrand</span>()) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>31</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>startBucket</span> = <span style=color:#a6e22e>r</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>offset</span> = uint8(<span style=color:#a6e22e>r</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>&amp;</span> (<span style=color:#a6e22e>bucketCnt</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>bucket</span> = <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>startBucket</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>mapiternext</span>(<span style=color:#a6e22e>it</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>fastrand</code> 部分，它是一个生成随机数的方法，它生成了随机数。用于决定从哪里开始循环迭代。
因此<strong>每次 <code>for range map</code> 的结果都是不一样的。那是因为它的起始位置根本就不固定</strong>。</p><h4 id=map-的键类型不能是哪些类型>map 的键类型不能是哪些类型
<a class=anchor href=#map-%e7%9a%84%e9%94%ae%e7%b1%bb%e5%9e%8b%e4%b8%8d%e8%83%bd%e6%98%af%e5%93%aa%e4%ba%9b%e7%b1%bb%e5%9e%8b>#</a></h4><p><code>map</code> 的键和元素的最大不同在于，前者的类型是受限的，而后者却可以是任意类型的。</p><p><strong><code>map</code> 的键类型不可以是函数类型、字典类型和切片类型</strong>。</p><p>为什么？</p><p>Go 语言规范规定，在<strong>键类型的值之间必须可以施加操作符 <code>==</code> 和 <code>!=</code></strong>。换句话说，键类型的值必须要支持判等操作。由于
函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。</p><p>另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>badMap2</span> = <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>interface</span>{}]<span style=color:#66d9ef>int</span>{
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1&#34;</span>:   <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>[]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>2</span>}: <span style=color:#ae81ff>2</span>, <span style=color:#75715e>// 这里会引发 panic。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>3</span>:    <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=优先考虑哪些类型作为字典的键类型>优先考虑哪些类型作为字典的键类型
<a class=anchor href=#%e4%bc%98%e5%85%88%e8%80%83%e8%99%91%e5%93%aa%e4%ba%9b%e7%b1%bb%e5%9e%8b%e4%bd%9c%e4%b8%ba%e5%ad%97%e5%85%b8%e7%9a%84%e9%94%ae%e7%b1%bb%e5%9e%8b>#</a></h4><p>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</p><p>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。</p><p>类型的宽度是指它的单个值需要占用的字节数。比如，<code>bool</code>、<code>int8</code> 和 <code>uint8</code> 类型的一个值需要占用的字节数都是 1，因此这些类型的宽度就都是 1。</p><h4 id=在值为-nil-的字典上执行读写操作会成功吗>在值为 nil 的字典上执行读写操作会成功吗
<a class=anchor href=#%e5%9c%a8%e5%80%bc%e4%b8%ba-nil-%e7%9a%84%e5%ad%97%e5%85%b8%e4%b8%8a%e6%89%a7%e8%a1%8c%e8%af%bb%e5%86%99%e6%93%8d%e4%bd%9c%e4%bc%9a%e6%88%90%e5%8a%9f%e5%90%97>#</a></h4><p>当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是 <code>nil</code>。如果你尝试使用一个 <code>nil</code> 的 <code>map</code>，你会得到一个 <code>nil</code> 指针异常，这将导致程序终止运行。所以不应该初始化一个空的 map 变量，比如 <code>var m map[string]string</code>。</p><p><strong>除了添加键 - 元素对，我们在一个值为 <code>nil</code> 的字典上做任何操作都不会引起错误</strong>。当我们试图在一个值为 <code>nil</code> 的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。</p><p>可以先使用 <code>make</code> 函数初始化，或者 <code>dictionary = map[string]string{}</code>。这两种方法都可以创建一个空的 <code>hash map</code> 并指向 <code>dictionary</code>。这确保永远不会获得 <code>nil 指针异常</code>。</p><h2 id=hash-表>hash 表
<a class=anchor href=#hash-%e8%a1%a8>#</a></h2><p>要实现一个性能优异的哈希表，需要注意两个关键点 —— <strong>哈希函数和冲突解决方法</strong>。</p><p>哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求哈希函数的输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p><p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题。哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。</p><p>如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 <code>O(1)</code>；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 <code>O(n)</code> （为什么是 <code>O(n)</code> ，如果使用拉链法解决哈希冲突，极端情况下，hash 函数的结构都在一个索引的链表上，复杂度就是 <code>O(n)</code>），由此看来，使用好的哈希函数是至关重要的。</p><p>常见解决哈希冲突方法的就是开放寻址法和拉链法。</p><p>开放寻址法2是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是<strong>依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中</strong>。</p><p>开放寻址法中对性能影响最大的是<strong>装载因子</strong>，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 <code>O(n)</code> 的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。</p><p>拉链法是哈希表最常见的实现方法。一般会使用<strong>数组加上链表</strong>，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构。</p><p><img src=separate-chaing-and-set.png alt></p><p>上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式是直接对哈希返回的结果取模：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span>(<span style=color:#e6db74>&#34;Key6&#34;</span>) <span style=color:#f92672>%</span> <span style=color:#a6e22e>array</span>.<span style=color:#a6e22e>len</span>
</span></span></code></pre></div><p>选择了 2 号桶后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p><ol><li>找到键相同的键值对 — 更新键对应的值；</li><li>没有找到键相同的键值对 — 在链表的末尾追加新的键值对；</li></ol><h2 id=数据结构>数据结构
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p><code>runtime.hmap</code> 是最核心的结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span>        <span style=color:#75715e>// 哈希表中的元素数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>      <span style=color:#75715e>// 状态标识，主要是 goroutine 写入和扩容机制的相关状态控制。并发读写的判断条件之一就是该值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>      <span style=color:#75715e>// 哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 len(buckets) == 2^B
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span>     <span style=color:#75715e>// 溢出桶的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// 哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>buckets</span>    <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  <span style=color:#75715e>// 当前桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  <span style=color:#75715e>// 哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>         <span style=color:#75715e>// 迁移进度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mapextra</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>overflow</span>    <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>   <span style=color:#a6e22e>为</span> <span style=color:#a6e22e>hmap</span>.<span style=color:#a6e22e>buckets</span> <span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>当前</span><span style=color:#960050;background-color:#1e0010>）</span><span style=color:#a6e22e>溢出桶的指针地址</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>oldoverflow</span> <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>   <span style=color:#a6e22e>为</span> <span style=color:#a6e22e>hmap</span>.<span style=color:#a6e22e>oldbuckets</span> <span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>旧</span><span style=color:#960050;background-color:#1e0010>）</span><span style=color:#a6e22e>溢出桶的指针地址</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>     <span style=color:#a6e22e>为空闲溢出桶的指针地址</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=hmap-and-buckets.png alt></p><p><code>runtime.hmap</code> 的桶是 <code>runtime.bmap</code>。每一个 <strong><code>runtime.bmap</code> 都能存储 8 个键值对</strong>，当哈希表中存储的数据过多，单个桶无法装满时就会使用 <code>extra.nextOverflow</code> 中桶存储溢出的数据。</p><p>述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为<strong>正常桶</strong>和<strong>溢出桶</strong>。黄色的就是正常桶，绿色的是溢出桶。<strong>溢出桶能够减少扩容的频率</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>tophash</span> [<span style=color:#a6e22e>bucketCnt</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>tophash</code> 存储了<strong>键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>topbits</span>  [<span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>keys</span>     [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>keytype</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>values</span>   [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>valuetype</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pad</span>      <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>overflow</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>存储 k 和 v 的载体并不是用 <code>k/v/k/v/k/v/k/v</code> 的模式，而是 <code>k/k/k/k/v/v/v/v</code> 的形式去存储。这是为什么呢？</p><p>例如一个 map <code>map[int64]int8</code>，如果按照 <code>k/v</code> 的形式存放 int64 的 key 占用 8 个字节，最然值 int8 只占用一个字节，但是却需要 7 个填充字节来做内存对齐，就会浪费大量内存空间。</p><p>随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p><h2 id=访问>访问
<a class=anchor href=#%e8%ae%bf%e9%97%ae>#</a></h2><p><code>hash[key]</code> 以及类似的操作都会被转换成哈希的 OINDEXMAP 操作，中间代码生成阶段会在 <code>cmd/compile/internal/gc.walkexpr</code> 函数中将这些 OINDEXMAP 操作转换成如下的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>v</span>     <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span>[<span style=color:#a6e22e>key</span>] <span style=color:#75715e>// =&gt; v     := *mapaccess1(maptype, hash, &amp;key)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span>[<span style=color:#a6e22e>key</span>] <span style=color:#75715e>// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)
</span></span></span></code></pre></div><p>赋值语句左侧接受参数的个数会决定使用的运行时方法：</p><ul><li>当接受一个参数时，会使用 <code>runtime.mapaccess1</code>，该函数仅会返回一个指向目标值的指针；</li><li>当接受两个参数时，会使用 <code>runtime.mapaccess2</code>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 bool 值：</li></ul><p><code>runtime.mapaccess1</code> 会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 <code>runtime.bucketMask</code> 和 <code>runtime.add</code> 拿到该键值对所在的桶序号和哈希高位的 8 位数字。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapaccess1</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>alg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>alg</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alg</span>.<span style=color:#a6e22e>hash</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span> <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span> <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>bucketloop</span>:
</span></span><span style=display:flex><span> <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>alg</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>valuesize</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>zeroVal</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>bucketloop 循环中，哈希会依次遍历正常桶和溢出桶中的数据，它先会比较哈希的高 8 位和桶中存储的 tophash，后比较传入的和桶中的值以加速数据的读写。用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等 tophash 的概率影响性能。</p><p><img src=hashmap-mapaccess.png alt></p><p>每一个桶都是一整片的内存空间，当发现桶中的 tophash 与传入键的 tophash 匹配之后，我们会通过指针和偏移量获取哈希中存储的键 <code>keys[0]</code> 并与 key 比较，如果两者相同就会获取目标值的指针 <code>values[0]</code> 并返回。</p><p>判断是否正在发生扩容（h.oldbuckets 是否为 nil），若正在扩容，则到老的 buckets 中查找（因为 buckets 中可能还没有值，搬迁未完成），若该 bucket 已经搬迁完毕。则到 buckets 中继续查找</p><h2 id=写入>写入
<a class=anchor href=#%e5%86%99%e5%85%a5>#</a></h2><p>当形如 <code>hash[k]</code> 的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成 <code>runtime.mapassign</code> 函数的调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapassign</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>alg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>alg</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alg</span>.<span style=color:#a6e22e>hash</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> ^= <span style=color:#a6e22e>hashWriting</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>again</span>:
</span></span><span style=display:flex><span> <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>bucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span> <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span></code></pre></div><p>通过遍历比较桶中存储的 tophash 和键的哈希，如果找到了相同结果就会返回目标位置的地址。其中 inserti 表示目标元素的在桶中的索引，insertk 和 val 分别表示键值对的地址，获得目标地址之后会通过算术计算寻址获得键值对 k 和 val：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>insertk</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>val</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bucketloop</span>:
</span></span><span style=display:flex><span> <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>val</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>valuesize</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>alg</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>val</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>valuesize</span>))
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>ovf</span>
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>for 循环会依次遍历正常桶和溢出桶中存储的数据，整个过程会分别判断 tophash 是否相等、key 是否相等，遍历结束后会从循环中跳出。</p><p><img src=hashmap-overflow-bucket.png alt></p><p>如果当前桶已经满了，哈希会调用 <code>runtime.hmap.newoverflow</code> 创建新桶或者使用 <code>runtime.hmap</code> 预先在 <code>noverflow</code> 中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的 <code>noverflow</code> 计数器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newb</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>newoverflow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newb</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>newb</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>val</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span><span style=color:#a6e22e>inserti</span> = <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>done</span>:
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=扩容>扩容
<a class=anchor href=#%e6%89%a9%e5%ae%b9>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>装载因子 :<span style=color:#f92672>=</span> 元素数量 ÷ 桶数量
</span></span></code></pre></div><p><code>runtime.mapassign</code> 函数会在以下两种情况发生时触发哈希的扩容：</p><ul><li>装载因子已经超过 6.5；</li><li>哈希使用了太多溢出桶；</li></ul><p>哈希的扩容不是一个原子的过程，所以 <code>runtime.mapassign</code> 还需要<strong>判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱</strong>。</p><p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是<strong>等量扩容 <code>sameSizeGrow</code></strong>，sameSizeGrow 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏。runtime: limit the number of map overflow buckets 引入了 <strong>sameSizeGrow 通过复用已有的哈希扩容机制解决该问题，一旦哈希中出现了过多的溢出桶，它会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存</strong>。</p><p>扩容的入口是 <code>runtime.hashGrow</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>bigger</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>bigger</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>sameSizeGrow</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#a6e22e>oldbuckets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>newbuckets</span>, <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bigger</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>bigger</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> = <span style=color:#a6e22e>flags</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span> = <span style=color:#a6e22e>oldbuckets</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newbuckets</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>oldoverflow</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>哈希在扩容的过程中会通过 runtime.makeBucketArray 创建一组新桶和预创建的溢出桶，随后将原有的桶数组设置到 oldbuckets 上并将新的空桶设置到 buckets 上，溢出桶也使用了相同的逻辑更新，下图展示了触发扩容后的哈希：</p><p><img src=hashmap-hashgrow.png alt></p><p>为什么是增量扩容？</p><p>“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p><p>如果是全量扩容的话，那问题就来了。假设当前 hmap 的容量比较大，直接全量扩容的话，就会导致扩容要花费大量的时间和内存，导致系统卡顿，最直观的表现就是慢。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>evacDst</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>  <span style=color:#75715e>// 当前目标桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 当前目标桶存储的键值对数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>k</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  <span style=color:#75715e>// 指向当前 key 的内存地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>v</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  <span style=color:#75715e>// 指向当前 value 的内存地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>evacDst 是迁移中的基础数据结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>oldbucket</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span> <span style=color:#a6e22e>newbit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noldbuckets</span>()
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>evacuated</span>(<span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>xy</span> [<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>evacDst</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>+</span><span style=color:#a6e22e>newbit</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>            <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oldIterator</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>kind</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>kindNoPointers</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>))
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>dataOffset</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>memclrHasPointers</span>(<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldbucket</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>advanceEvacuationMark</span>(<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>newbit</span>)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>计算并得到 oldbucket 的 bmap 指针地址
计算 hmap 在增长之前的桶数量
判断当前的迁移（搬迁）状态，以便流转后续的操作。若没有正在进行迁移 !evacuated(b) ，则根据扩容的规则的不同，当规则为等量扩容 sameSizeGrow 时，只使用一个 evacDst 桶用于分流。而为双倍扩容时，就会使用两个 evacDst 进行分流操作
当分流完毕后，需要迁移的数据都会通过 typedmemmove 函数迁移到指定的目标桶上
若当前不存在 flags 使用标志、使用 oldbucket 迭代器、bucket 不为指针类型。则取消链接溢出桶、清除键值
在最后 advanceEvacuationMark 函数中会对迁移进度 hmap.nevacuate 进行累积计数，并调用 bucketEvacuated 对旧桶 oldbuckets 进行不断的迁移。直至全部迁移完毕。那么也就表示扩容完毕了，会对 hmap.oldbuckets 和 h.extra.oldoverflow 进行清空</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/e2c1b9369331db41bcc14cb50249d04165b4bc8c title='Last modified by shipengqi | October 15, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 15, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/basic/04_map.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#map>map</a><ul><li><ul><li></li></ul></li><li><a href=#hash-表>hash 表</a></li><li><a href=#数据结构>数据结构</a></li><li><a href=#访问>访问</a></li><li><a href=#写入>写入</a></li><li><a href=#扩容>扩容</a></li></ul></li></ul></nav></div></aside></main></body></html>