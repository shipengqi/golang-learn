<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="面向对象 # GO 支持面向对象编程。
方法 # 方法声明：
func (变量名 类型) 方法名() [返回类型]{ /* 函数体*/ } 实例：
/* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&#34;Area of Circle(c1) = &#34;, c1.getArea()) } // 该 method 属于 Circle 类型对象中的方法 // 这里的 c 叫作方法的接收器，类似 Javascript 的 this func (c Circle) getArea() float64 { // c.radius 即为 Circle 类型对象中的属性 return 3.14 * c."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="面向对象"><meta property="og:description" content="面向对象 # GO 支持面向对象编程。
方法 # 方法声明：
func (变量名 类型) 方法名() [返回类型]{ /* 函数体*/ } 实例：
/* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&#34;Area of Circle(c1) = &#34;, c1.getArea()) } // 该 method 属于 Circle 类型对象中的方法 // 这里的 c 叫作方法的接收器，类似 Javascript 的 this func (c Circle) getArea() float64 { // c.radius 即为 Circle 类型对象中的属性 return 3.14 * c."><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/basic/15_oop/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-22T19:30:19+08:00"><title>面向对象 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.a9a0c7ebf102ff8cc5b852bb51cebc2548b7397c4262df29bb65cf30db23157f.js integrity="sha256-qaDH6/EC/4zFuFK7Uc68JUi3OXxCYt8pu2XPMNsjFX8=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>map</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/ class=active>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li><li><a href=/golang-learn/docs/advance/04_netpooler/>网络轮询器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>面向对象</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#面向对象>面向对象</a><ul><li><a href=#方法>方法</a><ul><li><a href=#如何选择-receiver-的类型>如何选择 receiver 的类型</a></li><li><a href=#方法集>方法集</a></li></ul></li><li><a href=#嵌入结构体扩展类型>嵌入结构体扩展类型</a><ul><li><a href=#go-语言是用嵌入字段实现了继承吗>Go 语言是用嵌入字段实现了继承吗</a></li></ul></li><li><a href=#封装>封装</a></li><li><a href=#string-方法><code>String</code> 方法</a></li></ul></li><li><a href=#结构体>结构体</a><ul><li><a href=#结构体的零值>结构体的零值</a></li><li><a href=#结构体字面值>结构体字面值</a></li><li><a href=#结构体比较>结构体比较</a></li><li><a href=#结构体嵌入-匿名成员>结构体嵌入 匿名成员</a><ul><li><a href=#嵌入接口类型>嵌入接口类型</a></li><li><a href=#如果被嵌入类型和嵌入类型有同名的方法那么调用哪一个的方法>如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=面向对象>面向对象
<a class=anchor href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1>#</a></h1><p>GO 支持面向对象编程。</p><h2 id=方法>方法
<a class=anchor href=#%e6%96%b9%e6%b3%95>#</a></h2><p>方法声明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>变量名</span> <span style=color:#a6e22e>类型</span>) <span style=color:#a6e22e>方法名</span>() [<span style=color:#a6e22e>返回类型</span>]{
</span></span><span style=display:flex><span>   <span style=color:#75715e>/* 函数体*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/* 定义结构体 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Circle</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>radius</span> <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c1</span> <span style=color:#a6e22e>Circle</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>c1</span>.<span style=color:#a6e22e>radius</span> = <span style=color:#ae81ff>10.00</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Area of Circle(c1) = &#34;</span>, <span style=color:#a6e22e>c1</span>.<span style=color:#a6e22e>getArea</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 该 method 属于 Circle 类型对象中的方法
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 这里的 c 叫作方法的接收器，类似 Javascript 的 this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>Circle</span>) <span style=color:#a6e22e>getArea</span>() <span style=color:#66d9ef>float64</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// c.radius 即为 Circle 类型对象中的属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3.14</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>radius</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>radius</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Go 没有像其它语言那样用 <code>this</code> 或者 <code>self</code> 作为接收器。<strong>Go 可以给任意类型定义方法</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Point</span>) <span style=color:#a6e22e>ScaleBy</span>(<span style=color:#a6e22e>factor</span> <span style=color:#66d9ef>float64</span>) {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>X</span> <span style=color:#f92672>*=</span> <span style=color:#a6e22e>factor</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Y</span> <span style=color:#f92672>*=</span> <span style=color:#a6e22e>factor</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>调用指针类型方法<code>(*Point).ScaleBy</code>，<code>()</code>必须有，否则会被理解为<code>*(Point.ScaleBy)</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 调用指针类型方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>ScaleBy</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 简短写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ScaleBy</span>(<span style=color:#ae81ff>2</span>)
</span></span></code></pre></div><p>只有类型(<code>Point</code>)和指向他们的指针(<code>*Point</code>)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，
如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>P</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>P</span>) <span style=color:#a6e22e>f</span>() { <span style=color:#75715e>/* ... */</span> } <span style=color:#75715e>// compile error: invalid receiver type
</span></span></span></code></pre></div><h3 id=如何选择-receiver-的类型>如何选择 receiver 的类型
<a class=anchor href=#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9-receiver-%e7%9a%84%e7%b1%bb%e5%9e%8b>#</a></h3><ol><li><strong>不管你的 <code>method</code> 的 <code>receiver</code> 是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换</strong>。</li><li>在声明一个 <code>method</code> 的 <code>receiver</code> 该是指针还是非指针类型时，你需要考虑：</li></ol><ul><li>要修改实例状态，用 <code>*T</code>，无需修改使用 <code>T</code>。</li><li>大对象建议使用 <code>*T</code>，减少复制成本，<code>T</code> 调用时会产生一次拷贝。</li><li>对于引用类型，直接使用 <code>T</code>，因为它们本身就是指针包装的。</li><li>包含 <code>Mutex</code> 等并发原语的，使用 <code>*T</code>，避免因为复制造成锁操作无效。</li><li>无法确定时，使用 <code>*T</code>。</li></ul><p><strong>方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型</strong>。</p><ul><li>值方法，就是接收者类型是非指针的自定义数据类型的方法。</li><li>指针方法，就是接收者类型是指针类型的方法。</li></ul><h4 id=实现了-interface-的方法>实现了 interface 的方法
<a class=anchor href=#%e5%ae%9e%e7%8e%b0%e4%ba%86-interface-%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h4><p>如果一个类型实现的某个接口的方法，如果接收者是指针类型，那么只能指针赋值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>I</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>Get</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>S</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>S</span>) <span style=color:#a6e22e>Get</span>() {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;get&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>ss</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>S</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#a6e22e>I</span>
</span></span><span style=display:flex><span> <span style=color:#75715e>//i = ss , 此处编译不过
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>//i.Get()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>i</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ss</span> <span style=color:#75715e>// 必须是指针赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>Get</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果接收者是非指针类型，那么值和指针都可以赋值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#a6e22e>ss</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>S</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#a6e22e>I</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>ss</span>  <span style=color:#75715e>// 可以赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>Get</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>i</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ss</span> <span style=color:#75715e>// 可以赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>Get</span>()
</span></span></code></pre></div><h3 id=方法集>方法集
<a class=anchor href=#%e6%96%b9%e6%b3%95%e9%9b%86>#</a></h3><p>Golang 方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p><pre tabindex=0><code>• 类型 T 方法集包含全部 receiver T 方法。
• 类型 *T 方法集包含全部 receiver T + *T 方法。

• 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。
• 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。
• 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。
</code></pre><p><strong>对于结构体嵌套匿名字段的类型是指针还是非指针</strong>，根据实际情况决定。</p><h2 id=嵌入结构体扩展类型>嵌入结构体扩展类型
<a class=anchor href=#%e5%b5%8c%e5%85%a5%e7%bb%93%e6%9e%84%e4%bd%93%e6%89%a9%e5%b1%95%e7%b1%bb%e5%9e%8b>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;image/color&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Point</span> <span style=color:#66d9ef>struct</span>{ <span style=color:#a6e22e>X</span>, <span style=color:#a6e22e>Y</span> <span style=color:#66d9ef>float64</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ColoredPoint</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Point</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Color</span> <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>RGBA</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>red</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>RGBA</span>{<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>blue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>RGBA</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>ColoredPoint</span>{<span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>}, <span style=color:#a6e22e>red</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>q</span> = <span style=color:#a6e22e>ColoredPoint</span>{<span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>}, <span style=color:#a6e22e>blue</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Distance</span>(<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Point</span>)) <span style=color:#75715e>// &#34;5&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ScaleBy</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>ScaleBy</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Distance</span>(<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Point</span>)) <span style=color:#75715e>// &#34;10&#34;
</span></span></span></code></pre></div><p>如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将 <code>Point</code> 看作一个基类，而 <code>ColoredPoint</code> 看作其子类或者继承类。
但这是错误的理解。请注意上面例子中对 <code>Distance</code> 方法的调用。<code>Distance</code> 有一个参数是 <code>Point</code> 类型，但是这里的 <code>q</code> 虽然貌
似是继承了<code>Point</code> 类，但 <code>q</code> 并不是，所以尽管 <code>q</code> 有着 <code>Point</code> 这个内嵌类型，我们也必须要显式传入 <code>q.Point</code>。</p><h3 id=go-语言是用嵌入字段实现了继承吗>Go 语言是用嵌入字段实现了继承吗
<a class=anchor href=#go-%e8%af%ad%e8%a8%80%e6%98%af%e7%94%a8%e5%b5%8c%e5%85%a5%e5%ad%97%e6%ae%b5%e5%ae%9e%e7%8e%b0%e4%ba%86%e7%bb%a7%e6%89%bf%e5%90%97>#</a></h3><p>Go 语言中<strong>没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合</strong>。
具体原因和理念请见 <a href=https://golang.org/doc/faq#inheritance>Why is there no type inheritance?</a>。</p><p>简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。
类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。</p><p>同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。我们要做的只是把类型当做字段嵌入进来，然后坐
享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。</p><p>另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。</p><p>这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。再者，组合要比继承更加简洁和清晰，Go 语言可以轻而易举地通过嵌入
多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。</p><h2 id=封装>封装
<a class=anchor href=#%e5%b0%81%e8%a3%85>#</a></h2><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。通过首字母大小写来定义是否从包中导出。
封装一个对象，必须定义为一个 <code>struct</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntSet</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优点：</p><ul><li>调用方不能直接修改对象的变量值</li><li>隐藏实现的细节，防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。</li><li>阻止了外部调用方对对象内部的值任意地进行修改。</li></ul><h2 id=string-方法><code>String</code> 方法
<a class=anchor href=#string-%e6%96%b9%e6%b3%95>#</a></h2><p>在 Go 语言中，<strong>我们可以通过为一个类型编写名为 <code>String</code> 的方法，来自定义该类型的字符串表示形式。这个 <code>String</code> 方法不需
要任何参数声明，但需要有一个 <code>string</code> 类型的结果声明</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AnimalCategory</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kingdom</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 界。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>phylum</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 门。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>class</span>  <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 纲。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>order</span>  <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 目。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>family</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 科。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>genus</span>  <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 属。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>species</span> <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 种。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ac</span> <span style=color:#a6e22e>AnimalCategory</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s%s%s%s%s%s%s&#34;</span>,<span style=color:#a6e22e>ac</span>.<span style=color:#a6e22e>kingdom</span>, <span style=color:#a6e22e>ac</span>.<span style=color:#a6e22e>phylum</span>, <span style=color:#a6e22e>ac</span>.<span style=color:#a6e22e>class</span>, <span style=color:#a6e22e>ac</span>.<span style=color:#a6e22e>order</span>,<span style=color:#a6e22e>ac</span>.<span style=color:#a6e22e>family</span>, <span style=color:#a6e22e>ac</span>.<span style=color:#a6e22e>genus</span>, <span style=color:#a6e22e>ac</span>.<span style=color:#a6e22e>species</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>category</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>AnimalCategory</span>{<span style=color:#a6e22e>species</span>: <span style=color:#e6db74>&#34;cat&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;The animal category: %s\n&#34;</span>, <span style=color:#a6e22e>category</span>)
</span></span></code></pre></div><p>正因为如此，我在调用 <code>fmt.Printf</code> 函数时，使用占位符 <code>%s</code> 和 <code>category</code> 值本身就可以打印出后者的字符串表示形式，
而<strong>无需显式地调用它的 <code>String</code> 方法</strong>。</p><p><code>fmt.Printf</code> 函数会自己去寻找它。此时的打印内容会是 <code>The animal category: cat</code>。显而易见，<code>category</code> 的 <code>String</code> 方法成
功地引用了当前值的所有字段。</p><p>当你广泛使用一个自定义类型时，最好为它定义 <code>String()</code> 方法。</p><p><strong>不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误</strong>，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TT</span> <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>TT</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%v&#34;</span>, <span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>String</span>()
</span></span></code></pre></div><p>它导致了一个无限递归调用（<code>TT.String()</code> 调用 <code>fmt.Sprintf</code>，而 <code>fmt.Sprintf</code> 又会反过来调用 <code>TT.String()</code>&mldr;），很快就会导
致内存溢出。</p><h1 id=结构体>结构体
<a class=anchor href=#%e7%bb%93%e6%9e%84%e4%bd%93>#</a></h1><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。
结构体定义需要使用 <code>type</code> 和 <code>struct</code> 语句, <code>struct</code> 语句定义一个新的数据类型, <code>type</code> 语句定义了结构体的名称：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 定义了结构体类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>struct_variable_type</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>member</span> <span style=color:#a6e22e>definition</span>;
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>member</span> <span style=color:#a6e22e>definition</span>;
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>member</span> <span style=color:#a6e22e>definition</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>variable_name</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structure_variable_type</span>{<span style=color:#a6e22e>value1</span>, <span style=color:#a6e22e>value2</span><span style=color:#f92672>...</span><span style=color:#a6e22e>valuen</span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 或
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>variable_name</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structure_variable_type</span>{ <span style=color:#a6e22e>key1</span>: <span style=color:#a6e22e>value1</span>, <span style=color:#a6e22e>key2</span>: <span style=color:#a6e22e>value2</span><span style=color:#f92672>...</span>, <span style=color:#a6e22e>keyn</span>: <span style=color:#a6e22e>valuen</span>}
</span></span></code></pre></div><p>用点号 <code>.</code> 操作符访问结构体成员, 实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Books</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>title</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>author</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>subject</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>book_id</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Book1</span> <span style=color:#a6e22e>Books</span>        <span style=color:#75715e>/* 声明 Book1 为 Books 类型 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>/* book 1 描述 */</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>title</span> = <span style=color:#e6db74>&#34;Go 语言&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>author</span> = <span style=color:#e6db74>&#34;www.runoob.com&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>subject</span> = <span style=color:#e6db74>&#34;Go 语言教程&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>book_id</span> = <span style=color:#ae81ff>6495407</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 打印 Book1 信息 */</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>( <span style=color:#e6db74>&#34;Book 1 title : %s\n&#34;</span>, <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>title</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>( <span style=color:#e6db74>&#34;Book 1 author : %s\n&#34;</span>, <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>author</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>( <span style=color:#e6db74>&#34;Book 1 subject : %s\n&#34;</span>, <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>subject</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>( <span style=color:#e6db74>&#34;Book 1 book_id : %d\n&#34;</span>, <span style=color:#a6e22e>Book1</span>.<span style=color:#a6e22e>book_id</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>.</code> 点操作符也可以和指向结构体的指针一起工作:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>employeeOfTheMonth</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Employee</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>dilbert</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>employeeOfTheMonth</span>.<span style=color:#a6e22e>Position</span> <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34; (proactive team player)&#34;</span>
</span></span></code></pre></div><p><strong>一个结构体可能同时包含导出和未导出的成员, 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。
未导出的成员, 不允许在外部包修改。</strong></p><p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Employee</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>ID</span>            <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>Address</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>Salary</span>        <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一个命名为 S 的结构体类型将不能再包含 S 类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）
但是S类型的结构体可以包含 <code>*S</code> 指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>tree</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>value</span>       <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>tree</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=结构体的零值>结构体的零值
<a class=anchor href=#%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e9%9b%b6%e5%80%bc>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>AgeYears</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Friends</span> []<span style=color:#a6e22e>Person</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>Person</span> <span style=color:#75715e>// Person{0, &#34;&#34;, nil}
</span></span></span></code></pre></div><p>变量 <code>p</code> 只声明但没有赋值，所以 <code>p</code> 的所有字段都有对应的零值。</p><p><strong>注意如果声明结构体指针使用 <code>var p *Person</code> 的方式，那么 <code>p</code> 只是一个 <code>nil</code> 指针，建议使用 <code>p := &amp;Person{}</code> 的方式声明，
<code>p</code> 的值是 <code>&amp;Person{0, "", nil}</code>，避免 json unmarshal 出错</strong>。</p><h2 id=结构体字面值>结构体字面值
<a class=anchor href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%ad%97%e9%9d%a2%e5%80%bc>#</a></h2><p>结构体字面值可以指定每个成员的值:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Point</span> <span style=color:#66d9ef>struct</span>{ <span style=color:#a6e22e>X</span>, <span style=color:#a6e22e>Y</span> <span style=color:#66d9ef>int</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span></code></pre></div><h2 id=结构体比较>结构体比较
<a class=anchor href=#%e7%bb%93%e6%9e%84%e4%bd%93%e6%af%94%e8%be%83>#</a></h2><p>两个结构体将可以使用 <code>==</code> 或 <code>!=</code> 运算符进行比较。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Point</span> <span style=color:#66d9ef>struct</span>{ <span style=color:#a6e22e>X</span>, <span style=color:#a6e22e>Y</span> <span style=color:#66d9ef>int</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>q</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>X</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>X</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Y</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Y</span>) <span style=color:#75715e>// &#34;false&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>q</span>)                   <span style=color:#75715e>// &#34;false&#34;
</span></span></span></code></pre></div><h2 id=结构体嵌入-匿名成员>结构体嵌入 匿名成员
<a class=anchor href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%b5%8c%e5%85%a5-%e5%8c%bf%e5%90%8d%e6%88%90%e5%91%98>#</a></h2><p>Go 语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，
这样就可以通过简单的点运算符 <code>x.f</code> 来访问匿名成员链中嵌套的 <code>x.d.e.f</code> 成员。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Point</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>X</span>, <span style=color:#a6e22e>Y</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Circle</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Center</span> <span style=color:#a6e22e>Point</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Radius</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Wheel</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Circle</span> <span style=color:#a6e22e>Circle</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Spokes</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码，会使访问每个成员变得繁琐：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>w</span> <span style=color:#a6e22e>Wheel</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Circle</span>.<span style=color:#a6e22e>Center</span>.<span style=color:#a6e22e>X</span> = <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Circle</span>.<span style=color:#a6e22e>Center</span>.<span style=color:#a6e22e>Y</span> = <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Circle</span>.<span style=color:#a6e22e>Radius</span> = <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Spokes</span> = <span style=color:#ae81ff>20</span>
</span></span></code></pre></div><p>Go 语言有一个特性可以<strong>只声明一个成员对应的数据类型而定义成员的名字；这类成员就叫匿名成员</strong>。Go 语言规范规定，
如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。
匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Point</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>X</span>, <span style=color:#a6e22e>Y</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Circle</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Point</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Radius</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Wheel</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Circle</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Spokes</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>w</span> <span style=color:#a6e22e>Wheel</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>X</span> = <span style=color:#ae81ff>8</span>            <span style=color:#75715e>// equivalent to w.Circle.Point.X = 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Y</span> = <span style=color:#ae81ff>8</span>            <span style=color:#75715e>// equivalent to w.Circle.Point.Y = 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Radius</span> = <span style=color:#ae81ff>5</span>       <span style=color:#75715e>// equivalent to w.Circle.Radius = 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Spokes</span> = <span style=color:#ae81ff>20</span>
</span></span></code></pre></div><p>上面的代码中，<code>Circle</code> 和 <code>Wheel</code> 各自都有一个匿名成员。我们可以说 <code>Point</code> 类型被嵌入到了 <code>Circle</code> 结构体，
同时 <code>Circle</code> 类型被嵌入到了 <code>Wheel</code> 结构体。但是<strong>结构体字面值并没有简短表示匿名成员的语法</strong>，所以下面的代码，
会编译失败：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>w</span> = <span style=color:#a6e22e>Wheel</span>{<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>20</span>}                       <span style=color:#75715e>// compile error: unknown fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>w</span> = <span style=color:#a6e22e>Wheel</span>{<span style=color:#a6e22e>X</span>: <span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>Y</span>: <span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>Radius</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>Spokes</span>: <span style=color:#ae81ff>20</span>} <span style=color:#75715e>// compile error: unknown fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 正确的语法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>w</span> = <span style=color:#a6e22e>Wheel</span>{<span style=color:#a6e22e>Circle</span>{<span style=color:#a6e22e>Point</span>{<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>}, <span style=color:#ae81ff>5</span>}, <span style=color:#ae81ff>20</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>w</span> = <span style=color:#a6e22e>Wheel</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Circle</span>: <span style=color:#a6e22e>Circle</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Point</span>:  <span style=color:#a6e22e>Point</span>{<span style=color:#a6e22e>X</span>: <span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>Y</span>: <span style=color:#ae81ff>8</span>},
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Radius</span>: <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Spokes</span>: <span style=color:#ae81ff>20</span>, <span style=color:#75715e>// NOTE: trailing comma necessary here (and at Radius)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><strong>不能同时包含两个类型相同的匿名成员，这会导致名字冲突</strong>。</p><h3 id=嵌入接口类型>嵌入接口类型
<a class=anchor href=#%e5%b5%8c%e5%85%a5%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b>#</a></h3><p>Go 语言的结构体还可以嵌入接口类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Interface</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Array 实现 Interface 接口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Array</span> []<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arr</span> <span style=color:#a6e22e>Array</span>) <span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arr</span> <span style=color:#a6e22e>Array</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>] &lt; <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arr</span> <span style=color:#a6e22e>Array</span>) <span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 匿名接口(anonymous interface)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>reverse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Interface</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 重写(override)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>reverse</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Interface</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 构造 reverse Interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Reverse</span>(<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>Interface</span>) <span style=color:#a6e22e>Interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>reverse</span>{<span style=color:#a6e22e>data</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Array</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rarr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Reverse</span>(<span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>rarr</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>reverse</code> 结构体内嵌了一个名为 <code>Interface</code> 的 <code>interface</code>，并且实现 <code>Less</code> 函数，但是
却没有实现 <code>Len</code>, <code>Swap</code> 函数。</p><p>为什么这么设计？</p><p>通过这种方法可以让 <strong><code>reverse</code> 实现 <code>Interface</code> 这个接口类型，并且仅实现某个指定的方法，而不需要实现这个接口下的所有方法</strong>。</p><p>对比一下传统的组合匿名结构体实现重写的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Interface</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Array</span> []<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arr</span> <span style=color:#a6e22e>Array</span>) <span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arr</span> <span style=color:#a6e22e>Array</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>] &lt; <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>arr</span> <span style=color:#a6e22e>Array</span>) <span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 匿名struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>reverse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Array</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 重写
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>reverse</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Array</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 构造 reverse Interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Reverse</span>(<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>Array</span>) <span style=color:#a6e22e>Interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>reverse</span>{<span style=color:#a6e22e>data</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Array</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rarr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Reverse</span>(<span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>rarr</span>.<span style=color:#a6e22e>Less</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>匿名接口的优点，<strong>匿名接口的方式不依赖具体实现，可以对任意实现了该接口的类型进行重写</strong>。</p><h3 id=如果被嵌入类型和嵌入类型有同名的方法那么调用哪一个的方法>如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法
<a class=anchor href=#%e5%a6%82%e6%9e%9c%e8%a2%ab%e5%b5%8c%e5%85%a5%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%b5%8c%e5%85%a5%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%90%8c%e5%90%8d%e7%9a%84%e6%96%b9%e6%b3%95%e9%82%a3%e4%b9%88%e8%b0%83%e7%94%a8%e5%93%aa%e4%b8%80%e4%b8%aa%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h3><p><strong>只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法</strong>。</p><p>类似的，由于我们同样可以像访问被嵌入类型的字段那样，直接访问嵌入字段的字段，所以<strong>如果这两个结构体类型里存在同名的字段，
那么嵌入字段中的那个字段一定会被“屏蔽”</strong>。</p><p>正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。</p><p><strong>不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法</strong>。</p><p>嵌入字段本身也有嵌入字段的情况，这种情况下，“屏蔽”现象会以嵌入的层级为依据，嵌入层级越深的字段或方法越可能被“屏蔽”。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/9fb15a88d58ff7b7f2b86ddea21d7ddc5d3f2db5 title='Last modified by shipengqi | October 22, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 22, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/basic/15_oop.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#面向对象>面向对象</a><ul><li><a href=#方法>方法</a><ul><li><a href=#如何选择-receiver-的类型>如何选择 receiver 的类型</a></li><li><a href=#方法集>方法集</a></li></ul></li><li><a href=#嵌入结构体扩展类型>嵌入结构体扩展类型</a><ul><li><a href=#go-语言是用嵌入字段实现了继承吗>Go 语言是用嵌入字段实现了继承吗</a></li></ul></li><li><a href=#封装>封装</a></li><li><a href=#string-方法><code>String</code> 方法</a></li></ul></li><li><a href=#结构体>结构体</a><ul><li><a href=#结构体的零值>结构体的零值</a></li><li><a href=#结构体字面值>结构体字面值</a></li><li><a href=#结构体比较>结构体比较</a></li><li><a href=#结构体嵌入-匿名成员>结构体嵌入 匿名成员</a><ul><li><a href=#嵌入接口类型>嵌入接口类型</a></li><li><a href=#如果被嵌入类型和嵌入类型有同名的方法那么调用哪一个的方法>如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>