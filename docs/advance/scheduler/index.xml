<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go Learning – 调度器</title><link>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/</link><description>Recent content in 调度器 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://shipengqi.github.io/golang-learn/docs/advance/scheduler/index.xml" rel="self" type="application/rss+xml"/><item><title>GPM 模型和一些重要的数据结构</title><link>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/01_gpm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/01_gpm/</guid><description>
&lt;p>&lt;strong>goroutine 建立在操作系统线程基础之上，它与操作系统线程之间实现了一个多对多 (&lt;code>M:N&lt;/code>) 的两级线程模型&lt;/strong>。&lt;/p>
&lt;p>这里的 &lt;code>M:N&lt;/code> 是指 &lt;strong>M 个 goroutine 运行在 N 个操作系统线程之上&lt;/strong>。&lt;strong>操作系统内核负责对这 N 个操作系统线程进行调度&lt;/strong>，而这 &lt;strong>N 个系统线程又负责对这 M 个 goroutine 进行调度&lt;/strong>和运行。&lt;/p>
&lt;p>goroutine 调度器的大概工作流程：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 程序启动时的初始化代码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">......&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 创建 N 个操作系统线程执行 schedule 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">create_os_thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">schedule&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 创建一个操作系统线程执行 schedule 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// schedule 函数实现调度逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 调度循环
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 根据某种算法从 M 个 goroutine 中找出一个需要运行的 goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">find_a_runnable_goroutine_from_M_goroutines&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">run_g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// CPU 运行该 goroutine，直到需要调度其它 goroutine 才返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">save_status_of_g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 保存 goroutine 的状态，主要是寄存器的值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>程序运行起来之后创建了 N 个由内核调度的操作系统线程去执行 &lt;code>shedule&lt;/code> 函数。&lt;/li>
&lt;li>&lt;code>schedule&lt;/code> 函数在一个调度循环中反复从 M 个 goroutine 中挑选出一个需要运行的 goroutine 并跳转到该 goroutine 去运行。&lt;/li>
&lt;li>直到需要调度其它 goroutine 时才返回到 &lt;code>schedule&lt;/code> 函数中通过 &lt;code>save_status_of_g&lt;/code> 保存刚刚正在运行的 goroutine 的状态然后再次去寻找下一个 goroutine。&lt;/li>
&lt;/ol>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">系统线程对 goroutine 的调度与内核对系统线程的调度原理是一样的，都是&lt;strong>通过保存和修改 CPU 寄存器的值来达到切换线程 或 goroutine 的目的&lt;/strong>。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h2>调度器相关数据结构&lt;span class="hx-absolute -hx-mt-20" id="调度器相关数据结构">&lt;/span>
&lt;a href="#%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>g 结构体（goroutine）&lt;span class="hx-absolute -hx-mt-20" id="g-结构体goroutine">&lt;/span>
&lt;a href="#g-%e7%bb%93%e6%9e%84%e4%bd%93goroutine" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>为了实现对 goroutine 的调度，需要引入一个数据结构来保存 CPU 寄存器的值以及 goroutine 的其它一些状态信息，在 Go 调度器源代码中，这个数据结构是一个名叫 &lt;strong>&lt;code>g&lt;/code> 的结构体&lt;/strong>。该结构体的每一个实例对象都代表了一个 goroutine。&lt;/p>
&lt;p>调度器代码可以通过 &lt;code>g&lt;/code> 对象来对 goroutine 进行调度:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>当 goroutine 被调离 CPU 时，调度器代码负责把 CPU 寄存器的值保存在 &lt;code>g&lt;/code> 对象的成员变量之中&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>当 goroutine 被调度起来运行时，调度器代码又负责把 &lt;code>g&lt;/code> 对象的成员变量所保存的寄存器的值恢复到 CPU 的寄存器&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3>schedt 结构体（调度器）&lt;span class="hx-absolute -hx-mt-20" id="schedt-结构体调度器">&lt;/span>
&lt;a href="#schedt-%e7%bb%93%e6%9e%84%e4%bd%93%e8%b0%83%e5%ba%a6%e5%99%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>只有 &lt;code>g&lt;/code> 结构体对象是不够的，还需要一个&lt;strong>存放所有（可运行）goroutine 的容器&lt;/strong>，便于工作线程寻找需要被调度起来运行的 goroutine，于是 Go 调度器又引入了 &lt;strong>&lt;code>schedt&lt;/code> 结构体&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>用来保存调度器自身的状态信息；&lt;/li>
&lt;li>保存 goroutine 的运行队列。&lt;/li>
&lt;/ul>
&lt;h4>全局运行队列&lt;span class="hx-absolute -hx-mt-20" id="全局运行队列">&lt;/span>
&lt;a href="#%e5%85%a8%e5%b1%80%e8%bf%90%e8%a1%8c%e9%98%9f%e5%88%97" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>每个 Go 程序只有一个调度器，所以在每个 Go 程序中 &lt;strong>&lt;code>schedt&lt;/code> 结构体只有一个实例对象&lt;/strong>，该实例对象在源代码中被定义成了一个共享的全局变量，这样每个工作线程都可以访问它以及它所拥有的 goroutine 运行队列，我们称这个运行队列为&lt;strong>全局运行队列&lt;/strong>。&lt;/p>
&lt;h4>线程运行队列&lt;span class="hx-absolute -hx-mt-20" id="线程运行队列">&lt;/span>
&lt;a href="#%e7%ba%bf%e7%a8%8b%e8%bf%90%e8%a1%8c%e9%98%9f%e5%88%97" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>这个&lt;strong>全局运行队列是每个工作线程都可以访问的，那就涉及到并发的问题&lt;/strong>，因此需要加锁。但是在高并发的场景下，加锁是会导致性能问题的。于是调度器又为&lt;strong>每个工作线程引入了一个私有的局部 goroutine 运行队列&lt;/strong>，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这大大减少了锁冲突，提高了工作线程的并发性。&lt;strong>局部运行队列被包含在 &lt;code>p&lt;/code> 结构体&lt;/strong>的实例对象之中，每一个运行着 Go 代码的&lt;strong>工作线程都会与一个 &lt;code>p&lt;/code> 结构体的实例对象关联在一起&lt;/strong>。&lt;/p>
&lt;h3>m 结构体（工作线程）&lt;span class="hx-absolute -hx-mt-20" id="m-结构体工作线程">&lt;/span>
&lt;a href="#m-%e7%bb%93%e6%9e%84%e4%bd%93%e5%b7%a5%e4%bd%9c%e7%ba%bf%e7%a8%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;strong>每个工作线程都有唯一的一个 &lt;code>m&lt;/code> 结构体的实例对象与之对应&lt;/strong>，&lt;code>m&lt;/code> 结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的 goroutine 以及是否空闲等等状态信息之外，还通过指针维持着与 &lt;code>p&lt;/code> 结构体的实例对象之间的绑定关系。于是，通过 &lt;code>m&lt;/code> 既可以找到与之对应的工作线程正在运行的 goroutine，又可以找到工作线程的局部运行队列等资源。&lt;/p>
&lt;h3>GPM 模型&lt;span class="hx-absolute -hx-mt-20" id="gpm-模型">&lt;/span>
&lt;a href="#gpm-%e6%a8%a1%e5%9e%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/gpm.png" alt="gpm" style="width:60%;" />
&lt;p>灰色的 &lt;code>g&lt;/code> 表示处于运行队列之中正在等待被调度起来运行的 goroutine。&lt;/p>
&lt;p>&lt;strong>每个 &lt;code>m&lt;/code> 都绑定了一个 &lt;code>p&lt;/code>，每个 &lt;code>p&lt;/code> 都有一个私有的本地 goroutine 队列，&lt;code>m&lt;/code> 对应的线程从本地和全局 goroutine 队列中获取 goroutine 并运行&lt;/strong>。&lt;/p>
&lt;h4>工作线程如何绑定到 m 结构体实例对象&lt;span class="hx-absolute -hx-mt-20" id="工作线程如何绑定到-m-结构体实例对象">&lt;/span>
&lt;a href="#%e5%b7%a5%e4%bd%9c%e7%ba%bf%e7%a8%8b%e5%a6%82%e4%bd%95%e7%bb%91%e5%ae%9a%e5%88%b0-m-%e7%bb%93%e6%9e%84%e4%bd%93%e5%ae%9e%e4%be%8b%e5%af%b9%e8%b1%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>多个工作线程和多个 &lt;code>m&lt;/code> 需要一一对应，如何实现？&lt;strong>线程本地存储&lt;/strong>。线程本地存储其实就是线程私有的全局变量，这正是我们需要的。只要&lt;strong>每个工作线程拥有了各自私有的 &lt;code>m&lt;/code> 结构体全局变量，就能在不同的工作线程中使用相同的全局变量名来访问不同的 &lt;code>m&lt;/code> 结构体对象&lt;/strong>。&lt;/p>
&lt;p>每个&lt;strong>工作线程在刚刚被创建出来进入调度循环之前就利用线程本地存储机制为该工作线程实现了一个指向 &lt;code>m&lt;/code> 结构体实例对象的私有全局变量&lt;/strong>，这样在之后的代码中就&lt;strong>使用该全局变量来访问自己的 &lt;code>m&lt;/code> 结构体对象以及与 &lt;code>m&lt;/code> 相关联的 &lt;code>p&lt;/code> 和 &lt;code>g&lt;/code> 对象&lt;/strong>（工作线程可以直接从本地线程存储取出来 &lt;code>m&lt;/code>）。&lt;/p>
&lt;p>调度伪代码：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 程序启动时的初始化代码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">......&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 创建 N 个操作系统线程执行 schedule 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">create_os_thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">schedule&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 创建一个操作系统线程执行 schedule 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// --------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 线程部分
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 定义一个线程私有全局变量，注意它是一个指向m结构体对象的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ThreadLocal 用来定义线程私有全局变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">ThreadLocal&lt;/span> &lt;span class="nx">self&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// schedule 函数实现调度逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建和初始化 m 结构体对象，并赋值给私有全局变量 self
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">self&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">initm&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 调度循环
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runqueue&lt;/span> &lt;span class="nx">is&lt;/span> &lt;span class="nx">empty&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 本地运行队列为空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 从全局运行队列中找出一个需要运行的 goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">find_a_runnable_goroutine_from_global_runqueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从私有的本地运行队列中找出一个需要运行的 goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">find_a_runnable_goroutine_from_local_runqueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">run_g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// CPU 运行该 goroutine，直到需要调度其它 goroutine 才返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">save_status_of_g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 保存 goroutine 的状态，主要是寄存器的值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>重要的结构体&lt;span class="hx-absolute -hx-mt-20" id="重要的结构体">&lt;/span>
&lt;a href="#%e9%87%8d%e8%a6%81%e7%9a%84%e7%bb%93%e6%9e%84%e4%bd%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>这些结构体的定义全部在 &lt;code>runtime/runtime2.go&lt;/code> 源码文件中：&lt;/p>
&lt;h4>stack 结构体&lt;span class="hx-absolute -hx-mt-20" id="stack-结构体">&lt;/span>
&lt;a href="#stack-%e7%bb%93%e6%9e%84%e4%bd%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>记录 goroutine 所使用的栈的信息，包括栈顶和栈底位置：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Stack describes a Go execution stack.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// The bounds of the stack are exactly [lo, hi),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// with no implicit data structures on either side.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 用于记录 goroutine 使用的栈的起始和结束位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lo&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// 栈顶，低地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">hi&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// 栈底，高地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>为 goroutine 提供&lt;strong>独立的、受保护的栈&lt;/strong>。这是&lt;strong>函数调用基础&lt;/strong>。&lt;/li>
&lt;li>记录当前栈边界，实现按需&lt;strong>动态扩容&lt;/strong>，当栈空间不足时触发扩容（分段栈或连续栈）。&lt;/li>
&lt;li>在 goroutine 被抢占或主动让出时，需要使用 &lt;code>stack&lt;/code> 结构体&lt;strong>保存 goroutine 的栈信息&lt;/strong>，以便在 goroutine 再次被调度起来运行时&lt;strong>恢复栈信息&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h4>gobuf 结构体&lt;span class="hx-absolute -hx-mt-20" id="gobuf-结构体">&lt;/span>
&lt;a href="#gobuf-%e7%bb%93%e6%9e%84%e4%bd%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>用于保存 goroutine 的调度信息，主要包括 CPU 的几个寄存器的值：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">gobuf&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sp&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// 保存 CPU 的 rsp 寄存器的值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">pc&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// 保存 CPU 的 rip 寄存器的值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 记录当前这个 gobuf 对象属于哪个 goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">ctxt&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 保存系统调用的返回值，因为从系统调用返回之后如果 p 被其它工作线程抢占，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 则这个 goroutine 会被放入全局运行队列被其它工作线程调度，其它线程需要知道系统调用的返回值。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">ret&lt;/span> &lt;span class="nx">sys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Uintreg&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lr&lt;/span> &lt;span class="kt">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">bp&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="c1">// for GOEXPERIMENT=framepointer
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>当 goroutine 需要被抢占或主动让出 CPU 时，就需要使用 &lt;code>gobuf&lt;/code> 结构体保存 goroutine 的上下文信息。当 goroutine 再次被调度起来运行时，就需要从 &lt;code>gobuf&lt;/code> 结构体中恢复上下文信息&lt;/strong>。&lt;/p>
&lt;h4>g 结构体&lt;span class="hx-absolute -hx-mt-20" id="g-结构体">&lt;/span>
&lt;a href="#g-%e7%bb%93%e6%9e%84%e4%bd%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>代表一个 goroutine，该结构体保存了 goroutine 的所有信息，包括栈，&lt;code>gobuf&lt;/code> 结构体和其它的一些状态信息：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// goroutine 使用的栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="c1">// offset known to runtime/cgo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 下面两个成员用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到 stackguard0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stackguard0&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// offset known to liblink
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stackguard1&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// offset known to liblink
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_panic&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">_panic&lt;/span> &lt;span class="c1">// innermost panic - offset known to liblink
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">_defer&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">_defer&lt;/span> &lt;span class="c1">// innermost defer
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 当前与 g 绑定的 m
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="c1">// current m; offset known to arm liblink
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 保存调度信息，主要是几个寄存器的值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sched&lt;/span> &lt;span class="nx">gobuf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">syscallsp&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// if status==Gsyscall, syscallsp = sched.sp to use during gc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">syscallpc&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// if status==Gsyscall, syscallpc = sched.pc to use during gc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stktopsp&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// expected sp at top of stack, to check in traceback
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">param&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pointer&lt;/span> &lt;span class="c1">// passed parameter on wakeup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">atomicstatus&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">stackLock&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// sigprof/scang lock; TODO: fold in to atomicstatus
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">goid&lt;/span> &lt;span class="kt">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// schedlink 字段指向全局运行队列中的下一个 g，所有位于全局运行队列中的 g 形成一个链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">schedlink&lt;/span> &lt;span class="nx">guintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// g 被阻塞之后的近似时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">waitsince&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// approx time when the g become blocked
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// g 被阻塞的原因
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">waitreason&lt;/span> &lt;span class="nx">waitReason&lt;/span> &lt;span class="c1">// if status==Gwaiting
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 抢占调度标志，如果需要抢占调度，设置 preempt 为 true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">preempt&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// preemption signal, duplicates
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>m 结构体&lt;span class="hx-absolute -hx-mt-20" id="m-结构体">&lt;/span>
&lt;a href="#m-%e7%bb%93%e6%9e%84%e4%bd%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>代表工作线程，保存了 &lt;code>m&lt;/code> 自身使用的栈信息，当前正在运行的 goroutine 以及与 &lt;code>m&lt;/code> 绑定的 &lt;code>p&lt;/code> 等信息：&lt;/p>
&lt;p>&lt;code>g&lt;/code> 需要调度到 &lt;code>m&lt;/code> 上才能运行，&lt;code>m&lt;/code> 是真正工作的人。&lt;/p>
&lt;p>&lt;strong>当 &lt;code>m&lt;/code> 没有工作可做的时候，在它休眠前，会“自旋”地来找工作：检查全局队列，查看 network poller，试图执行 gc 任务，或者“偷”工作&lt;/strong>。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// g0 主要用来记录工作线程使用的栈信息，在执行调度代码时需要使用这个栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 执行用户 goroutine 代码时，使用用户 goroutine 自己的栈，调度时会发生栈的切换
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">g0&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="c1">// goroutine with scheduling stack
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通过 TLS 实现 m 结构体对象与工作线程之间的绑定
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">tls&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// thread-local storage (for x86 extern register)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mstartfn&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 指向正在运行的 gorutine 对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">curg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="c1">// current running goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">caughtsig&lt;/span> &lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// goroutine running during fatal signal
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 当前工作线程绑定的 p
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="nx">puintptr&lt;/span> &lt;span class="c1">// attached p for executing go code (nil if not executing go code)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nextp&lt;/span> &lt;span class="nx">puintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">oldp&lt;/span> &lt;span class="nx">puintptr&lt;/span> &lt;span class="c1">// the p that was attached before executing a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// spinning 状态：表示当前工作线程正在试图从其它工作线程的本地运行队列偷取goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">spinning&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// m is out of work and is actively looking for work
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// m 正阻塞在 note 上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">blocked&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// m is blocked on a note
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 正在执行 cgo 调用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">incgo&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// m is executing a cgo call
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 没有 goroutine 需要运行时，工作线程睡眠在这个 park 成员上，其它线程通过这个 park 唤醒该工作线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">park&lt;/span> &lt;span class="nx">note&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 记录所有工作线程的一个链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">alllink&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="c1">// on allm
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Linux 平台 thread 的值就是操作系统线程 ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">thread&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// thread handle
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">freelink&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="c1">// on sched.freem
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>p 结构体&lt;span class="hx-absolute -hx-mt-20" id="p-结构体">&lt;/span>
&lt;a href="#p-%e7%bb%93%e6%9e%84%e4%bd%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>&lt;code>p&lt;/code> 是 processor 的意思。&lt;/p>
&lt;p>保存工作线程执行 Go 代码时所必需的资源，比如 goroutine 的运行队列，内存分配用到的缓存等等。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在 allp 中的索引
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">id&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每次调用 schedule 时会加一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">schedtick&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每次系统调用时加一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">syscalltick&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sysmontick&lt;/span> &lt;span class="nx">sysmontick&lt;/span> &lt;span class="c1">// last tick observed by sysmon
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 指向绑定的 m，如果 p 是 idle 的话，那这个指针是 nil
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="nx">muintptr&lt;/span> &lt;span class="c1">// back-link to associated m (nil if idle)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Queue of runnable goroutines. Accessed without lock.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 本地 goroutine 运行队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqhead&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 队列头
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqtail&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// 队列尾
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runq&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">256&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">guintptr&lt;/span> &lt;span class="c1">// 使用数组实现的循环队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// runnext 非空时，代表的是一个 runnable 状态的 G，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这个 G 被当前 G 修改为 ready 状态，相比 runq 中的 G 有更高的优先级。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果当前 G 还有剩余的可用时间，那么就应该运行这个 G
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 运行之后，该 G 会继承当前 G 的剩余时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runnext&lt;/span> &lt;span class="nx">guintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 空闲的 g
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gfree&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>schedt 结构体&lt;span class="hx-absolute -hx-mt-20" id="schedt-结构体">&lt;/span>
&lt;a href="#schedt-%e7%bb%93%e6%9e%84%e4%bd%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>保存调度器的状态信息和 goroutine 的全局运行队列：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">schedt&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 由空闲的工作线程组成链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">midle&lt;/span> &lt;span class="nx">muintptr&lt;/span> &lt;span class="c1">// idle m&amp;#39;s waiting for work
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 空闲的工作线程的数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nmidle&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// number of idle m&amp;#39;s waiting for work
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nmidlelocked&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// number of locked m&amp;#39;s waiting for work
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mnext&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// number of m&amp;#39;s that have been created and next M ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 最多只能创建 maxmcount 个工作线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">maxmcount&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// maximum number of m&amp;#39;s allowed (or die)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nmsys&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// number of system m&amp;#39;s not counted for deadlock
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nmfreed&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// cumulative number of freed m&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ngsys&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// number of system goroutines; updated atomically
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 由空闲的 p 结构体对象组成的链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">pidle&lt;/span> &lt;span class="nx">puintptr&lt;/span> &lt;span class="c1">// idle p&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 空闲的 p 结构体对象的数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">npidle&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nmspinning&lt;/span> &lt;span class="kt">uint32&lt;/span> &lt;span class="c1">// See &amp;#34;Worker thread parking/unparking&amp;#34; comment in proc.go.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Global runnable queue.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// goroutine 全局运行队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runq&lt;/span> &lt;span class="nx">gQueue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">runqsize&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">......&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Global cache of dead G&amp;#39;s.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// gFree 是所有已经退出的 goroutine 对应的 g 结构体对象组成的链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 用于缓存 g 结构体对象，避免每次创建 goroutine 时都重新分配内存
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gFree&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">lock&lt;/span> &lt;span class="nx">mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">stack&lt;/span> &lt;span class="nx">gList&lt;/span> &lt;span class="c1">// Gs with stacks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">noStack&lt;/span> &lt;span class="nx">gList&lt;/span> &lt;span class="c1">// Gs without stacks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">......&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>midle&lt;/code> 由空闲的工作线程组成链表。&lt;/li>
&lt;li>&lt;code>pidle&lt;/code> 由空闲的 p 结构体对象组成的链表。&lt;/li>
&lt;li>&lt;code>gFree&lt;/code> 所有已经退出的 goroutine 对应的 g 结构体对象组成的链表。相当于一个 g 结构体对象的缓存，避免每次创建 goroutine 时都重新分配内存。&lt;/li>
&lt;li>&lt;code>runq&lt;/code> goroutine 全局运行队列。&lt;/li>
&lt;/ul>
&lt;h3>重要的全局变量&lt;span class="hx-absolute -hx-mt-20" id="重要的全局变量">&lt;/span>
&lt;a href="#%e9%87%8d%e8%a6%81%e7%9a%84%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">allgs&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="c1">// 保存所有的 g
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">allm&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="c1">// 所有的 m 构成的一个链表，包括下面的 m0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">allp&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="c1">// 保存所有的 p，len(allp) == gomaxprocs
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ncpu&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// 系统中 cpu 核的数量，程序启动时由 runtime 代码初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">gomaxprocs&lt;/span> &lt;span class="kt">int32&lt;/span> &lt;span class="c1">// p 的最大值，默认等于 ncpu，但可以通过 GOMAXPROCS 修改
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">sched&lt;/span> &lt;span class="nx">schedt&lt;/span> &lt;span class="c1">// 调度器结构体对象，记录了调度器的工作状态
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">m0&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="c1">// 代表进程的主线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">g0&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="c1">// m0 的 g0，也就是 m0.g0 = &amp;amp;g0
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>初始化调度器</title><link>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/02_scheduler_init/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/02_scheduler_init/</guid><description>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello World!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>程序的启动过程：&lt;/p>
&lt;ol>
&lt;li>从磁盘上把可执行程序读入内存；&lt;/li>
&lt;li>创建进程和主线程；&lt;/li>
&lt;li>为主线程分配栈空间；&lt;/li>
&lt;li>把由用户在命令行输入的参数拷贝到主线程的栈；&lt;/li>
&lt;li>把主线程放入操作系统的运行队列等待被调度执起来运行。&lt;/li>
&lt;/ol>
&lt;p>主线程第一次被调度起来执行第一条指令之前，函数栈如下：&lt;/p>
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/main-thread-init-stack.png" alt="main-thread-init-stack" style="width:50%;" />
&lt;h2>程序入口&lt;span class="hx-absolute -hx-mt-20" id="程序入口">&lt;/span>
&lt;a href="#%e7%a8%8b%e5%ba%8f%e5%85%a5%e5%8f%a3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@shcCDFrh75vm7 ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># dlv exec ./hello&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Type &lt;span class="s1">&amp;#39;help&amp;#39;&lt;/span> &lt;span class="k">for&lt;/span> list of commands.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>dlv&lt;span class="o">)&lt;/span> disass
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">TEXT _rt0_amd64_linux&lt;span class="o">(&lt;/span>SB&lt;span class="o">)&lt;/span> /usr/local/go/src/runtime/rt0_linux_amd64.s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">=&lt;/span>&amp;gt; rt0_linux_amd64.s:8 0x463940 e9fbc8ffff jmp &lt;span class="nv">$_rt0_amd64&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>dlv&lt;span class="o">)&lt;/span> si
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; _rt0_amd64&lt;span class="o">()&lt;/span> /usr/local/go/src/runtime/asm_amd64.s:16 &lt;span class="o">(&lt;/span>PC: 0x460240&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Warning: debugging optimized &lt;span class="k">function&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">TEXT _rt0_amd64&lt;span class="o">(&lt;/span>SB&lt;span class="o">)&lt;/span> /usr/local/go/src/runtime/asm_amd64.s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">=&lt;/span>&amp;gt; asm_amd64.s:16 0x460240 488b3c24 mov rdi, qword ptr &lt;span class="o">[&lt;/span>rsp&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> asm_amd64.s:17 0x460244 488d742408 lea rsi, ptr &lt;span class="o">[&lt;/span>rsp+0x8&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> asm_amd64.s:18 0x460249 e912000000 jmp &lt;span class="nv">$runtime&lt;/span>.rt0_go&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>使用 dlv 调试程序可以看到程度的入口早 &lt;code>runtime/rt0_linux_amd64.s&lt;/code> 文件的第 8 行，执行 &lt;code>jmp $_rt0_amd64&lt;/code> 跳转到 &lt;code>runtime/asm_amd64.s&lt;/code> 中的 &lt;code>_rt0_amd64&lt;/code>。&lt;/p>
&lt;p>&lt;code>runtime/asm_amd64.s&lt;/code>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">TEXT&lt;/span> &lt;span class="no">_rt0_amd64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="no">NOSPLIT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="no">$-8&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SP&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">DI&lt;/span> &lt;span class="c1">// argc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">LEAQ&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SP&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">SI&lt;/span> &lt;span class="c1">// argv
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">JMP&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">rt0_go&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>前两行指令把操作系统内核传递过来的参数 &lt;code>argc&lt;/code> 和 &lt;code>argv&lt;/code> 数组的地址分别放在 &lt;code>DI&lt;/code> 和 &lt;code>SI&lt;/code> 寄存器中。第三行指令跳转到 &lt;code>rt0_go&lt;/code> 去执行。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">TEXT&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">rt0_go&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="no">NOSPLIT&lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="no">NOFRAME&lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="no">TOPFRAME&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="no">$0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// copy arguments forward on an even stack
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">DI&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">AX&lt;/span> &lt;span class="c1">// argc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">SI&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">BX&lt;/span> &lt;span class="c1">// argv
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">SUBQ&lt;/span> &lt;span class="no">$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">SP&lt;/span> &lt;span class="c1">// 3args 2auto
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">ANDQ&lt;/span> &lt;span class="no">$&lt;/span>&lt;span class="err">~&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">SP&lt;/span> &lt;span class="c1">// 调整栈顶寄存器使其按 16 字节对齐
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">AX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SP&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// argc 放在 SP + 16字节处
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">BX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">24&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SP&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">//&lt;/span> &lt;span class="no">argv&lt;/span> &lt;span class="err">放在&lt;/span> &lt;span class="no">SP&lt;/span> &lt;span class="err">+&lt;/span> &lt;span class="mi">24&lt;/span>&lt;span class="err">字节处&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>第 4 条指令用于调整栈顶寄存器的值使其按 16 字节对齐，也就是让栈顶寄存器 SP 指向的内存的地址为 16 的倍数，&lt;strong>之所以要按 16 字节对齐，是因为 CPU 有一组 SSE 指令，这些指令中出现的内存地址必须是 16 的倍数&lt;/strong>，最后两条指令把 &lt;code>argc&lt;/code> 和 &lt;code>argv&lt;/code> 搬到新的位置。&lt;/p>
&lt;h2>初始化 g0&lt;span class="hx-absolute -hx-mt-20" id="初始化-g0">&lt;/span>
&lt;a href="#%e5%88%9d%e5%a7%8b%e5%8c%96-g0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>后面的代码，开始初始化全局变量 &lt;code>g0&lt;/code>，&lt;strong>&lt;code>g0&lt;/code> 的主要作用是提供一个栈供 runtime 代码执行&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// create istack out of the given (operating system) stack.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// _cgo_init may update stackguard.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">g0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">DI&lt;/span> &lt;span class="c1">// g0 的地址放入 DI 寄存器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">LEAQ&lt;/span> &lt;span class="p">(-&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="no">SP&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">BX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">BX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">g_stackguard0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">DI&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">BX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">g_stackguard1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">DI&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">BX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">g_stack&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="no">stack_lo&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="no">DI&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">SP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">g_stack&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="no">stack_hi&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="no">DI&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>上面的代码主要是&lt;strong>从系统线程的栈空分出一部分当作 &lt;code>g0&lt;/code> 的栈&lt;/strong>，然后初始化 &lt;code>g0&lt;/code> 的栈信息和 &lt;code>stackgard&lt;/code>。&lt;/p>
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/g0-stack.png" alt="g0-stack" width="380px">
&lt;h2>主线程与 m0 绑定&lt;span class="hx-absolute -hx-mt-20" id="主线程与-m0-绑定">&lt;/span>
&lt;a href="#%e4%b8%bb%e7%ba%bf%e7%a8%8b%e4%b8%8e-m0-%e7%bb%91%e5%ae%9a" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>设置好 &lt;code>g0&lt;/code> 栈之后，跳过 CPU 型号检查以及 cgo 初始化相关的代码，直接从 258 行继续分析。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 初始化 tls (thread local storage, 线程本地存储)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">LEAQ&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">m0&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="no">m_tls&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">DI&lt;/span> &lt;span class="c1">// DI=&amp;amp;m0.tls，取 m0 的 tls 成员的地址到 DI 寄存器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">settls&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 调用 settls 设置线程本地存储，settls 函数的参数在 DI 寄存器中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// store through it, to make sure it works
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 验证 settls 是否可以正常工作，如果有问题则 abort 退出程序
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">get_tls&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$0x123&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">m0&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="no">m_tls&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">AX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">CMPQ&lt;/span> &lt;span class="no">AX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">$0x123&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">JEQ&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">PC&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">abort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>先调用 &lt;strong>&lt;code>settls&lt;/code> 函数初始化主线程的线程本地存储 (TLS)，目的是把 &lt;code>m0&lt;/code> 与主线程关联在一起&lt;/strong>。&lt;/li>
&lt;li>证 TLS 功能是否正常，如果不正常则直接 &lt;code>abort&lt;/code> 退出程序。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>settls&lt;/code> 函数在 &lt;code>runtime/sys_linx_amd64.s&lt;/code> 文件中：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// set tls base to DI
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">TEXT&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">settls&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="no">NOSPLIT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="no">$32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#ifdef GOOS_android
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Android stores the TLS offset in runtime·tls_g.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">SUBQ&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">tls_g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">DI&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// DI 寄存器中存放的是 m.tls[0] 的地址，m 的 tls 成员是一个数组
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 把 DI 寄存器中的地址加 8，存放的就是 m.tls[1] 的地址了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">ADDQ&lt;/span> &lt;span class="no">$8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">DI&lt;/span> &lt;span class="c1">// ELF wants to use -8(FS)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">DI&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">SI&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$0x1002&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">DI&lt;/span> &lt;span class="c1">// ARCH_SET_FS
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$SYS_arch_prctl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">AX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">SYSCALL&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">CMPQ&lt;/span> &lt;span class="no">AX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">$0xfffffffffffff001&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">JLS&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">PC&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVL&lt;/span> &lt;span class="no">$0xf1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0xf1&lt;/span> &lt;span class="c1">// crash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">RET&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>上面的 &lt;code>arch_prctl&lt;/code> 系统调用把 &lt;code>m0.tls[1]&lt;/code> 的地址设置成了 &lt;code>fs&lt;/code> 段的段基址。CPU 中有个叫 &lt;code>fs&lt;/code> 的段寄存器。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>这样通过 &lt;code>m0.tls[1]&lt;/code> 就可以访问到线程的 TLS 区域了&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>工作线程代码也可以通过 fs 寄存器来找到 &lt;code>m.tls&lt;/code>&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>CPU 的 FS 寄存器主要用于线程本地存储（TLS），用于在每个线程中快速访问“当前线程的本地数据”。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>rt0_go&lt;/code> 下面的代码会&lt;strong>把 g0 的地址也放入主线程的线程本地存储中&lt;/strong>，然后通过：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">m0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g0&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">g0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">g0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>把 &lt;code>m0&lt;/code> 和 &lt;code>g0&lt;/code> 绑定在一起，&lt;/p>
&lt;ul>
&lt;li>之后在主线程中通过 &lt;code>get_tls&lt;/code> 可以获取到 &lt;code>g0&lt;/code>。&lt;/li>
&lt;li>通过 &lt;code>g0&lt;/code> 的 &lt;code>m&lt;/code> 成员又可以找到 &lt;code>m0&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>于是这里就实现了 &lt;code>m0&lt;/code> 和 &lt;code>g0&lt;/code> 与主线程之间的关联。&lt;/p>
&lt;h2>初始化 m0&lt;span class="hx-absolute -hx-mt-20" id="初始化-m0">&lt;/span>
&lt;a href="#%e5%88%9d%e5%a7%8b%e5%8c%96-m0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>运行时通过 &lt;a href="https://github.com/golang/go/blob/6796ebb2cb66b316a07998cdcd69b1c486b8579e/src/runtime/proc.go#L798" target="_blank" rel="noopener">runtime.schedinit&lt;/a> 初始化调度器：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">schedinit&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// getg 函数在源代码中没有对应的定义，由编译器插入类似下面两行代码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// get_tls(CX)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// MOVQ g(CX), BX;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// BX 存器里面现在放的是当前 g 结构体对象的地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">maxmcount&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">10000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mcommoninit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lastpoll&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">uint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">nanotime&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">procs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ncpu&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">atoi32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">gogetenv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;GOMAXPROCS&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">procs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nf">procresize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">procs&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">throw&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unknown runnable goroutine during bootstrap&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>&lt;code>g0&lt;/code> 的地址已经被设置到了线程本地存储之中，通过 &lt;code>getg&lt;/code> 函数（&lt;code>getg&lt;/code> 函数是编译器实现的，源代码中是找不到其定义）&lt;strong>从线程本地存储中获取当前正在运行的 &lt;code>g&lt;/code>&lt;/strong>。&lt;/li>
&lt;li>&lt;code>mcommoninit&lt;/code> 对 &lt;code>m0&lt;/code> 进行必要的初始化。&lt;/li>
&lt;li>调用 &lt;code>procresize&lt;/code> 初始化系统需要用到的 &lt;code>p&lt;/code> 结构体对象。它的数量决定了最多可以有都少个 goroutine 同时并行运行。&lt;/li>
&lt;li>&lt;code>sched.maxmcount = 10000&lt;/code> 一个 Go 程序最多可以创建 10000 个线程。&lt;/li>
&lt;li>线程数可以通过 &lt;code>GOMAXPROCS&lt;/code> 变量控制。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://github.com/golang/go/blob/6796ebb2cb66b316a07998cdcd69b1c486b8579e/src/runtime/proc.go#L942" target="_blank" rel="noopener">&lt;code>mcommoninit&lt;/code>&lt;/a> 初始化 &lt;code>m0&lt;/code>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">mcommoninit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">id&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 初始化过程中 gp = g0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// g0 stack won&amp;#39;t make sense for user (and is not necessary unwindable).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g0&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 函数调用栈 traceback，不需要关心
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">callers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createstack&lt;/span>&lt;span class="p">[:])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">id&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">id&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">id&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">mReserveID&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// random 初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mrandinit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建用于信号处理的 gsignal，只是简单的从堆上分配一个 g 结构体对象,然后把栈设置好就返回了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mpreinit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gsignal&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gsignal&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stackguard1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gsignal&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lo&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">stackGuard&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Add to allm so garbage collector doesn&amp;#39;t free g-&amp;gt;m
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// when it is just in a register or thread-local storage.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 把 m0 加入到 allm 全局链表中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">alllink&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">allm&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// NumCgoCall() and others iterate over allm w/o schedlock,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// so we need to publish it safely.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">atomicstorep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">allm&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Allocate memory to hold a cgo traceback if the cgo call crashes.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">iscgo&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">GOOS&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;solaris&amp;#34;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">GOOS&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;illumos&amp;#34;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">GOOS&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;windows&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cgoCallers&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">cgoCallers&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mProfStackInit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>这里并未对 &lt;code>m0&lt;/code> 做什么关于调度相关的初始化，可以简单的认为这个函数只是把 &lt;code>m0&lt;/code> 放入全局链表 &lt;code>allm&lt;/code> 之中就返回了。&lt;/p>
&lt;h2>初始化 allp&lt;span class="hx-absolute -hx-mt-20" id="初始化-allp">&lt;/span>
&lt;a href="#%e5%88%9d%e5%a7%8b%e5%8c%96-allp" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">procresize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nprocs&lt;/span> &lt;span class="kt">int32&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 系统初始化时 gomaxprocs = 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">old&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">gomaxprocs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Grow allp if necessary.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">nprocs&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nb">int32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">allp&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 初始化时 len(allp) == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Synchronize with retake, which could be running
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// concurrently since it doesn&amp;#39;t run on a P.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">allpLock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">nprocs&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="nb">int32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">allp&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">allp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">allp&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nx">nprocs&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 初始化时进入此分支，创建 allp 切片
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nallp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">nprocs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Copy everything up to allp&amp;#39;s cap so we
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// never lose old allocated Ps.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nallp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">allp&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">allp&lt;/span>&lt;span class="p">)])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">allp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">nallp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">allpLock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// initialize new P&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 循环创建 nprocs 个 p 并完成基本初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">old&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">nprocs&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">allp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">pp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 调用内存分配器从堆上分配一个 struct p
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">atomicstorep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">allp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]),&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">id&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">nprocs&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 初始化时 m0-&amp;gt;p 还未初始化，所以不会执行这个分支
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// continue to use the current P
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">status&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">_Prunning&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">mcache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">prepareForSweep&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 初始化时执行这个分支
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// release the current P and acquire allp[0].
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// We must do this before destroying our current P
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// because p.destroy itself has write barriers, so we
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// need to do that from a valid P.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 初始化时这里不执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">trace&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">traceAcquire&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">trace&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ok&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Pretend that we were descheduled
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// and then scheduled again to keep
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// the trace consistent.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">trace&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GoSched&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">trace&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ProcStop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">traceRelease&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">trace&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">allp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">status&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">_Pidle&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">acquirep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 把 p 和 m0 关联起来，其实是这两个 strct 的成员相互赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">trace&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">traceAcquire&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">trace&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ok&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">trace&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GoStart&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">traceRelease&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">trace&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mcache0&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 循环把所有空闲的 p 放入空闲链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">runnablePs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">nprocs&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">allp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">pp&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// allp[0] 跟 m0 关联了，所以是不能放到空闲链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">status&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">_Pidle&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nf">runqempty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 初始化时除了 allp[0] 其它 p 全部执行这个分支，放入空闲链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">pidleput&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">now&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>使用 &lt;code>make([]*p, nprocs)&lt;/code> 初始化全局变量 &lt;code>allp&lt;/code>，即 &lt;code>allp = make([]*p, nprocs)&lt;/code>；&lt;/li>
&lt;li>循环创建并初始化 &lt;code>nprocs&lt;/code> 个 &lt;code>p&lt;/code> 结构体对象并依次保存在 &lt;code>allp&lt;/code> 切片之中；&lt;/li>
&lt;li>把 &lt;code>m0&lt;/code> 和 &lt;code>allp[0]&lt;/code> 绑定在一起，即 &lt;code>m0.p = allp[0]&lt;/code>, &lt;code>allp[0].m = m0&lt;/code>；&lt;/li>
&lt;li>把除了 &lt;code>allp[0]&lt;/code> 之外的所有 &lt;code>p&lt;/code> 放入到全局变量 &lt;code>sched&lt;/code> 的 &lt;code>pidle&lt;/code> 空闲队列之中。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>procresize&lt;/code> 函数执行完后，调度器相关的初始化工作就基本结束了。&lt;/p></description></item><item><title>初始化 main goroutine</title><link>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/03_main_g/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/03_main_g/</guid><description>
&lt;h2>创建 main goroutine&lt;span class="hx-absolute -hx-mt-20" id="创建-main-goroutine">&lt;/span>
&lt;a href="#%e5%88%9b%e5%bb%ba-main-goroutine" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>schedinit&lt;/code> 完成调度系统初始化后，返回到 &lt;code>rt0_go&lt;/code> 函数中开始调用 &lt;code>newproc()&lt;/code> 创建一个新的 goroutine 用于执行 mainPC 所对应的 &lt;code>runtime·main&lt;/code> 函数。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">schedinit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// create a new goroutine to start program
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">mainPC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">AX&lt;/span> &lt;span class="c1">// entry
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">PUSHQ&lt;/span> &lt;span class="no">AX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">newproc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">POPQ&lt;/span> &lt;span class="no">AX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// start this M
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">mstart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">abort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// mstart should never return
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">RET&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>另外 &lt;code>go&lt;/code> 关键字启动一个 goroutine 时，最终也会被编译器转换成 &lt;code>newproc&lt;/code> 函数。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">newproc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fn&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">funcval&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 函数调用参数入栈顺序是从右向左，而且栈是从高地址向低地址增长的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pc&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetCallerPC&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">systemstack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newg&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">newproc1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">waitReasonZero&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">runqput&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">newg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">mainStarted&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">wakep&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>&lt;code>newproc1&lt;/code> 函数的第一个参数 &lt;code>fn&lt;/code> 是新创建的 goroutine 需要执行的函数；&lt;/li>
&lt;li>&lt;code>newproc1&lt;/code> 根据传入参数初始化一个 &lt;code>g&lt;/code> 结构体。&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">newproc1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fn&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">funcval&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">callergp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">callerpc&lt;/span> &lt;span class="kt">uintptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">parked&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">waitreason&lt;/span> &lt;span class="nx">waitReason&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">acquirem&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// disable preemption because we hold M and P in local vars.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">pp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newg&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">gfget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 从 p 的本地缓冲里获取一个没有使用的 g，初始化时没有，返回nil
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">newg&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// new 一个 g 结构体对象，然后从堆上为其分配栈，并设置 g 的 stack 成员和两个 stackgard 成员
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">newg&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">malg&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_StackMin&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">casgstatus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">newg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Gidle&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Gdead&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 初始化 g 的状态为 _Gdead
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">allgadd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">newg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 放入全局变量 allgs 切片中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 把 newg.sched 结构体成员的所有成员设置为 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">memclrNoHeapPointers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">newg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">newg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 设置 newg 的 sched 成员，调度器需要依靠这些字段才能把 goroutine 调度到 CPU 上运行。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">newg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">sp&lt;/span> &lt;span class="c1">// newg 的栈顶
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">newg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stktopsp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">sp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// newg.sched.pc 表示当 newg 被调度起来运行时从这个地址开始执行指令
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 把 pc 设置成了 goexit 这个函数偏移 1（sys.PCQuantum 等于 1）的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">newg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pc&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">funcPC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">goexit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">sys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PCQuantum&lt;/span> &lt;span class="c1">// +PCQuantum so that previous instruction is in same function
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">newg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">guintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">newg&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">gostartcallfn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">newg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fn&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 调整 sched 成员和 newg 的栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>runtime.gfget&lt;/code> 中包含两部分逻辑，它会根据处理器中 &lt;code>gFree&lt;/code> 列表中 goroutine 的数量做出不同的决策：&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>p&lt;/code> 的 &lt;code>gfree&lt;/code> 数量充足时，会从列表头部返回一个 goroutine；&lt;/li>
&lt;li>当 &lt;code>p&lt;/code> 的 &lt;code>gfree&lt;/code> 列表为空时，会将调度器持有的空闲 goroutine 转移到当前 &lt;code>p&lt;/code> 上，直到 &lt;code>gfree&lt;/code> 列表中的 goroutine 数量达到 32；&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">gfget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">retry&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">(!&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">noStack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Move a batch of free Gs to the P.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">32&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Prefer Gs with stacks.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">noStack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">goto&lt;/span> &lt;span class="nx">retry&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">gFree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>当 &lt;code>p&lt;/code> 的 &lt;code>gfree&lt;/code> 和调度器的 &lt;code>gFree&lt;/code> 列表都不存在结构体时，调用 &lt;code>runtime.malg&lt;/code> 初始化新的 &lt;code>g&lt;/code>&lt;/strong>。&lt;/p>
&lt;p>拿到 &lt;code>g&lt;/code> 之后，调用 &lt;code>runtime.runqput&lt;/code> 会将 goroutine 放到运行队列 &lt;code>runq&lt;/code> 上，这既可能是全局的运行队列，也可能是 &lt;code>p&lt;/code> 本地的运行队列：&lt;/p>
&lt;ol>
&lt;li>当 &lt;code>next&lt;/code> 为 &lt;code>true&lt;/code> 时，将 goroutine 设置到处理器的 &lt;code>runnext &lt;/code>作为下一个处理器执行的任务；&lt;/li>
&lt;li>当 &lt;code>next&lt;/code> 为 &lt;code>false&lt;/code> 并且本地运行队列还有剩余空间时，将 goroutine 加入处理器持有的本地运行队列；&lt;/li>
&lt;li>当 &lt;code>p&lt;/code> 的&lt;strong>本地运行队列已经没有剩余空间时就会把本地队列中的一部分 goroutine 和待加入的 goroutine 通过 &lt;code>runtime.runqputslow&lt;/code> 添加到调度器持有的全局运行队列上&lt;/strong>；&lt;/li>
&lt;/ol>
&lt;h2>从 g0 切换到 main goroutine&lt;span class="hx-absolute -hx-mt-20" id="从-g0-切换到-main-goroutine">&lt;/span>
&lt;a href="#%e4%bb%8e-g0-%e5%88%87%e6%8d%a2%e5%88%b0-main-goroutine" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>从 &lt;code>newproc&lt;/code> 继续往下执行 &lt;code>mstart0&lt;/code>，继续调用 &lt;code>mstart1&lt;/code> 函数：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">mstart0&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// gp = g0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 对于启动过程来说，g0 的 stack.lo 早已完成初始化，所以 onStack = false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">osStack&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lo&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">osStack&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Initialize stack bounds from system stack.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Cgo may have left stack size in stack.hi.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// minit may update the stack bounds.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Note: these bounds may not be very accurate.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// We set hi to &amp;amp;size, but there are things above
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// it. The 1024 is supposed to compensate this,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// but is somewhat arbitrary.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">hi&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">size&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">16384&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">sys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StackGuardMultiplier&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">hi&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">noescape&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">size&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lo&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">hi&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1024&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Initialize stack guard so that we can start calling regular
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Go code.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stackguard0&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lo&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">stackGuard&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// This is the g0, so we can also call go:systemstack
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// functions, which check stackguard1.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stackguard1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stackguard0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mstart1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Exit this thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nf">mStackIsSystemAllocated&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// the stack, but put it in gp.stack before mstart,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// so the logic above hasn&amp;#39;t set osStack yet.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">osStack&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mexit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">osStack&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">mstart1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// gp = g0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">throw&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;bad runtime·mstart&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Set up m.g0.sched as a label returning to just
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// We&amp;#39;re never coming back to mstart1 after we call schedule,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// so other calls can reuse the current frame.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// And goexit0 does a gogo that needs to return from mstart1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// and let mstart0 exit the thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">guintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pc&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">sys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetCallerPC&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 获取 mstart1 执行完的返回地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">sys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetCallerSP&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 获取调用 mstart1 时的栈顶地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">asminit&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 在 AMD64 Linux 平台中，这个函数什么也没做，是个空函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">minit&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Install signal handlers; after minit so that minit can
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// prepare the thread to be able to handle the signals.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m0&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//启动时 gp.m 是 m0，所以会执行下面的 mstartm0 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">mstartm0&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">debug&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">dataindependenttiming&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EnableDIT&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">fn&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mstartfn&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">fn&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 初始化过程中 fn == nil
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">fn&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m0&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// m0 已经绑定了 allp[0]，如果不是 m0 的话，这时还没有 p，所以需要获取一个 p
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">acquirep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nextp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nextp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// schedule 函数永远不会返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>&lt;code>mstart1&lt;/code> 函数先保存 &lt;code>g0&lt;/code> 的调度信息。&lt;/li>
&lt;li>&lt;code>GetCallerPC()&lt;/code> 返回的是 &lt;code>mstart0&lt;/code> 调用 &lt;code>mstart1&lt;/code> 时被 &lt;code>call&lt;/code> 指令压栈的返回地址。&lt;/li>
&lt;li>&lt;code>GetCallerSP()&lt;/code> 函数返回的是调用 &lt;code>mstart1&lt;/code> 函数之前 &lt;code>mstart0&lt;/code> 函数的栈顶地址。&lt;/li>
&lt;/ol>
&lt;p>所以 &lt;strong>&lt;code>mstart1&lt;/code> 最主要做的就是保存当前正在运行的 &lt;code>g&lt;/code> 的下一条指令的地址和栈顶地址&lt;/strong>。&lt;/p>
&lt;p>不管是对 &lt;code>g0&lt;/code> 还是其它 &lt;code>goroutine&lt;/code> 来说这些信息在调度过程中都是必不可少的。&lt;/p>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">&lt;p>上面的 &lt;code>mstart1&lt;/code> 函数中：&lt;/p>
&lt;ul>
&lt;li>&lt;code>g0.sched.pc&lt;/code> 指向的是 &lt;code>mstart0&lt;/code> 函数中调用 &lt;code>mstart1&lt;/code> 函数之后下一个指令（也就是 &lt;code>if mStackIsSystemAllocated()&lt;/code> 语句）的地址。&lt;/li>
&lt;/ul>
&lt;p>从 &lt;code>mstart0&lt;/code> 函数可以看到，&lt;code>if mStackIsSystemAllocated()&lt;/code> 语句之后就要退出线程了。为什么要这么做？&lt;/p>
&lt;p>原因就在核心函数 &lt;code>schedule&lt;/code>。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="c1">// getg().m = g0.m, 初始化时 g0.m = m0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从本地运行队列和全局运行队列寻找需要运行的 goroutine，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 为了保证调度的公平性，每进行 61 次调度就需要优先从全局运行队列中获取 goroutine，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 因为如果只调度本地队列中的 g，那么全局运行队列中的 goroutine 将得不到运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果本地运行队列和全局运行队没有则从其它工作线程的运行队列中偷取，如果偷取不到，则当前工作线程进入睡眠，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 直到获取到需要运行的 goroutine 之后 findrunnable 函数才会返回。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">tryWakeP&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">findRunnable&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// blocks until work is available
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 当前运行的是 runtime 的代码，函数调用栈使用的是 g0 的栈空间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 调用 execte 切换到 gp 的代码和栈空间去运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="c1">// getg().m = g0.m, 初始化时 g0.m = m0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">goroutineProfile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">active&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Make sure that gp has had its stack written out to the goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// profile, exactly as it was when the goroutine profiler first stopped
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// the world.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">tryRecordGoroutineProfile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">osyield&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Assign gp.m before entering _Grunning so running Gs have an
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// M.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 把待运行 g 和 m 关联起来
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">curg&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">gp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">mp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 先设置待运行 g 的状态为 _Grunning
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">casgstatus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Grunnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Grunning&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// gogo 完成从 g0 到 gp 真正的切换
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">gogo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>&lt;code>execute&lt;/code> 函数的第一个参数 &lt;code>gp&lt;/code> 即是需要调度起来运行的 goroutine，这里首先把 &lt;code>gp&lt;/code> 的状态从 &lt;code>_Grunnable&lt;/code> 修改为 &lt;code>_Grunning&lt;/code>&lt;/li>
&lt;li>然后把 &lt;code>gp&lt;/code> 和 &lt;code>m&lt;/code> 关联起来，这样通过 &lt;code>m&lt;/code> 就可以找到当前工作线程正在执行哪个 goroutine，反之亦然。&lt;/li>
&lt;li>调用 &lt;code>gogo&lt;/code> 函数完成从 &lt;code>g0&lt;/code> 到 &lt;code>gp&lt;/code> 的的切换。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>gogo&lt;/code> 函数是通过汇编语言编写的：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">TEXT&lt;/span> &lt;span class="no">gogo&lt;/span>&lt;span class="err">&amp;lt;&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">NOSPLIT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">$0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">get_tls&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">CX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 把要运行的 g 的指针放入线程本地存储，这样后面的代码就可以通过线程本地存储
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 获取到当前正在执行的 goroutine 的 g 结构体对象，从而找到与之关联的 m 和 p
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">DX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">CX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">DX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">R14&lt;/span> &lt;span class="c1">// set the g register
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 把 CPU 的 SP 寄存器设置为 sched.sp，完成了栈的切换
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">gobuf_sp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">SP&lt;/span> &lt;span class="c1">// restore SP
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 恢复调度上下文到 CPU 相关寄存器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">gobuf_ret&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">AX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">gobuf_ctxt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">DX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">gobuf_bp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">BP&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 清空 sched 的值，因为我们已把相关值放入 CPU 对应的寄存器了，不再需要，这样做可以少 gc 的工作量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">gobuf_sp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// clear to help garbage collector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">gobuf_ret&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">gobuf_ctxt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">$0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">gobuf_bp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 把 sched.pc 值放入 BX 寄存器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">MOVQ&lt;/span> &lt;span class="no">gobuf_pc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">BX&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="no">BX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// JMP 把 BX 寄存器的包含的地址值放入 CPU 的 IP 寄存器，于是，CPU 跳转到该地址继续执行指令
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">JMP&lt;/span> &lt;span class="no">BX&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>gogo&lt;/code> 函数就只做了两件事：&lt;/p>
&lt;ol>
&lt;li>把 &lt;code>gp.sched&lt;/code> 的成员恢复到 CPU 的寄存器完成状态以及栈的切换；&lt;/li>
&lt;li>跳转到 &lt;code>gp.sched.pc&lt;/code> 所指的指令地址（&lt;code>runtime.main&lt;/code>）处执行。&lt;/li>
&lt;/ol>
&lt;p>现在已经从 &lt;code>g0&lt;/code> 切换到了 &lt;code>gp&lt;/code> 这个 goroutine（main goroutine），它的入口函数是 &lt;code>runtime.main&lt;/code>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// The main goroutine.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="c1">// g = main goroutine，不再是 g0 了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Racectx of m0-&amp;gt;g0 is used only as the parent of the main goroutine.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// It must not be used for anything else.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">racectx&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Using decimal instead of binary GB and MB because
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// they look nicer in the stack overflow failure message.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">goarch&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PtrSize&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 64 位系统上每个 goroutine 的栈最大可达 1G，也就是说 gorputine 的栈虽然可以自动扩展，但它并不是无限扩展的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">maxstacksize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1000000000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">maxstacksize&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">250000000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// An upper limit for max stack size. Used to avoid random crashes
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// after calling SetMaxStack and trying to allocate a stack that is too big,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// since stackalloc works with 32-bit sizes.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">maxstackceiling&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">maxstacksize&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Allow newproc to start new Ms.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mainStarted&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">haveSysmon&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 现在执行的是 main goroutine，所以使用的是 main goroutine 的栈，需要切换到 g0 栈去执行 newm()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">systemstack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">newm&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sysmon&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">gcenable&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 开启垃圾回收器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// main 包的初始化函数，也是由编译器实现，会递归的调用 import 进来的包的初始化函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">firstmoduledata&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">m&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">next&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">doInit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">inittasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 调用 main.main 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fn&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">main_main&lt;/span> &lt;span class="c1">// make an indirect call, as the linker doesn&amp;#39;t know the address of the main package when laying down the runtime
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">fn&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 进入系统调用，退出进程，可以看出 main goroutine 并未返回，而是直接进入系统调用退出进程了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 保护性代码，如果 exit 意外返回，下面的代码也会让该进程 crash 死掉
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>启动一个 sysmon 系统监控线程，该线程负责整个程序的 gc、抢占调度以及 netpoll 等功能的监控。&lt;/li>
&lt;li>执行 runtime 包的初始化；&lt;/li>
&lt;li>执行 main 包以及 main 包 import 的所有包的初始化；&lt;/li>
&lt;li>执行 &lt;code>main.main&lt;/code> 函数；&lt;/li>
&lt;li>从 &lt;code>main.main&lt;/code> 函数返回后调用 &lt;code>exit&lt;/code> 系统调用退出进程；&lt;/li>
&lt;/ol>
&lt;h3>goexit 函数&lt;span class="hx-absolute -hx-mt-20" id="goexit-函数">&lt;/span>
&lt;a href="#goexit-%e5%87%bd%e6%95%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>main goroutine 调用 exit 直接退出进程了！！&lt;/p>
&lt;p>&lt;code>runtime.main&lt;/code> 是 main goroutine 的入口函数，是在 &lt;code>schedule()-&amp;gt; execute()-&amp;gt; gogo()&lt;/code> 这个调用链的 &lt;code>gogo&lt;/code> 函数中用汇编代码直接跳转过来的，而且运行完后会直接退出。&lt;/p>
&lt;p>goexit 函数为什么没有调用？&lt;/p>
&lt;p>但是在 &lt;strong>&lt;code>newproc1&lt;/code> 创建 goroutine 的时候已经在其栈上放好了一个返回地址，伪造成 &lt;code>goexit&lt;/code> 函数调用了 goroutine 的入口函数，这里怎么没有用到这个返回地址啊？&lt;/strong>&lt;/p>
&lt;p>&lt;code>newproc1&lt;/code> 函数部分插入 goexit：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="s">`newg.sched.pc = funcPC(goexit) + sys.PCQuantum`&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>因为那是为非 main goroutine 准备的，&lt;strong>非 main goroutine 执行完成后就会返回到 &lt;code>goexit&lt;/code> 继续执行&lt;/strong>，而 main goroutine 执行完成后整个进程就结束了。&lt;/p>
&lt;h2>流程图&lt;span class="hx-absolute -hx-mt-20" id="流程图">&lt;/span>
&lt;a href="#%e6%b5%81%e7%a8%8b%e5%9b%be" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;div class="img-zoom lg">
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/go/go-main-run-flow.png" alt=go-main-run-flow">
&lt;/div></description></item><item><title>调度循环</title><link>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/04_loop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/scheduler/04_loop/</guid><description>
&lt;h2>非 main goroutine 的退出&lt;span class="hx-absolute -hx-mt-20" id="非-main-goroutine-的退出">&lt;/span>
&lt;a href="#%e9%9d%9e-main-goroutine-%e7%9a%84%e9%80%80%e5%87%ba" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>newproc1&lt;/code> 创建 goroutine 的时候已经在其栈上放好了一个返回地址，伪造成 &lt;code>goexit&lt;/code> 函数调用了 goroutine 的入口函数。&lt;strong>非 main goroutine 执行完成后就会返回到 &lt;code>goexit&lt;/code> 继续执行&lt;/strong>。&lt;/p>
&lt;p>&lt;code>goexit&lt;/code> 函数在 &lt;code>runtime/asm_amd64.s&lt;/code> 文件中：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">TEXT&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">goexit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="no">NOSPLIT&lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="no">TOPFRAME&lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="no">NOFRAME&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="no">$0-0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">BYTE&lt;/span> &lt;span class="no">$0x90&lt;/span> &lt;span class="c1">// NOP
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">goexit1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// does not return
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// traceback from goexit1 must hit code range of goexit
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">BYTE&lt;/span> &lt;span class="no">$0x90&lt;/span> &lt;span class="err">//&lt;/span> &lt;span class="no">NOP&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>CALL runtime·goexit1(SB)&lt;/code> 继续调用 &lt;code>goexit1&lt;/code> 函数，&lt;code>goexit1&lt;/code> 函数又调用 &lt;code>mcall(goexit0)&lt;/code>。&lt;/p>
&lt;p>&lt;strong>&lt;code>mcall&lt;/code> 做的事情跟 &lt;code>gogo&lt;/code> 函数完全相反。&lt;code>gogo&lt;/code> 函数实现了从 &lt;code>g0&lt;/code> 切换到某个 goroutine 去运行，而 &lt;code>mcall&lt;/code> 实现了从某个 goroutine 切换到 &lt;code>g0&lt;/code> 来运行&lt;/strong>。&lt;/p>
&lt;p>切换到 &lt;code>g0&lt;/code> 栈之后，下面开始在 &lt;code>g0&lt;/code> 栈执行 &lt;code>goexit0&lt;/code> 函数，该函数完成最后的清理工作：&lt;/p>
&lt;ol>
&lt;li>把 &lt;code>g&lt;/code> 的状态从 &lt;code>_Grunning&lt;/code> 变更为 &lt;code>_Gdead&lt;/code>；&lt;/li>
&lt;li>然后把 &lt;code>g&lt;/code> 的一些字段清空成 0 值；&lt;/li>
&lt;li>调用 &lt;code>dropg&lt;/code> 函数解除 &lt;code>g&lt;/code> 和 &lt;code>m&lt;/code> 之间的关系，其实就是设置 &lt;code>g-&amp;gt;m = nil, m-&amp;gt;currg = nil&lt;/code>；&lt;/li>
&lt;li>把 &lt;code>g&lt;/code> 放入 &lt;code>p&lt;/code> 的 &lt;code>freeg&lt;/code> 队列缓存起来供下次创建 &lt;code>g&lt;/code> 时快速获取而不用从内存分配。&lt;code>freeg&lt;/code> 就是 &lt;code>g&lt;/code> 的一个对象池；&lt;/li>
&lt;li>&lt;strong>调用 &lt;code>schedule&lt;/code> 函数再次进行调度&lt;/strong>；&lt;/li>
&lt;/ol>
&lt;p>工作线程再次调用了 &lt;code>schedule&lt;/code> 函数进入新一轮的调度循环。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">goexit0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">gdestroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>调用链：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>schedule() -&amp;gt; execute() -&amp;gt; gogo() -&amp;gt; g2() -&amp;gt; goexit() -&amp;gt; goexit1() -&amp;gt; mcall() -&amp;gt; goexit0() -&amp;gt; schedule()&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>调度策略&lt;span class="hx-absolute -hx-mt-20" id="调度策略">&lt;/span>
&lt;a href="#%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>从全局运行队列中寻找 goroutine。为了保证调度的公平性，每个工作线程每经过 61 次调度就需要优先尝试从全局运行队列中找出一个 goroutine 来运行，这样才能保证位于全局运行队列中的 goroutine 得到调度的机会。全局运行队列是所有工作线程都可以访问的，所以在访问它之前需要加锁。&lt;/li>
&lt;li>从工作线程本地运行队列中寻找 goroutine。如果不需要或不能从全局运行队列中获取到 goroutine 则从本地运行队列中获取。&lt;/li>
&lt;li>尝试通过 netpoll 快速获取 I/O 就绪任务&lt;/li>
&lt;li>从其它工作线程的运行队列中偷取 goroutine。如果上一步也没有找到需要运行的 goroutine，则从其他工作线程的运行队列中偷取 goroutine，在偷取之前会再次尝试从全局运行队列和当前线程的本地运行队列中查找需要运行的 goroutine。&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">findRunnable&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">tryWakeP&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">m&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Check the global runnable queue once in a while to ensure fairness.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Otherwise two goroutines can completely occupy the local runqueue
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// by constantly respawning each other.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 为了保证调度的公平性，每进行 61 次调度就需要优先从全局运行队列中获取 goroutine，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 因为如果只调度本地队列中的 g，那么全局运行队列中的 goroutine 将得不到运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">pp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">schedtick&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="mi">61&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runqsize&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 所有工作线程都能访问全局运行队列，所以需要加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">globrunqget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// local runq
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 从与 m 关联的 p 的本地运行队列中获取 goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">runqget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// global runq
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 从全局运行队列中获取 goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runqsize&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">globrunqget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Poll network.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// This netpoll is only an optimization before we resort to stealing.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// We can safely skip it if there are no waiters or a thread is blocked
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// in netpoll already. If there is any kind of logical race with that
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// blocked thread (e.g. it has already returned from netpoll, but does
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// not set lastpoll yet), this thread will do blocking netpoll below
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// anyway.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这里是在偷取 goroutine 之前的额一个优化。尝试通过 netpoll 快速获取 I/O 就绪任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果系统中已经有线程在处理 netpoll，就可以跳过这一步
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nf">netpollinited&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nf">netpollAnyWaiters&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lastpoll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Steal work from other P&amp;#39;s.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// If number of spinning M&amp;#39;s &amp;gt;= number of busy P&amp;#39;s, block.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// This is necessary to prevent excessive CPU consumption
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// when GOMAXPROCS&amp;gt;&amp;gt;1 but the program parallelism is low.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这个判断主要是为了防止因为寻找可运行的 goroutine 而消耗太多的 CPU。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 因为已经有足够多的工作线程正在寻找可运行的 goroutine，让他们去找就好了，自己偷个懒去睡觉
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">spinning&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nmspinning&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">gomaxprocs&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">npidle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">spinning&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">becomeSpinning&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 设置 m 的状态为 spinning
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">tnow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">newWork&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">stealWork&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">now&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 从其它 p 的本地运行队列盗取 goroutine
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>对于多个线程同时窃取同一个 P 的本地队列的情况，只有一个线程能窃取成功，其他线程只能继续从全局队列或者当前线程的本地队列中查找。&lt;/p>
&lt;p>这里使用的 &lt;code>for&lt;/code> 循环加原子操作 CAS （&lt;code>atomic.CasRel&lt;/code>）来保证只有一个线程能窃取成功。&lt;code>atomic.CasRel(&amp;amp;pp.runqhead, h, h+n)&lt;/code> 中 &lt;code>runqhead&lt;/code> 是本地丢列的头指针。&lt;/p>
&lt;h2>调度时机&lt;span class="hx-absolute -hx-mt-20" id="调度时机">&lt;/span>
&lt;a href="#%e8%b0%83%e5%ba%a6%e6%97%b6%e6%9c%ba" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>触发调度的几个路径：&lt;/p>
&lt;ul>
&lt;li>主动挂起 — &lt;code>runtime.gopark&lt;/code> -&amp;gt; &lt;code>runtime.park_m&lt;/code>。&lt;/li>
&lt;li>系统调用 — &lt;code>runtime.exitsyscall&lt;/code> -&amp;gt; &lt;code>runtime.exitsyscall0&lt;/code>。&lt;/li>
&lt;li>协作式调度 — &lt;code>runtime.Gosched&lt;/code> -&amp;gt; &lt;code>runtime.gosched_m&lt;/code> -&amp;gt; &lt;code>runtime.goschedImpl&lt;/code>。&lt;/li>
&lt;li>系统监控 — &lt;code>runtime.sysmon&lt;/code> -&amp;gt; &lt;code>runtime.retake&lt;/code> -&amp;gt; &lt;code>runtime.preemptone&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h3>主动挂起&lt;span class="hx-absolute -hx-mt-20" id="主动挂起">&lt;/span>
&lt;a href="#%e4%b8%bb%e5%8a%a8%e6%8c%82%e8%b5%b7" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>runtime.gopark&lt;/code> 会通过 &lt;code>runtime.mcall&lt;/code> 切换到 &lt;code>g0&lt;/code> 的栈上调用 &lt;code>runtime.park_m&lt;/code>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">park_m&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">casgstatus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Grunning&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Gwaiting&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dropg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>将当前 goroutine 的状态从 &lt;code>_Grunning&lt;/code> 切换至 &lt;code>_Gwaiting&lt;/code>。&lt;/li>
&lt;li>调用 &lt;code>runtime.dropg&lt;/code> 移除 &lt;code>m&lt;/code> 和 &lt;code>g&lt;/code> 之间的关联。&lt;/li>
&lt;li>调用 &lt;code>runtime.schedule&lt;/code> 触发新一轮的调度。&lt;/li>
&lt;/ol>
&lt;p>当 goroutine 等待的特定条件满足后，运行时会调用 &lt;code>runtime.goready&lt;/code> 将因为调用 &lt;code>runtime.gopark&lt;/code> 而陷入休眠的 goroutine 唤醒。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">goready&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">traceskip&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">systemstack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">ready&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">traceskip&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">ready&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">traceskip&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">next&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">mp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">acquirem&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// disable preemption because it can be holding p in a local var
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">casgstatus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Gwaiting&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Grunnable&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">runqput&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">next&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">npidle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nmspinning&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">wakep&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>将 goroutine 的 &lt;code>_Gwaiting&lt;/code> 状态切换至 &lt;code>_Grunnable&lt;/code>。&lt;/li>
&lt;li>将其加入处理器的运行队列中，等待调度器的调度。&lt;/li>
&lt;/ol>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">&lt;p>&lt;code>gopark&lt;/code> 需要调用 &lt;code>schedule&lt;/code> 而 &lt;code>goready&lt;/code> 不需要，原因：&lt;/p>
&lt;ul>
&lt;li>&lt;code>gopark&lt;/code> 将 &lt;code>g&lt;/code> 从 &lt;code>Grunning&lt;/code> 变为 &lt;code>Gwaiting&lt;/code>，必须让出 &lt;code>m&lt;/code>，找新 &lt;code>g&lt;/code> 来运行。&lt;/li>
&lt;li>&lt;code>goready&lt;/code> 将 &lt;code>g&lt;/code> 从 &lt;code>Gwaiting&lt;/code> 变为 &lt;code>Grunnable&lt;/code>，只需将 &lt;code>g&lt;/code> 放入 &lt;code>runq&lt;/code> 队列即可。&lt;/li>
&lt;/ul>
&lt;p>正常结束的非 main goroutine 会返回到 &lt;code>goexit&lt;/code> 函数，切换到 &lt;code>g0&lt;/code> 继续执行 &lt;code>shcedule&lt;/code>。&lt;/p>
&lt;p>&lt;strong>&lt;code>gopark&lt;/code>（&lt;code>mcall&lt;/code>）和 &lt;code>goready&lt;/code>（&lt;code>systemstack&lt;/code>）都会切换到 &lt;code>g0&lt;/code> 栈去执行&lt;/strong>。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h4>使用场景&lt;span class="hx-absolute -hx-mt-20" id="使用场景">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>channel 阻塞（&lt;code>hchan.sendq&lt;/code> 向 channel 发送数据而被阻塞的 goroutine 队列，&lt;code>hchan.recvq&lt;/code> 读取 channel 的数据而被阻塞的 goroutine 队列）-&amp;gt; &lt;code>gopark/goready&lt;/code>。&lt;/li>
&lt;li>&lt;code>sync.Metux&lt;/code> -&amp;gt; 信号量（&lt;code>semaRoot.treap&lt;/code> 等待着队列）-&amp;gt; &lt;code>gopark/goready&lt;/code>。&lt;/li>
&lt;li>&lt;code>sync.WaitGroup&lt;/code> -&amp;gt; 信号量（&lt;code>semaRoot.treap&lt;/code> 等待着队列）-&amp;gt; &lt;code>gopark/goready&lt;/code>。&lt;/li>
&lt;li>&lt;code>sync.Cond&lt;/code> -&amp;gt; &lt;code>gopark/goready&lt;/code>。&lt;/li>
&lt;li>&lt;code>golang.org/x/sync/semaphore&lt;/code> -&amp;gt; channel 阻塞、通知。&lt;/li>
&lt;li>&lt;code>golang.org/x/sync/singleflight&lt;/code> -&amp;gt; &lt;code>sync.Metux&lt;/code> -&amp;gt; 信号量（&lt;code>semaRoot.treap&lt;/code> 等待着队列）-&amp;gt; &lt;code>gopark/goready&lt;/code>。&lt;/li>
&lt;li>&lt;code>golang.org/x/sync/errgroup&lt;/code> -&amp;gt; &lt;code>sync.WaitGroup&lt;/code> -&amp;gt; 信号量（&lt;code>semaRoot.treap&lt;/code> 等待着队列）-&amp;gt; &lt;code>gopark/goready&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>上面的几种方式，都有一个被阻塞的 goroutine 队列， &lt;code>goready&lt;/code> 唤醒时，可以直接使用阻塞队列中的 &lt;code>g&lt;/code> 对象。&lt;/p>
&lt;h3>系统调用&lt;span class="hx-absolute -hx-mt-20" id="系统调用">&lt;/span>
&lt;a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>系统调用也会触发运行时调度器的调度，goroutine 有一个 &lt;code>_Gsyscall&lt;/code> 状态用来表示系统调用。&lt;/p>
&lt;p>Go 通过汇编语言封装了系统调用：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#define INVOKE_SYSCALL INT $0x80
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">TEXT&lt;/span> &lt;span class="err">·&lt;/span>&lt;span class="no">Syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="no">NOSPLIT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="no">$0-28&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">entersyscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">INVOKE_SYSCALL&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">exitsyscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">RET&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">ok:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">CALL&lt;/span> &lt;span class="no">runtime&lt;/span>&lt;span class="err">·&lt;/span>&lt;span class="no">exitsyscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">RET&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol>
&lt;li>&lt;code>runtime.entersyscall&lt;/code> 完成 goroutine 进入系统调用前的准备工作。&lt;/li>
&lt;li>&lt;code>INVOKE_SYSCALL&lt;/code> 系统调用指令。&lt;/li>
&lt;li>&lt;code>runtime.exitsyscall&lt;/code> 为当前 goroutine 重新分配资源。&lt;/li>
&lt;li>释放当前 &lt;code>m&lt;/code> 上的锁，&lt;strong>锁被释放后，当前线程会陷入系统调用等待返回&lt;/strong>，在锁被释放后，&lt;strong>会有其他 goroutine 抢占 &lt;code>p&lt;/code>&lt;/strong>（这是后面 &lt;code>exitsyscall&lt;/code> 会有两种路径的原因）。&lt;/li>
&lt;/ol>
&lt;h4>runtime.entersyscall&lt;span class="hx-absolute -hx-mt-20" id="runtimeentersyscall">&lt;/span>
&lt;a href="#runtimeentersyscall" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>&lt;code>runtime.entersyscall&lt;/code> 主要做以下几件事：&lt;/p>
&lt;ol>
&lt;li>保存当前 goroutine 的上下文信息，程序计数器 PC 和栈指针 SP 中的内容。&lt;/li>
&lt;li>切换当前 goroutine 为 &lt;code>_Gsyscall&lt;/code> 状态。&lt;/li>
&lt;li>将 goroutine 的 &lt;code>p&lt;/code> 和 &lt;code>m&lt;/code> 暂时分离并更新 &lt;code>p&lt;/code> 的状态到 &lt;code>_Psyscall&lt;/code>；&lt;/li>
&lt;/ol>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">&lt;p>这里的当前 goroutine 并没有和 &lt;code>m&lt;/code> 解绑，只是 &lt;code>p&lt;/code> 和 &lt;code>m&lt;/code> 解绑。当前 goroutine 的保存上下文信息是执行系统调用前的 PC 和 SP 等。&lt;/p>
&lt;p>然后 &lt;code>m&lt;/code> 陷入了阻塞，等待系统调用返回。&lt;/p>
&lt;p>返回之后才会将当前 goroutine 切换至 &lt;code>_Grunnable&lt;/code> 状态，并移除 &lt;code>m&lt;/code> 和当前 goroutine 的关联，放入运行队列，触发 &lt;code>runtime.schedule&lt;/code> 调度。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h4>runtime.exitsyscall&lt;span class="hx-absolute -hx-mt-20" id="runtimeexitsyscall">&lt;/span>
&lt;a href="#runtimeexitsyscall" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>系统调用结束后，会调用退出系统调用的函数 &lt;code>runtime.exitsyscall&lt;/code> 为当前 goroutine 重新分配资源，该函数有两个不同的执行路径：&lt;/p>
&lt;ol>
&lt;li>调用 &lt;code>runtime.exitsyscallfast&lt;/code>；&lt;/li>
&lt;li>切换至 &lt;code>g0&lt;/code> 并调用 &lt;code>runtime.exitsyscall0&lt;/code>，将当前 goroutine 切换至 &lt;code>_Grunnable&lt;/code> 状态；&lt;/li>
&lt;/ol>
&lt;p>对于当前 goroutine 放入哪个运行队列有两种策略：&lt;/p>
&lt;ol>
&lt;li>如果当前 goroutine 的执行系统调用前就绑定的 &lt;code>p&lt;/code> 仍处于 &lt;code>_Psyscall&lt;/code> 状态，会直接调用 &lt;code>wirep&lt;/code> 将 goroutine 与处理器进行关联；&lt;/li>
&lt;li>如果调度器中存在闲置的 &lt;code>p&lt;/code>，会调用 &lt;code>runtime.acquirep&lt;/code> 使用闲置的 &lt;code>p&lt;/code> 处理当前 goroutine；&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>最后都会调用 &lt;code>runtime.schedule&lt;/code> 触发调度器的调度&lt;/strong>。&lt;/p>
&lt;h3>协作式调度&lt;span class="hx-absolute -hx-mt-20" id="协作式调度">&lt;/span>
&lt;a href="#%e5%8d%8f%e4%bd%9c%e5%bc%8f%e8%b0%83%e5%ba%a6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;strong>&lt;code>runtime.Gosched&lt;/code> 函数会主动让出处理器&lt;/strong>，允许其他 goroutine 运行。&lt;strong>该函数无法挂起 goroutine，调度器可能会将当前 goroutine 调度到其他线程上&lt;/strong>。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">Gosched&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">checkTimeouts&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">mcall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gosched_m&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">gosched_m&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">goschedImpl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">goschedImpl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">casgstatus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Grunning&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Grunnable&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dropg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">globrunqput&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>经过连续几次跳转，最终在 &lt;code>g0&lt;/code> 的栈上调用 &lt;code>runtime.goschedImpl&lt;/code>：&lt;/p>
&lt;ol>
&lt;li>运行时会更新 goroutine 的状态到 &lt;code>_Grunnable&lt;/code>。&lt;/li>
&lt;li>让出当前的处理器并将 goroutine 重新放回全局队列。&lt;/li>
&lt;li>在最后，该函数会调用 &lt;code>runtime.schedule&lt;/code> 触发调度。&lt;/li>
&lt;/ol>
&lt;h3>总结&lt;span class="hx-absolute -hx-mt-20" id="总结">&lt;/span>
&lt;a href="#%e6%80%bb%e7%bb%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>goroutine 的调度，总体就是一个循环，伪代码：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// --------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 线程部分
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 定义一个线程私有全局变量，注意它是一个指向 m 结构体对象的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ThreadLocal 用来定义线程私有全局变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">ThreadLocal&lt;/span> &lt;span class="nx">self&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// schedule 函数实现调度逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建和初始化 m 结构体对象，并赋值给私有全局变量 self
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">self&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">initm&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 调度循环
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">find_a_runnable_goroutine_from_local_runqueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">run_g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// CPU 运行该 goroutine，直到需要调度其它 goroutine 才返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">save_status_of_g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 保存 goroutine 的状态，主要是寄存器的值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>正常执行结束的 goroutine，会返回到 &lt;code>goexit&lt;/code> 函数，然后切换到 &lt;code>g0&lt;/code> 栈继续执行 &lt;code>schedule&lt;/code> 函数。&lt;/li>
&lt;li>调用 &lt;code>gopark&lt;/code> 的 goroutine，将状态设置为 &lt;code>_Gwaiting&lt;/code>，然后切换到 &lt;code>g0&lt;/code> 栈继续执行 &lt;code>schedule&lt;/code> 函数。当前 goroutine 会放到某个队列中，方便 &lt;code>goready&lt;/code> 时唤醒。唤醒时将状态设置为 &lt;code>_Grunnable&lt;/code>，并放入可运行队列。&lt;/li>
&lt;li>调用 &lt;code>Gosched&lt;/code> 函数会让出处理器并将 goroutine 重新放回全局队列。状态仍然是 &lt;code>_Grunnable&lt;/code>。可能会被调度到其他的 &lt;code>p&lt;/code>。然后切换到 &lt;code>g0&lt;/code> 栈继续执行 &lt;code>schedule&lt;/code> 函数。&lt;/li>
&lt;li>执行系统调用的 goroutine，将状态设置为 &lt;code>_Gsyscall&lt;/code>。当前 goroutine 仍然和 &lt;code>m&lt;/code> 绑定，&lt;code>m&lt;/code> 被阻塞，系统调用返回时，将状态设置为 &lt;code>_Grunnable&lt;/code>，并将 goroutine 放到可运行队列。然后切换到 &lt;code>g0&lt;/code> 栈继续执行 &lt;code>schedule&lt;/code> 函数。&lt;/li>
&lt;li>被抢占调度的 goroutine，将状态设置为 &lt;code>_Grunnable&lt;/code>，并放入可运行队列。然后切换到 &lt;code>g0&lt;/code> 栈继续执行 &lt;code>schedule&lt;/code> 函数。&lt;/li>
&lt;/ul>
&lt;h2>线程管理&lt;span class="hx-absolute -hx-mt-20" id="线程管理">&lt;/span>
&lt;a href="#%e7%ba%bf%e7%a8%8b%e7%ae%a1%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>runtime.LockOSThread&lt;/code> 和 &lt;code>runtime.UnlockOSThread&lt;/code> 可以绑定 goroutine 和线程完成一些比较特殊的操作。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">LockOSThread&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">newmHandoff&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">haveTemplateThread&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">GOOS&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;plan9&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">startTemplateThread&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_g_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lockedExt&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dolockOSThread&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">dolockOSThread&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_g_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lockedg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_g_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lockedm&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>runtime.dolockOSThread&lt;/code> 会分别设置线程的 &lt;code>lockedg&lt;/code> 字段和 goroutine 的 &lt;code>lockedm&lt;/code> 字段，这两行代码会绑定线程和 goroutine。&lt;/p>
&lt;p>&lt;code>runtime.UnlockOSThread&lt;/code> 用户解绑 goroutine 和线程。&lt;/p>
&lt;h3>线程生命周期&lt;span class="hx-absolute -hx-mt-20" id="线程生命周期">&lt;/span>
&lt;a href="#%e7%ba%bf%e7%a8%8b%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Go 语言的运行时会通过 &lt;code>runtime.startm&lt;/code> 启动线程来执行处理器 &lt;code>p&lt;/code>，如果在该函数中没能从闲置列表中获取到线程 &lt;code>m&lt;/code> 就会调用 &lt;code>runtime.newm&lt;/code> 创建新的线程：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">newm&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fn&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">_p_&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">id&lt;/span> &lt;span class="kt">int64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">allocm&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nextp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sigmask&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">initSigmask&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">newm1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">newm1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">iscgo&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">newosproc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>创建新的线程需要使用如下所示的 &lt;code>runtime.newosproc&lt;/code>，该函数在 Linux 平台上会通过系统调用 clone 创建新的操作系统线程：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">newosproc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">stk&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">hi&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ret&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">clone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">cloneFlags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g0&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">funcPC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mstart&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item></channel></rss>