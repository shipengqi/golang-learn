<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="哈希表 # map 是一个无序的 key/value 对的集合，同一个 key 只会出现一次。
哈希表的设计原理 # 哈希表其实是数组的扩展。哈希表是利用数组可以根据下标随机访问（时间复杂度是 O(1)）这一特性来实现快速查找的。
哈希函数 # 哈希表是通过哈希函数将 key 转化为数组的下标，然后将数据存储在数组下标对应的位置。查询时，也是同样的使用哈希函数计算出数组下标，从下标对应的位置取出数据。
哈希函数的基本要求：
哈希函数计算出来的值是一个非负整数。 如果 key1 == key2 那么 hash(key1) == hash(key2) 如果 key1 != key2 那么 hash(key1) != hash(key2) 第三点，想要实现一个不同的 key 对应的哈希值绝对不一样的哈希函数，几乎是不可能的，也就说无法避免哈希冲突。
常用的处理哈希冲突的方法有两种：开放寻址法和链表法。
开放寻址法 # 开放寻址法核心思想是，如果出现了哈希冲突，就重新探测一个空闲位置，将其插入。
上图蓝色表示已经插入的元素，key9 哈希后得到的数组下标为 6，但是已经有数据了，产生了冲突。那么就按顺序向后查找直到找到一个空闲的位置，如果到数组的尾部都没有找到空闲的位置，就从头开始继续找。 上图最终找到位置 1 并插入元素。
查找的逻辑和插入类似，从哈希函数计算出来的下标位置开始查找，比较数组中下标位置的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。直到找到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。
可以看出当数组中空闲位置不多的时候，哈希冲突的概率就会大大提高。装载因子（load factor）就是用来表示空位的多少。
装载因子=已插入的元素个数/哈希表的长度 装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。
链表法 # 链表法是最常见的哈希冲突的解决办法。在哈希表中，每个桶（bucket）会对应一条链表，所有哈希值相同的元素都放到相同桶对应的链表中。
插入时，哈希函数计算后得出存放在几号桶，然后遍历桶中的链表了：
找到键相同的键值对，则更新键对应的值； 没有找到键相同的键值对，则在链表的末尾追加新的键值对 链表法实现的哈希表的装载因子：
装载因子=已插入的元素个数/桶数量 Go map 原理 # 表示 map 的结构体是 hmap："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="哈希表"><meta property="og:description" content="哈希表 # map 是一个无序的 key/value 对的集合，同一个 key 只会出现一次。
哈希表的设计原理 # 哈希表其实是数组的扩展。哈希表是利用数组可以根据下标随机访问（时间复杂度是 O(1)）这一特性来实现快速查找的。
哈希函数 # 哈希表是通过哈希函数将 key 转化为数组的下标，然后将数据存储在数组下标对应的位置。查询时，也是同样的使用哈希函数计算出数组下标，从下标对应的位置取出数据。
哈希函数的基本要求：
哈希函数计算出来的值是一个非负整数。 如果 key1 == key2 那么 hash(key1) == hash(key2) 如果 key1 != key2 那么 hash(key1) != hash(key2) 第三点，想要实现一个不同的 key 对应的哈希值绝对不一样的哈希函数，几乎是不可能的，也就说无法避免哈希冲突。
常用的处理哈希冲突的方法有两种：开放寻址法和链表法。
开放寻址法 # 开放寻址法核心思想是，如果出现了哈希冲突，就重新探测一个空闲位置，将其插入。
上图蓝色表示已经插入的元素，key9 哈希后得到的数组下标为 6，但是已经有数据了，产生了冲突。那么就按顺序向后查找直到找到一个空闲的位置，如果到数组的尾部都没有找到空闲的位置，就从头开始继续找。 上图最终找到位置 1 并插入元素。
查找的逻辑和插入类似，从哈希函数计算出来的下标位置开始查找，比较数组中下标位置的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。直到找到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。
可以看出当数组中空闲位置不多的时候，哈希冲突的概率就会大大提高。装载因子（load factor）就是用来表示空位的多少。
装载因子=已插入的元素个数/哈希表的长度 装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。
链表法 # 链表法是最常见的哈希冲突的解决办法。在哈希表中，每个桶（bucket）会对应一条链表，所有哈希值相同的元素都放到相同桶对应的链表中。
插入时，哈希函数计算后得出存放在几号桶，然后遍历桶中的链表了：
找到键相同的键值对，则更新键对应的值； 没有找到键相同的键值对，则在链表的末尾追加新的键值对 链表法实现的哈希表的装载因子：
装载因子=已插入的元素个数/桶数量 Go map 原理 # 表示 map 的结构体是 hmap："><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/basic/04_map/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-27T21:09:02+08:00"><title>哈希表 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.c96fce1103aadb7b8ca2609ed6e37d8b27feb4d6d4c119031273761f81e8f21e.js integrity="sha256-yW/OEQOq23uMomCe1uN9iyf+tNbUwRkDEnN2H4Ho8h4=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础数据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/ class=active>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li><li><a href=/golang-learn/docs/concurrency/12_errorgroup/>ErrGroup</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析（上）</a></li><li><a href=/golang-learn/docs/practice/05_trace/>Go 性能分析（下）</a></li><li><a href=/golang-learn/docs/practice/06_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go Core Dump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li></ul></li><li><span>🛠️ Go 工程实践</span><ul><li><a href=/golang-learn/docs/project/01_specs/>项目规范</a></li><li><a href=/golang-learn/docs/project/02_structure/>项目的目录结构</a></li><li><a href=/golang-learn/docs/project/03_code/>代码规范</a></li><li><a href=/golang-learn/docs/project/04_commitizen/>Commit 规范</a></li><li><a href=/golang-learn/docs/project/05_version/>版本规范</a></li><li><a href=/golang-learn/docs/project/06_api_doc/>API 文档</a></li><li><a href=/golang-learn/docs/project/07_flow/>Git 工作流程</a></li><li><a href=/golang-learn/docs/project/08_make/>项目管理</a></li><li><a href=/golang-learn/docs/project/09_actions/>GitHub Actions</a></li><li><a href=/golang-learn/docs/project/10_dependabot/>GitHub Dependabot</a></li><li><a href=/golang-learn/docs/project/11_templates/>GitHub 模板</a></li><li><a href=/golang-learn/docs/project/12_goreleaser/>GoReleaser</a></li><li><a href=/golang-learn/docs/project/14_error/>错误处理</a></li></ul></li><li><a href=/golang-learn/docs/advance/>🔍 底层原理</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>哈希表</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#哈希表>哈希表</a><ul><li><a href=#哈希表的设计原理>哈希表的设计原理</a><ul><li><a href=#哈希函数>哈希函数</a></li><li><a href=#开放寻址法>开放寻址法</a></li><li><a href=#链表法>链表法</a></li></ul></li><li><a href=#go-map-原理>Go map 原理</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#查询>查询</a></li><li><a href=#写入>写入</a></li><li><a href=#扩容>扩容</a></li><li><a href=#删除>删除</a></li><li><a href=#map-为什么是无序的>map 为什么是无序的</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=哈希表>哈希表
<a class=anchor href=#%e5%93%88%e5%b8%8c%e8%a1%a8>#</a></h1><p><code>map</code> 是一个无序的 <code>key/value</code> 对的集合，同一个 key 只会出现一次。</p><h2 id=哈希表的设计原理>哈希表的设计原理
<a class=anchor href=#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>哈希表其实是数组的扩展。哈希表是利用数组可以根据下标随机访问（时间复杂度是 <code>O(1)</code>）这一特性来实现快速查找的。</p><h3 id=哈希函数>哈希函数
<a class=anchor href=#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0>#</a></h3><p>哈希表是通过<strong>哈希函数</strong>将 key 转化为数组的下标，然后将数据存储在数组下标对应的位置。查询时，也是同样的使用哈希函数计算出数组下标，从下标对应的位置取出数据。</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/c532a70c015ab877e64c7fec6382cf1791597cbc/go/hash-func.png alt=map-seek-addr></p><p>哈希函数的基本要求：</p><ol><li>哈希函数计算出来的值是一个非负整数。</li><li>如果 <code>key1 == key2</code> 那么 <code>hash(key1) == hash(key2)</code></li><li>如果 <code>key1 != key2</code> 那么 <code>hash(key1) != hash(key2)</code></li></ol><p>第三点，想要实现一个不同的 key 对应的哈希值绝对不一样的哈希函数，几乎是不可能的，也就说无法避免<strong>哈希冲突</strong>。</p><p>常用的处理哈希冲突的方法有两种：<strong>开放寻址法</strong>和<strong>链表法</strong>。</p><h3 id=开放寻址法>开放寻址法
<a class=anchor href=#%e5%bc%80%e6%94%be%e5%af%bb%e5%9d%80%e6%b3%95>#</a></h3><p>开放寻址法核心思想是，如果出现了哈希冲突，就重新探测一个空闲位置，将其插入。</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/1e5051b9e3f0f681565b1737802ae7e15e075fc5/go/map-seek-addr.png alt=map-seek-addr></p><p>上图蓝色表示已经插入的元素，<code>key9</code> 哈希后得到的数组下标为 6，但是已经有数据了，产生了冲突。那么就按顺序向后查找直到找到一个空闲的位置，如果到数组的尾部都没有找到空闲的位置，就从头开始继续找。
上图最终找到位置 1 并插入元素。</p><p>查找的逻辑和插入类似，从哈希函数计算出来的下标位置开始查找，比较数组中下标位置的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。直到找到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。</p><p>可以看出当数组中空闲位置不多的时候，哈希冲突的概率就会大大提高。<strong>装载因子</strong>（load factor）就是用来表示空位的多少。</p><pre tabindex=0><code>装载因子=已插入的元素个数/哈希表的长度
</code></pre><p>装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。</p><h3 id=链表法>链表法
<a class=anchor href=#%e9%93%be%e8%a1%a8%e6%b3%95>#</a></h3><p>链表法是最常见的哈希冲突的解决办法。在哈希表中，每个桶（bucket）会对应一条链表，所有哈希值相同的元素都放到相同桶对应的链表中。</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/c532a70c015ab877e64c7fec6382cf1791597cbc/go/map-link.png alt=map-link></p><p>插入时，哈希函数计算后得出存放在几号桶，然后遍历桶中的链表了：</p><ul><li>找到键相同的键值对，则更新键对应的值；</li><li>没有找到键相同的键值对，则在链表的末尾追加新的键值对</li></ul><p>链表法实现的哈希表的装载因子：</p><pre tabindex=0><code>装载因子=已插入的元素个数/桶数量
</code></pre><h2 id=go-map-原理>Go map 原理
<a class=anchor href=#go-map-%e5%8e%9f%e7%90%86>#</a></h2><p>表示 map 的结构体是 <code>hmap</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/map.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 哈希表中的元素数量 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span>        
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 状态标识，主要是 goroutine 写入和扩容机制的相关状态控制。并发读写的判断条件之一就是该值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都 2 的倍数，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 所以该字段会存储对数，也就是 len(buckets) == 2^B
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 溢出桶的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span>     
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 哈希种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 指向 buckets 数组，长度为 2^B
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>buckets</span>   <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 哈希在扩容时用于保存之前 buckets 的字段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 等量扩容的时候，buckets 长度和 oldbuckets 相等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 双倍扩容的时候，buckets 长度是 oldbuckets 的两倍
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 迁移进度，小于此地址的 buckets 是已迁移完成的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>         
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mapextra</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// hmap.buckets （当前）溢出桶的指针地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>overflow</span>    <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 为 hmap.oldbuckets （旧）溢出桶的指针地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>oldoverflow</span> <span style=color:#f92672>*</span>[]<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为空闲溢出桶的指针地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>     
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>hmap.buckets</code> 就是指向一个 <code>bmap</code> 数组。<code>bmap</code> 的结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tophash</span> [<span style=color:#a6e22e>bucketCnt</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 编译时，编译器会推导键值对占用内存空间的大小，然后修改 bmap 的结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>topbits</span>  [<span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>keys</span>     [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>keytype</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>values</span>   [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>valuetype</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pad</span>      <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>overflow</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>bmap</code> 就是桶，一个桶里面会最多存储 8 个键值对。</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/8e8c090d5a1de970d1d00bdf5f79917e74bfd63d/go/bmap-struct.png alt=bmap-struct></p><ol><li>在桶内，会根据 key 计算出来的 hash 值的高 8 位来决定 key 存储在桶中的位置。</li><li>key 和 value 是分别放在一块连续的内存，这样做的目的是为了节省内存。例如一个 <code>map[int64]int8</code> 类型的 map，如果按照 <code>key1/value1/key2/value2 ...</code> 这样的形式来存储，那么内存对齐每个 <code>key/value</code> 都需要 padding 7 个字节。
分开连续存储的话，就只需要在最后 padding 一次。</li><li>每个桶只能存储 8 个 <code>key/value</code>，如果有更多的 key 放入当前桶，就需要一个溢出桶，通过 <code>overflow</code> 指针连接起来。</li></ol><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/8e8c090d5a1de970d1d00bdf5f79917e74bfd63d/go/hmap.png alt=hmap></p><h3 id=初始化>初始化
<a class=anchor href=#%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h3><p>初始化 <code>map</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>{
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;1&#34;</span>: <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;3&#34;</span>: <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;5&#34;</span>: <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>hash2</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><p>不管是使用字面量还是 <code>make</code> 初始化 map，最后都是调用 <code>makemap</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makemap</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>hint</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// initialize Hmap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span> = new(<span style=color:#a6e22e>hmap</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取一个随机的哈希种子
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span> = <span style=color:#a6e22e>fastrand</span>()
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 根据传入的 hint 计算出需要的最小需要的桶的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>B</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>hint</span>, <span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>B</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> = <span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 初始化 hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 如果 hint 长度比较大，分配内存会花费长一点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// makeBucketArray 根据传入的 B 计算出的需要创建的桶数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 并在内存中分配一片连续的空间用于存储数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> = new(<span style=color:#a6e22e>mapextra</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>预分配的溢出桶和正常桶是在一块连续的内存中。</p><h3 id=查询>查询
<a class=anchor href=#%e6%9f%a5%e8%af%a2>#</a></h3><p>查询 map 中的值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span>[<span style=color:#a6e22e>key</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span>[<span style=color:#a6e22e>key</span>]
</span></span></code></pre></div><p>这两种查询方式会被转换成 <a href=https://github.com/golang/go/blob/8da6405e0db80fa0a4136fb816c7ca2db716c2b2/src/runtime/map.go#L396><code>mapaccess1</code></a> 和 <code>mapaccess2</code> 函数，两个函数基本一样，不过 <code>mapaccess2</code> 函数的返回值多了一个 <code>bool</code> 类型。</p><p>查询过程：</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/ae69f3fdb54032a8619d342edccbcdc95c7776a6/go/map-get.png alt=map-get></p><h4 id=1-计算哈希值>1. 计算哈希值
<a class=anchor href=#1-%e8%ae%a1%e7%ae%97%e5%93%88%e5%b8%8c%e5%80%bc>#</a></h4><p>通过哈希函数和种子获取当前 key 的 64 位的哈希值（64 位机）。以上图哈希值：<code>11010111 | 110000110110110010001111001010100010010110010101001 │ 00011</code> 为例。</p><h4 id=2-计算这个-key-要放在哪个桶>2. 计算这个 key 要放在哪个桶
<a class=anchor href=#2-%e8%ae%a1%e7%ae%97%e8%bf%99%e4%b8%aa-key-%e8%a6%81%e6%94%be%e5%9c%a8%e5%93%aa%e4%b8%aa%e6%a1%b6>#</a></h4><p>根据哈希值的 <code>B</code> （<code>hmap.B</code>）个 bit 位来计算，也就是 <code>00011</code>，十进制的值是 <code>3</code>，那么就是 <code>3</code> 号桶。</p><h4 id=3-计算这个-key-在桶内的位置>3. 计算这个 key 在桶内的位置
<a class=anchor href=#3-%e8%ae%a1%e7%ae%97%e8%bf%99%e4%b8%aa-key-%e5%9c%a8%e6%a1%b6%e5%86%85%e7%9a%84%e4%bd%8d%e7%bd%ae>#</a></h4><p>根据哈希值的高 8 位，也就是 <code>10010111</code>，十进制的值是 <code>151</code>，先用 <code>151</code> 和桶内存储的 <code>tophash</code> 比较，再比较桶内的存储的 key 和传入的 key，这种方式可以优化桶内的读写速度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/map.go#L434 mapaccess1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 先比较 tophash，如果不相等，就直接进入下次循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 再比较桶内的 key 和传入的 key，如果相等，再获取目标值的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Key</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>计算在几号桶用的是后 <code>B</code> 位，<code>tophash</code> 使用的是高 8 位，这种方式可以避免一个桶内出现大量相同的 <code>tophash</code>，影响读写的性能。</p></blockquote><p>如果当前桶中没有找到 key，而且存在溢出桶，那么会接着遍历所有的溢出桶中的数据。</p><h3 id=写入>写入
<a class=anchor href=#%e5%86%99%e5%85%a5>#</a></h3><p>写入 map 和查询 map 的实现原理类似，计算哈希值和存放在哪个桶，然后遍历当前桶和溢出桶的数据：</p><ul><li>如果当前 key 不存在，则通过偏移量存储到桶中</li><li>如果已经存在，则返回 value 的内存地址，赋值操作是在编译期执行的。</li><li>如果桶已满，则会创建新桶或者使用空闲的溢出桶，添加到已有桶的末尾，<code>noverflow</code> 计数加 1。</li></ul><h3 id=扩容>扩容
<a class=anchor href=#%e6%89%a9%e5%ae%b9>#</a></h3><p>随着 map 中写入的 <code>key/value</code> 增多，装载因子会越来越大，哈希冲突的概率越来越大，性能会跟着下降。如果大量的 key 都落入到同一个桶中，哈希表会退化成链表，查询的时间复杂度会从 <code>O(1)</code> 退化到 <code>O(n)</code>。</p><p>所以当装载因子大到一定程度之后，哈希表就不得不进行扩容。</p><h4 id=go-map-在什么时候会触发扩容>Go map 在什么时候会触发扩容？
<a class=anchor href=#go-map-%e5%9c%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9a%e8%a7%a6%e5%8f%91%e6%89%a9%e5%ae%b9>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapassign</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// src/runtime/map.go mapassign
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If we hit the max load factor or we have too many overflow buckets,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and we&#39;re not already in the middle of growing, start growing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>tooManyOverflowBuckets</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>again</span> <span style=color:#75715e>// Growing the table invalidates everything, so try again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>装载因子超过阈值 6.5。</li><li>溢出桶的数量过多：<ul><li>当 <code>B &lt; 15</code> 时，如果溢出桶的数量超多 <code>2^B</code> 则触发扩容。</li><li>当 <code>B >= 15</code> 时，如果溢出桶的数量超过 <code>2^15</code> 则触发扩容。</li></ul></li></ol><h4 id=为什么溢出桶过多需要进行扩容>为什么溢出桶过多需要进行扩容？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%ba%a2%e5%87%ba%e6%a1%b6%e8%bf%87%e5%a4%9a%e9%9c%80%e8%a6%81%e8%bf%9b%e8%a1%8c%e6%89%a9%e5%ae%b9>#</a></h4><p>什么情况下会出现装载因子很小不超过阈值，但是溢出桶过多的情况？</p><p>先插入很多元素，导致创建了很多桶，但是未达到阈值，并没有触发扩容。之后再删除元素，降低元素的总量。反复执行前面的步骤，但是又不会触发扩容，就会导致创建了很多溢出桶，但是 map 中的 key 分布的很分散。导致查询和插入的效率很低。</p><h4 id=渐进式扩容>渐进式扩容
<a class=anchor href=#%e6%b8%90%e8%bf%9b%e5%bc%8f%e6%89%a9%e5%ae%b9>#</a></h4><p>扩容需要把原有的 buckets 中的数据迁移到新的 buckets 中。如果一个哈希表当前大小为 1GB，扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的内存空间搬移到新的内存空间，这是非常耗时的操作。</p><p>所以 map 的扩容采用的是一种<strong>渐进式</strong>的方式，将迁移的操作穿插在插入操作的过程中，分批完成。</p><p>大概思路就是：</p><p>当有新的 <code>key/value</code> 要插入时，将这个 <code>key/value</code> 插入到新 buckets 中，并且从老的 buckets 中拿出一个 <code>key/value</code> 放入到新 buckets。每次插入一个 <code>key/value</code>，都重复上面的过程。经过多次插入操作之后，老的 buckets 中的数据就一点一点全部迁移到新的 buckets 中了。
这样不用一次性将数据迁移，插入操作就都变得很快了。</p><p>对于查询操作，为了兼容了新、老 buckets 中的数据，会先从新 buckets 中查找，如果没有找到，再去老的 buckets 中查找。</p><h5 id=对于条件-2-溢出桶的数量过多>对于条件 2 溢出桶的数量过多
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e6%9d%a1%e4%bb%b6-2-%e6%ba%a2%e5%87%ba%e6%a1%b6%e7%9a%84%e6%95%b0%e9%87%8f%e8%bf%87%e5%a4%9a>#</a></h5><p>申请的新的 buckets 数量和原有的 buckets 数量是<strong>相等的</strong>，进行的是<strong>等量扩容</strong>。由于 buckets 数量不变，所以原有的数据在几号桶，迁移之后仍然在几号桶。比如原来在 0 号 bucket，到新的地方后，仍然放在 0 号 bucket。</p><p>扩容完成后，溢出桶没有了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。</p><h5 id=对于条件-1-当装载因子超过阈值后>对于条件 1 当装载因子超过阈值后
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e6%9d%a1%e4%bb%b6-1-%e5%bd%93%e8%a3%85%e8%bd%bd%e5%9b%a0%e5%ad%90%e8%b6%85%e8%bf%87%e9%98%88%e5%80%bc%e5%90%8e>#</a></h5><p>申请的新的 buckets 数量和原有的 buckets 数量的 <strong>2 倍</strong>，也就是 <code>B+1</code>。桶的数量改变了，那么 key 的哈希值要重新计算，才能决定它到底落在哪个 bucket。</p><p>例如，原来 <code>B=5</code>，根据出 key 的哈希值的后 5 位，就能决定它落在哪个 bucket。扩容后的 buckets 数量翻倍，B 变成了 6，因此变成哈希值的后 6 位才能决定 key 落在哪个 bucket。这叫做 <code>rehash</code>。</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/d6f049a373b8bc7134b2fd13014a4e02aa7b6248/go/map-evacuate-bucket-num.png alt=map-evacuate-bucket-num></p><p>因此，某个 key 在迁移前后 bucket 序号可能会改变，取决于 <code>rehash</code> 之后的哈希值倒数第 6 位是 0 还是 1。</p><p>扩容完成后，老 buckets 中的 key 分裂到了 2 个新的 bucket。</p><h5 id=迁移实现>迁移实现
<a class=anchor href=#%e8%bf%81%e7%a7%bb%e5%ae%9e%e7%8e%b0>#</a></h5><p>Go map 扩容的实现在 <code>hashGrow</code> 函数中，<code>hashGrow</code> 只申请新的 buckets，但并没有马上将原有的 <code>key/value</code> 迁移新的 buckets 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bigger</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 溢出桶过多触发的扩容是等量扩容，bigger 设置为 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>bigger</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>sameSizeGrow</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将原有的 buckets 挂到 oldbuckets 上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>oldbuckets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 申请新的 buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>newbuckets</span>, <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bigger</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>flags</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^</span> (<span style=color:#a6e22e>iterator</span> | <span style=color:#a6e22e>oldIterator</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>iterator</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>oldIterator</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是等量扩容，bigger 为 0，B 不变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>bigger</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> = <span style=color:#a6e22e>flags</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原有的 buckets 挂到 map 的 oldbuckets 上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span> = <span style=color:#a6e22e>oldbuckets</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 新申请的 buckets 挂到 buckets 上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newbuckets</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置迁移进度为 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 溢出桶数量为 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>迁移是在插入数据和删除数据时，也就是 <code>mapassign</code> 和 <code>mapdelete</code> 中进行的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapassign</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>again</span>:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 真正的迁移在 growWork 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span>)
</span></span><span style=display:flex><span>	}	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapdelete</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) <span style=color:#a6e22e>growing</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// oldbuckets 不为空，说明还没有迁移完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>growWork</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>bucket</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 确认迁移的老的 bucket 对应正在使用的 bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbucketmask</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 额外再迁移一个 bucket，加快迁移进度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>真正的迁移在 <code>evacuate</code> 函数中，它会对传入桶中的数据进行再分配。<code>evacuate</code> 函数每次只完成一个 bucket 的迁移工作（包括这个 bucket 链接的溢出桶），它会遍历 bucket （包括溢出桶）中得到所有 <code>key/value</code> 并迁移。
已迁移的 <code>key/value</code> 对应的 <code>tophash</code> 会被设置为 <code>evacuatedEmpty</code>，表示已经迁移。</p><h3 id=删除>删除
<a class=anchor href=#%e5%88%a0%e9%99%a4>#</a></h3><p>删除 map 中的 <code>key/value</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>delete(<span style=color:#a6e22e>hashmap</span>, <span style=color:#a6e22e>key</span>)
</span></span></code></pre></div><p><code>delete</code> 关键字的唯一作用就是将某一个 <code>key/value</code> 从哈希表中删除。会被编译器被转换成 <code>mapdelete</code> 方法。删除操作先是找到 key 的位置，清空 <code>key/value</code>，然后将 <code>hmap.count - 1</code>，并且对应的 <code>tophash</code> 设置为 <code>Empty</code>。</p><h3 id=map-为什么是无序的>map 为什么是无序的
<a class=anchor href=#map-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e6%97%a0%e5%ba%8f%e7%9a%84>#</a></h3><p>map 在扩容后，<code>key/value</code> 会进行迁移，在同一个桶中的 key，有些会迁移到别的桶中，有些 key 原地不动，导致遍历 map 就无法保证顺序。</p><p>Go 底层的实现简单粗暴，直接生成一个随机数，这个随机数决定从哪里开始遍历，因此<strong>每次 <code>for range map</code> 的结果都是不一样的。那是因为它的起始位置根本就不固定</strong>。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/71b3cd60afb327324631b06ed0522cc3c6479070 title='Last modified by PengQi Shi | November 27, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 27, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/basic/04_map.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#哈希表>哈希表</a><ul><li><a href=#哈希表的设计原理>哈希表的设计原理</a><ul><li><a href=#哈希函数>哈希函数</a></li><li><a href=#开放寻址法>开放寻址法</a></li><li><a href=#链表法>链表法</a></li></ul></li><li><a href=#go-map-原理>Go map 原理</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#查询>查询</a></li><li><a href=#写入>写入</a></li><li><a href=#扩容>扩容</a></li><li><a href=#删除>删除</a></li><li><a href=#map-为什么是无序的>map 为什么是无序的</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>