---
title: select
weight: 11
---

# select

`select` 类似于用于通信的 `switch` 语句。每个 `case` 必须是一个通信操作，要么是发送要么是接收。

当条件满足时，`select` 会去通信并执行 `case` 之后的语句，这时候其它通信是不会执行的。
如果多个 `case` 同时满足条件，`select` 会随机地选择一个执行。如果没有 `case` 可运行，它将阻塞，直到有 `case` 可运行。

一个默认的子句应该总是可运行的。

```go
select {
  case communication clause:
      ...
  case communication clause:
      ...
  default: /* 可选 */
   ...
}   
```

`for range` 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。**`for range` 会复制目标数据。可改用数组指针或者切片**。

`range` 关键字右边的位置上的代码被称为 `range` 表达式。

1. **`range` 表达式只会在 `for` 语句开始执行时被求值一次，无论后边会有多少次迭代**；
2. `range` 表达式的求值结果会被复制，也就是说，被迭代的对象是 `range` 表达式结果值的副本而不是原值。
3. `for range` 在性能比 `for` 稍差，因为 `for range` 会进行值拷贝。

字符串的复制成本很小，切片，字典，通道等引用类型本身是指针的封装，复制成本也很小，无序专门优化。

**如果 `range` 的目标表达式是函数，也只会运行一次**。

```go
numbers1 := []int{1, 2, 3, 4, 5, 6}
for i := range numbers1 {
    if i == 3 {
        numbers1[i] |= i
    }
}
fmt.Println(numbers1)
```

打印的内容会是 `[1 2 3 7 5 6]`，为什么，首先 `i` 是切片的下标，当 `i` 的值等于 3 的时候，与之对应的是切片中的第 4 个元素
值 4。对 4 和 3 进行按位或操作得到的结果是 7。

当 `for` 语句被执行的时候，在 `range` 关键字右边的 `numbers1` 会先被求值。`range` 表达式的结果值可以是数组、数组的指针、
切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。这里的 `numbers1` 是一个切片,那么迭代变量就可以
有两个，右边的迭代变量代表当次迭代对应的某一个元素值，而左边的迭代变量则代表该元素值在切片中的索引值。
循环控制语句：

- `break`，用于中断当前 `for` 循环或跳出 `switch` 语句
- `continue`，跳过当前循，继续进行下一轮循环。
- `goto`，将控制转移到被标记的语句。通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。不推荐
  使用，以免造成流程混乱。

`goto` 实例：

```go
LOOP: for a < 20 {
 if a == 15 {
   /* 跳过迭代 */
   a = a + 1
   goto LOOP
 }
 fmt.Printf("a的值为 : %d\n", a)
 a ++  
}  
```
