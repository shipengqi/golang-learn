---
title: 同步和锁
---

# 同步和锁

channel 不是用来代替锁的，channel 倾向于解决逻辑层次的并发处理，而锁用来保护局部范围的数据安全。

## 共享变量

无论任何时候，只要有两个以上 goroutine 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。
避免数据竞争的三种方式：

1. 不去写变量。读取不可能出现数据竞争。
2. 避免从多个 goroutine 访问变量，尽量把变量限定在了一个单独的 goroutine 中。(**不要使用共享数据来通信，使用通信
来共享数据**)
3. 互斥锁

## 同步锁

Go 语言包中的 `sync` 包提供了两种锁类型：`sync.Mutex` 和 `sync.RWMutex`，前者是互斥锁，后者是读写锁。

### 互斥锁

#### 使用 channel 实现互斥锁

我们可以使用容量只有 `1` 的 `channel` 来保证最多只有一个 goroutine 在同一时刻访问一个共享变量：

```go
var (
  sema = make(chan struct{}, 1) // a binary semaphore guarding balance
  balance int
)

func Deposit(amount int) {
  sema <- struct{}{} // acquire lock
  balance = balance + amount
  <-sema // release lock
}

func Balance() int {
  sema <- struct{}{} // acquire lock
  b := balance
  <-sema // release lock
  return b
}
```

#### sync.Mutex

**注意，如果 Mutex 作为匿名字段，那么接收器必须是指针。否则会导致锁失效**

```go
type data struct {
    sync.Mutex
}

func (d *Data) test() {
    d.Lock()
    defer d.Unlock()
}
```

使用 `sync.Mutex` 互斥锁：

```go
import "sync"

var (
  mu sync.Mutex // guards balance
  balance int
)

func Deposit(amount int) {
  mu.Lock()
  balance = balance + amount
  mu.Unlock()
}

func Balance() int {
  mu.Lock()
  b := balance
  mu.Unlock()
  return b
}
```

`mutex` 会保护共享变量，当已经有 goroutine 获得这个锁，再有 goroutine 访问这个加锁的变量就会被阻塞，
直到持有这个锁的 goroutine `unlock` 这个锁。

我们可以**使用 `defer` 来 `unlock` 锁，保证在函数返回之后或者发生错误返回时一定会执行 `unlock`**。

### 读写锁 `sync.RWMutex`

如果有多个 goroutine 读取变量，那么是并发安全的，这个时候使用 `sync.Mutex` 加锁就没有必要。可以使
用 `sync.RWMutex` 读写锁（多读单写锁）。

**读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护**。

一个读写锁中实际上包含了两个锁，即：读锁和写锁。`sync.RWMutex` 类型中的 `Lock` 方法和 `Unlock` 方法分别用于对写锁进行
锁定和解锁，而它的 `RLock` 方法和 `RUnlock` 方法则分别用于对读锁进行锁定和解锁。

**对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行**。

```go
var mu sync.RWMutex
var balance int
func Balance() int {
  mu.RLock() // readers lock
  defer mu.RUnlock()
  return balance
}
```

**`RLock` 只能在共享变量没有任何写入操作时可用**。

**为什么只读操作也需要加锁**？

```go
var x, y int
go func() {
  x = 1 // A1
  fmt.Print("y:", y, " ") // A2
}()
go func() {
  y = 1                   // B1
  fmt.Print("x:", x, " ") // B2
}()
```

上面的代码打印的结果可能是：

```bash
y:0 x:1
x:0 y:1
x:1 y:1
y:1 x:1

# 还可能是
x:0 y:0
y:0 x:0
```

为什么会有 `x:0 y:0` 这种结果，在一个 goroutine 中，语句的执行顺序可以保证，在声明的例子，可以保证
执行 `x = 1` 后打印 `y:`，但是不能保证打印 `y:` 时，另一个 goroutine 中 `y = 1` 是否已经执行。

所以可能的话，将变量限定在 goroutine 内部；如果是多个 goroutine 都需要访问的变量，使用互斥条件来访问。

### 注意事项

- 不要重复锁定互斥锁；**对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine 的**。这个 goroutine 所执行的流程，
会一直停滞在调用该互斥锁的 `Lock` 方法的那行代码上。直到该互斥锁的 `Unlock`方法被调用，并且这里的锁定操作成功完成，后续的代码
（也就是临界区中的代码）才会开始执行。这也正是互斥锁能够保护临界区的原因所在。
- 不要忘记解锁互斥锁，必要时使用 `defer` 语句；避免重复锁定。
- 不要对尚未锁定或者已解锁的互斥锁解锁；**解锁“读写锁中未被锁定的写锁”，会立即引发 panic**，对于其中的读锁也是如此，并且同
样是不可恢复的。
- **不要在多个函数之间直接传递互斥锁。一旦，你把一个互斥锁同时用在了多个地方，就必然会有更多的 goroutine 争用这把锁**。
这不但会让你的程序变慢，还会大大增加死锁（`deadlock`）的可能性。

所谓的**死锁**，指的就是当前程序中的主 goroutine，以及我们启用的那些 goroutine 都已经被阻塞。这些 goroutine 可以被统
称为用户级的 goroutine。这就相当于整个程序都已经停滞不前了。

Go 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 goroutine 都处于等待状态，就会自行抛出一个带有如下
信息的 panic：`fatal error: all goroutines are asleep - deadlock!`

**注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用 recover 函数对它们起不到任何作用。
也就是说，一旦产生死锁，程序必然崩溃**。

**最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区**。

## 条件变量 sync.Cond

条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享
资源的那些线程的。**当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程**。

条件变量在这里的最大优势就是在效率方面的提升。当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，
只要等待通知就好了。

### 条件变量怎样与互斥锁配合使用

条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。

Go 语言标准库中的 sync.Cond 一个条件变量，它可以让一系列的 Goroutine 都在满足特定条件时被唤醒。

条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。我们在利用条件变量等待通知的时候，
需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后
再做这两种操作。

```go
var mailbox uint8
var lock sync.RWMutex
sendCond := sync.NewCond(&lock)
recvCond := sync.NewCond(lock.RLocker())
```

`lock` 是一个类型为 `sync.RWMutex` 的变量，是一个读写锁。基于这把锁，我还创建了两个代表条件变量的变量，名字分别
叫 `sendCond` 和 `recvCond`。

**`sync.Cond` 类型并不是开箱即用的。只能利用 `sync.NewCond` 函数创建它的指针值**。

`lock` 变量的 `Lock` 方法和 `Unlock` 方法分别用于对其中写锁的锁定和解锁，它们与 `sendCond` 变量的含义是对应的。
被视为对共享资源的写操作。

初始化 `recvCond`这 个条件变量，我们需要的是 `lock` 变量中的读锁，`sync.RWMutex` 类型的 `RLocker` 方法可以实现这一需求。
`lock.RLocker()`，在其内部会分别调用 `lock` 变量的 `RLock` 方法和 `RUnlock` 方法。

下面是一个例子：
`mailbox` 是一个信箱，如果在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信
箱里没有情报，那也只能先回去了。

```go
lock.Lock()
for mailbox == 1 {
    sendCond.Wait()
}
mailbox = 1
lock.Unlock()
recvCond.Signal()
```

先调用 `lock` 变量的 `Lock` 方法。注意，这个 `Lock` 方法在这里意味的是：持有信箱上的锁，并且有打开信箱的权利，
而不是锁上这个锁。

检查 `mailbox` 变量的值是否等于 1，也就是说，要看看信箱里是不是还存有情报。如果还有情报，那么我就回家去等通知。

如果信箱里没有情报，那么我就把新情报放进去，关上信箱、锁上锁，然后离开。用代码表达出来就是 `mailbox = 1` 和 `lock.Unlock()`。
然后发通知，“信箱里已经有新情报了”，我们调用 `recvCond` 的 `Signal` 方法就可以实现这一步骤。

另一方面，你现在是另一个 goroutine，想要适时地从信箱中获取情报，然后通知我。

```go
lock.RLock()
for mailbox == 0 {
    recvCond.Wait()
}
mailbox = 0
lock.RUnlock()
sendCond.Signal()
```

事情在流程上其实基本一致，只不过每一步操作的对象是不同的。

**为什么先要锁定条件变量基于的互斥锁，才能调用它的 Wait 方法？**

`Wait` 方法主要做了四件事。

1. 把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。
2. 解锁当前的条件变量基于的那个互斥锁。
3. 让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这
个 `Wait` 方法的那行代码上。
4. 如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前
的 goroutine 就会继续执行后面的代码了。

因为条件变量的 `Wait` 方法在阻塞当前的 goroutine 之前会解锁它基于的互斥锁，所以在调用该 `Wait` 方法之前我们必须先
锁定那个互斥锁，否则在调用这个 `Wait` 方法时，就会引发一个不可恢复的 panic。

为什么条件变量的 `Wait` 方法要这么做呢？你可以想象一下，如果 `Wait` 方法在互斥锁已经锁定的情况下，阻塞了当前的 goroutine，
那么又由谁来解锁呢？别的 goroutine 吗？

先不说这违背了互斥锁的重要使用原则，即：成对的锁定和解锁，就算别的 goroutine 可以来解锁，那万一解锁重复了怎么办？
由此引发的 panic 可是无法恢复的。

如果当前的 goroutine 无法解锁，别的 goroutine 也都不来解锁，那么又由谁来进入临界区，并改变共享资源的状态呢？只要共享资源
的状态不变，即使当前的 goroutine 因收到通知而被唤醒，也依然会再次执行这个 `Wait` 方法，并再次被阻塞。

所以说，如果条件变量的 `Wait` 方法不先解锁互斥锁的话，那么就只会造成两种后果：不是当前的程序因 panic 而崩溃，就是相关的
 goroutine 全面阻塞。

**为什么要用 `for` 语句来包裹调用其 `Wait` 方法的表达式，用 `if` 语句不行吗？**

`if` 语句只会对共享资源的状态检查一次，而 `for` 语句却可以做多次检查，直到这个状态改变为止。

那为什么要做多次检查呢？

为了保险起见。如果一个 goroutine 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用
条件变量的 `Wait` 方法，并继续等待下次通知的到来。

这种情况是很有可能发生的。

### 条件变量的 `Signal` 方法和 `Broadcast` 方法有哪些异同

条件变量的 `Signal` 方法和 `Broadcast` 方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 goroutine，
而后者的通知却会唤醒所有为此等待的 goroutine。

条件变量的 `Wait` 方法总会把当前的 goroutine 添加到通知队列的队尾，而它的 `Signal` 方法总会从通知队列的队首开始查找可被
唤醒的 goroutine。所以，因 `Signal` 方法的通知而被唤醒的 goroutine 一般都是最早等待的那一个。

## 原子操作

Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代
码包 `sync/atomic` 中。

`sync/atomic` 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、
存储（store）和交换（swap）。

这些函数针对的数据类型并不多。对这些类型中的每一个，`sync/atomic` 包都会有一套函数给予支持。这些数据类型有：
`int32`、`int64`、`uint32`、`uint64`、`uintptr`，以及 `unsafe` 包中的 `Pointer`。不过，针对
`unsafe.Pointer` 类型，该包并未提供进行原子加法操作的函数。

`sync/atomic` 包还提供了一个名为 `Value` 的类型，它可以被用来存储任意类型的值。

`atomic.AddInt32` 函数的第一个参数，为什么不是 `int32` 而是 `*int32` 呢？
因为**原子操作函数需要的是被操作值的指针，而不是这个值本身**；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，
就已经与函数外的那个值毫无关系了。

所以，传入值本身没有任何意义。`unsafe.Pointer` 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向
的那个值，所以需要的仍然是指向这个指针值的指针。

只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内
存地址上的数据。

## 比较并交换操作与交换操作相比有什么不同

**比较并交换操作即 CAS 操作**，是有条件的交换操作，**只有在条件满足的情况下才会进行值的交换**。

**所谓的交换指的是，把新值赋给变量，并返回变量的旧值**。

CAS 操作用途要更广泛一些。例如，我们将它与 `for` 语句联用就可以实现一种简易的自旋锁（spinlock）。

```go
for {
    if atomic.CompareAndSwapInt32(&num2, 10, 0) {
        fmt.Println("The second number has gone to zero.")
        break
    }
    time.Sleep(time.Millisecond * 500)
}
```

在 `for` 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 `for` 循环。这就相当于，只要条件未被满足，
当前的流程就会被一直“阻塞”在这里。

这在效果上与互斥锁有些类似。不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他
的 goroutine 频繁地改变。

而 `for` 语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，
或者说更加宽松的做法。

**假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原
子操作吗**？

很有必要。其中的道理你可以对照一下读写锁。为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有
被修改完的值，对吗？

如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。

所以，一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护。不完全的保护基本上与不保护没有什么区别。

### ABA 问题

2.什么是ABA问题？怎么解决？
答：当一个值从A更新为B，再从B更新为A，普通CAS机制会误判通过检测。解决方案是使用版本号，通过比较值和版本号才判断是否可以替换。

https://blog.csdn.net/weixin_41832850/article/details/100095677

添加版本号解决 ABA 问题
真正要做到严谨的CAS机制，我们在 compare 阶段不仅需要比较内存地址V中的值是否和旧的期望值A相同，还需要比较变量的版本号是否一致。

## `sync/atomic.Value`

此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。开箱即用。

它只有两个指针方法—— `Store` 和 `Load`。不过，虽然简单，但还是有一些值得注意的地方的。

1. 一旦 `atomic.Value` 类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。只要用它来存储值了，就相当于开始真正使用了。
`atomic.Value` 类型属于结构体类型，而结构体类型属于值类型。所以，复制该类型的值会产生一个完全分离的新值。这个新值相当于被
复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者。
2. 不能用原子值存储 `nil`。
3. 我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。
4. 尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。

```go
var box6 atomic.Value
v6 := []int{1, 2, 3}
box6.Store(v6)
v6[1] = 4 // 注意，此处的操作不是并发安全的！
```

切片类型属于引用类型。所以，我在外面改动这个切片值，就等于修改了 `box6` 中存储的那个值。这相当于绕过了原子值而进行了非并发
安全的操作。怎样修补：

```go
store := func(v []int) {
    replica := make([]int, len(v))
    copy(replica, v)
    box6.Store(replica)
}
store(v6)
v6[2] = 5 // 此处的操作是安全的。
```

先为切片值 `v6` 创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入 `box6`。如此一来，
无论我再对 `v6` 的值做怎样的修改，都不会破坏 `box6` 提供的安全保护。

## sync.WaitGroup

在一些场合下里，我们使用通道的方式看起来都似乎有些蹩脚。比如：声明一个通道，使它的容量与我们手动启用的 goroutine 的数量相同。
之后利用这个通道，让主 goroutine 等待其他 goroutine 的运行结束。更具体地说就是：让其他的 goroutine 在运行结束之前，
都向这个通道发送一个元素值，并且，让主 goroutine 在最后从这个通道中接收元素值，接收的次数需要与其他的 goroutine 的数量相同。

```go
func coordinateWithChan() {
    sign := make(chan struct{}, 2)
    num := int32(0)
    fmt.Printf("The number: %d [with chan struct{}]\n", num)
    max := int32(10)
    go addNum(&num, 1, max, func() {
        sign <- struct{}{}
    })
    go addNum(&num, 2, max, func() {
        sign <- struct{}{}
    })
    <-sign
    <-sign
}
```

`coordinateWithChan` 函数中最后的那两行代码了吗？重复的两个接收表达式 `<-sign`，很丑陋。
我们可以选用另外一个同步工具，即：`sync` 包的 `WaitGroup` 类型。它比通道更加适合实现这种一对多的 goroutine 协作流程。

`sync.WaitGroup` 类型（以下简称 `WaitGroup` 类型）是开箱即用的，也是并发安全的。

`WaitGroup` 类型拥有三个指针方法：`Add`、`Done` 和 `Wait`。**你可以想象该类型中有一个计数器，它的默认值是 `0`。我们可
以通过调用该类型值的 `Add` 方法来增加，或者减少这个计数器的值**。

**一般情况下，我会用这个方法来记录需要等待的 goroutine 的数量。相对应的，这个类型的 `Done` 方法，用于对其所属值中计数器
的值进行减一操作**。我们可以在需要等待的 goroutine 中，通过 `defer` 语句调用它。

而**此类型的 `Wait` 方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零**。

改造版本：

```go
func coordinateWithWaitGroup() {
 var wg sync.WaitGroup
 wg.Add(2)
 num := int32(0)
 fmt.Printf("The number: %d [with sync.WaitGroup]\n", num)
 max := int32(10)
 go addNum(&num, 3, max, wg.Done)
 go addNum(&num, 4, max, wg.Done)
 wg.Wait()
}
```

**尽量不要在 `go` 函数内部调用 `Add`，以免 `Add` 还未执行，`Wait` 已经退出**：

```go
var wg sync.WaitGroup
go func(){
 wg.Add(1)
 fmt.Println("test")
}()

wg.Wait()
fmt.Println("exit.")
```

### sync.WaitGroup 类型值中计数器的值可以小于 0 吗

不可以。**小于 0，会引发一个 panic**。

**`WaitGroup` 值是可以被复用的，但需要保证其计数周期的完整性**。这里的计数周期指的是这样一个过程：该值中的计数器值由 0 变为
了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了 0。

如果在一个此类值的 `Wait` 方法被执行期间，跨越了两个计数周期，那么就会引发一个 panic。

### 使用注意

- 不要把增加其计数器值的操作和调用其 `Wait` 方法的代码，放在不同的 goroutine 中执行。换句话说，要**杜绝对同一个
`WaitGroup` 值的两种操作的并发执行**。

## sync.Once

与 `sync.WaitGroup` 类型一样，`sync.Once` 类型（以下简称 `Once` 类型）也属于结构体类型，同样也是开箱即用和并发安全的。
由于这个类型中包含了一个 `sync.Mutex` 类型的字段，所以，复制该类型的值也会导致功能的失效。

```go
var loadIconsOnce sync.Once
var icons map[string]image.Image
// Concurrency-safe.
func Icon(name string) image.Image {
  loadIconsOnce.Do(loadIcons)
  return icons[name]
}
```

`Once` 类型的 `Do` 方法只接受一个参数，这个参数的类型必须是 `func()`，即：无参数声明和结果声明的函数。该方法的功能并
不是对每一种参数函数都只执行一次，而是只**执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数**。

所以，**如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个 `sync.Once` 类型的值**（以下简称 `Once` 值）。

`Once` 类型中还有一个名叫 `done` 的 `uint32` 类型的字段。**它的作用是记录其所属值的 `Do` 方法被调用的次数。不过，该字段的值
只可能是 0 或者 1。一旦 `Do` 方法的首次调用完成，它的值就会从 0 变为 1**。

**既然 `done` 字段的值不是 0 就是 1，那为什么还要使用需要四个字节的 `uint32` 类型呢**？

原因很简单，因为对它的操作必须是“原子”的。`Do` 方法在一开始就会通过调用 `atomic.LoadUint32` 函数来获取该字段的值，并且一旦
发现该值为 1 就会直接返回。这也初步保证了“`Do` 方法，只会执行首次被调用时传入的函数”。

### Do 方法在功能方面的两个特点

- 由于 `Do` 方法只会在参数函数执行结束之后把 `done` 字段的值变为 1，因此，如果参数函数的执行需要很长时间或者根本就不会结束
（比如执行一些守护任务），那么就有可能会导致相关 goroutine 的同时阻塞
- `Do` 方法在参数函数执行结束后，对 `done` 字段的赋值用的是原子操作，并且，这一操作是被挂在 `defer` 语句中的。因此，不论参数
函数的执行会以怎样的方式结束，`done` 字段的值都会变为 1。

## context.Context 类型

使用 `WaitGroup` 值的时候，我们最好用**先统一 `Add`，再并发 `Done`，最后 `Wait`** 的标准模式来构建协作流程。如果在调用
该值的 `Wait` 方法的同时，为了增大其计数器的值，而并发地调用该值的 `Add` 方法，那么就很可能会引发 panic。

但是**如果，我们不能在一开始就确定执行子任务的 goroutine 的数量，那么使用 `WaitGroup` 值来协调它们和分发子任务的 goroutine，就是有一定风险的**。一个解决方案是：**分批地启用执行子任务的 goroutine**。

只要我们在严格遵循上述规则的前提下，分批地启用执行子任务的 goroutine，就肯定不会有问题。

```go
func coordinateWithWaitGroup() {
    total := 12
    stride := 3
    var num int32
    fmt.Printf("The number: %d [with sync.WaitGroup]\n", num)
    var wg sync.WaitGroup
    for i := 1; i <= total; i = i + stride {
        wg.Add(stride)
        for j := 0; j < stride; j++ {
            go addNum(&num, i+j, wg.Done)
        }
        wg.Wait()
    }
    fmt.Println("End.")
}
```

### 使用 `context` 包中的程序实体，实现一对多的 goroutine 协作流程

用 `context` 包中的函数和 `Context` 类型作为实现工具，实现 `coordinateWithContext` 的函数。这个函数应该具有上
面 `coordinateWithWaitGroup` 函数相同的功能。

```go
func coordinateWithContext() {
 total := 12
 var num int32
 fmt.Printf("The number: %d [with context.Context]\n", num)
 cxt, cancelFunc := context.WithCancel(context.Background())
 for i := 1; i <= total; i++ {
  go addNum(&num, i, func() {
   if atomic.LoadInt32(&num) == int32(total) {
    cancelFunc()
   }
  })
 }
 <-cxt.Done()
 fmt.Println("End.")
}
```

先后调用了 `context.Background` 函数和 `context.WithCancel` 函数，并得到了一个可撤销的 `context.Context` 类型的值
（由变量 `cxt` 代表），以及一个 `context.CancelFunc`类型的撤销函数（由变量 `cancelFunc` 代表）。

注意我给予 `addNum` 函数的最后一个参数值。它是一个匿名函数，其中只包含了一条 `if` 语句。这条 `if` 语句会**原子地**加载
 `num` 变量的值，并判断它是否等于 `total` 变量的值。

如果两个值相等，那么就调用 `cancelFunc` 函数。其含义是，如果所有的 `addNum` 函数都执行完毕，那么就立即通知分发子任务
的 goroutine。

**这里分发子任务的 goroutine，即为执行 `coordinateWithContext` 函数的 goroutine**。它在执行完 `for` 语句后，会
立即调用 `cxt` 变量的 `Done` 函数，并试图针对该函数返回的通道，进行接收操作。

一旦 `cancelFunc` 函数被调用，针对该通道的接收操作就会马上结束，所以，这样做就可以实现“等待所有的 `addNum` 函数都执
行完毕”的功能。

### context.Context 类型

`Context` 类型的值（以下简称 `Context` 值）是可以繁衍的，这意味着我们可以通过一个 `Context` 值产生出任意个子值。这些子值
可以携带其父值的属性和数据，也可以响应通过其父值传达的信号。

正因为如此，所有的 `Context` 值共同构成了一颗代表了上下文全貌的树形结构。这棵树的**树根（或者称上下文根节点）是一个已经
在 `context` 包中预定义好的 `Context` 值**，它是**全局唯一**的。通过调用 `context.Background` 函数，我们就可以获取到
它（在 `coordinateWithContext` 函数中就是这么做的）。

注意一下，这个**上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能**。也就是说，它既不可以被撤销（`cancel`），
也不能携带任何数据。

`context` 包中还包含了**四个用于繁衍 `Context` 值的函数，即：`WithCancel`、`WithDeadline`、`WithTimeout` 和 `WithValue`**。

这些函数的第一个参数的类型都是 `context.Context`，而名称都为 `parent`。顾名思义，**这个位置上的参数对应的都是它们将会产生
的 `Context` 值的父值**。

**`WithCancel` 函数用于产生一个可撤销的 parent 的子值**。

在 `coordinateWithContext` 函数中，通过调用该函数，获得了一个衍生自上下文根节点的 `Context` 值，和一个用于触发撤销信号的函数。

`WithDeadline` 函数和 `WithTimeout` 函数则都可以被用来产生一个会**定时撤销**的 `parent` 的子值。至于 `WithValue` 函数，
我们可以通过调用它，产生一个会携带额外数据的 `parent` 的子值。

### “可撤销的”在 context 包中代表着什么？“撤销”一个 Context 值又意味着什么？

这需要从 `Context` 类型的声明讲起。这个接口中有两个方法与“撤销”息息相关。`Done` 方法会返回一个元素类型为 `struct{}` 的接
收通道。不过，这个接收通道的用途并不是传递元素值，而是**让调用方去感知“撤销”当前Context值的那个信号**。

一旦当前的 `Context` 值被撤销，这里的接收通道就会被立即关闭。我们都知道，对于一个未包含任何元素值的通道来说，它的关闭会
使任何针对它的接收操作立即结束。

正因为如此，在 `coordinateWithContext` 函数中，基于调用表达式 `cxt.Done()` 的接收操作，才能够起到感知撤销信号的作用。

### 撤销信号是如何在上下文树中传播的

`context`包的 `WithCancel` 函数在被调用后会产生两个结果值。第一个结果值就是那个可撤销的 `Context` 值，而第二个结果值则是
用于触发撤销信号的函数。

在撤销函数被调用之后，对应的 `Context` 值会先关闭它内部的接收通道，也就是它的 `Done` 方法会返回的那个通道。

然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个 `Context` 值会
断开它与其父值之间的关联。

**通过调用 `context.WithValue` 函数得到的 `Context` 值是不可撤销的**。

### 怎样通过 Context 值携带数据

**`WithValue` 函数在产生新的 `Context` 值（以下简称含数据的 `Context` 值）的时候需要三个参数，即：父值、键和值**。
“字典对于键的约束”类似，这里**键的类型必须是可判等**的。

原因很简单，当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种 `Context` 值并不是用字典来存储键和值的，
后两者只是被简单地存储在前者的相应字段中而已。

## 临时对象池 sync.Pool

 Go 语言标准库中最重要的那几个同步工具，这包括:

- 互斥锁
- 读写锁
- 条件变量
- 原子操作
- `sync/atomic.Value`
- `sync.Once`
- `sync.WaitGroup`
- `context.Context`

Go 语言标准库中的还有另一个同步工具：`sync.Pool`。

`sync.Pool` 类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与 Go 语言的很多同步工具一样，`sync.Pool` 类型也属
于结构体类型，它的值在被真正使用之后，就不应该再被复制了。

**临时对象**的意思是：不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在
任何时候发生，并且完全不会影响到程序的功能。

**我们可以把临时对象池当作针对某种数据的缓存来用**。

`sync.Pool` 类型只有两个方法——`Put` 和 `Get`。前者用于在当前的池中存放临时对象，它接受一个 `interface{}` 类型的参数；
而后者则被用于从当前的池中获取临时对象，它会返回一个 `interface{}` 类型的值。

更具体地说，**这个类型的 `Get` 方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，
那么这个方法就会使用当前池的 `New` 字段创建一个新值，并直接将其返回**。

`sync.Pool` 类型的 `New` 字段代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：`func() interface{}`。
**初始化这个池的时候最好给定它**。

这个函数是 `Get` 方法最后的临时对象获取手段。`Get` 方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结
值并不会被存入当前的临时对象池中，而是直接返回给 `Get` 方法的调用方。

**临时对象池中存储的每一个值都应该是独立的、平等的和可重用的**。`sync.Pool` 的定位不是做类似连接池的东西，它的用途仅仅是增加
对象重用的几率，减少 gc 的负担。因为 gc 带来了编程的方便但同时也增加了运行时开销，使用不当甚至会严重影响程序的性能。因此性能
要求高的场景不能任意产生太多的垃圾。如何解决呢？那就是要重用对象了。

一个比较好的例子是 `fmt` 包，`fmt` 包总是需要使用一些 `[]byte` 之类的对象，golang 建立了一个临时对象池，存放着这些对象，
如果需要使用一个 `[]byte`，就去 `Pool` 里面拿，如果拿不到就分配一份。这比起不停生成新的 `[]byte`，用完了再等待 gc 回收
来要高效得多。

`sync.Pool` 缓存对象的期限是很诡异的，先看一下 `src/pkg/sync/pool.go` 里面的一段实现代码：

```go
func init() {
    runtime_registerPoolCleanup(poolCleanup)
}
```

可以看到 `pool` 包在 `init` 的时候注册了一个 `poolCleanup` 函数，它会清除所有的 `pool` 里面的所有缓存的对象，该函数注册进去
之后会在每次 gc 之前都会调用，因此 **`sync.Pool` 缓存的期限只是两次gc之间这段时间**。

## sync.Map

Go 语言自带的字典类型 `map` 并不是并发安全的。换句话说，在同一时间段内，让不同 goroutine 中的代码，对同一个字典进行读写操
作是不安全的。

Go 语言官方终于在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型 `sync.Map`。

使用 `sync.Map` 可以显著地减少锁的争用。`sync.Map` 本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。

**使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个 CPU 核心的情况下**。

由于**并发安全字典内部使用的存储介质正是原生字典，又因为它使用的原生字典键类型也是可以包罗万象的 `interface{}`，所以，
我们绝对不能带着任何实际类型为函数类型、字典类型或切片类型的键值去操作并发安全字典**。

因为**这些键值的实际类型只有在程序运行期间才能够确定，所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类
型肯定会引发 panic**。

**因此，我们在这里首先要做的一件事就是：一定不要违反上述规则。我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际
类型。无论是存、取还是删，都应该如此**。

> **更好的做法是，把针对同一个并发安全字典的这几种操作都集中起来，然后统一地编写检查代码。除此之外，把并发安全字典封装在一
个结构体类型中，往往是一个很好的选择**。如果你实在拿不准，那么可以先通过调用 `reflect.TypeOf` 函数得到一个键值对应的反射类
型值（即：`reflect.Type` 类型的值），然后再调用这个值的 `Comparable` 方法，得到确切的判断结果。

### 并发安全字典如何做到尽量避免使用锁

`sync.Map` 类型在内部使用了**大量的原子操作来存取键和值，并使用了两个原生的 map 作为存储介质**。

其中一个原生 map 被存在了 `sync.Map` 的 `read` 字段中，该字段是 `sync/atomic.Value` 类型的。简称它为**只读字典**。

**只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值**。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键
的集合而言的。

由 `read` 字段的类型可知，`sync.Map` 在替换只读字典的时候根本用不着锁。另外，这个只读字典在存储键值对的时候，还在值之上
封装了一层。

它先把值转换为了 `unsafe.Pointer` 类型的值，然后再把后者封装，并储存在其中的原生字典中。如此一来，在变更某个键所对应的值
的时候，就也可以使用原子操作了。

`sync.Map` 中的另一个原生字典由它的 `dirty` 字段代表。它存储键值对的方式与 `read` 字段中的原生字典一致，它的键类型
也是 `interface{}`，并且同样是把值先做转换和封装后再进行储存的。称为**脏字典**。

> 脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。正如前文所述，
这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。

`sync.Map` 在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定**只读字典中没有，但脏
字典中可能会有这个键**的时候，它才会在锁的保护下去访问脏字典。

相对应的，`sync.Map` 在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并
直接返回，这种情况下也不需要用到锁。

否则，它才会在锁的保护下把键值对存储到脏字典中。这个时候，该键值对的“已删除”标记会被抹去。

只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。
这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。在查找和遍历键值对的时候，已被逻
辑删除的键值对永远会被无视。

最后，`sync.Map` 会把该键值对中指向值的那个指针置为 `nil` ，这是另一种逻辑删除的方式。

除此之外，还有一个细节需要注意，只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，`sync.Map` 会把
脏字典直接作为只读字典，保存在它的 `read` 字段中，然后把代表脏字典的 `dirty` 字段的值置为 `nil`。

在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。
理所当然，这些转换操作肯定都需要在锁的保护下进行。

**`sync.Map` 的只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同**。

可以看出，在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。在几个写操作当中，新增键值对的操作对并发安
全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。

如果被操作的键值对已经存在于 `sync.Map` 的只读字典中，并且没有被逻辑删除，那么修改它并不会使用到锁，对其性能的影响就会很小。

## 竞争检查器

在 `go build`，`go run` 或者 `go test` 命令后面加上 `-race`，就会使编译器创建一个你的应用的“修改”版。

会记录下每一个读或者写共享变量的 goroutine 的身份信息。记录下所有的同步事件，比如 `go` 语句，`channel` 操作，
以及对 `(*sync.Mutex).Lock`，`(*sync.WaitGroup).Wait` 等等的调用。

由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的
工作来说还是可以接受的。
