---
title: 包
---
# 包
Go 语言的包与其他语言的 `modules` 或者 `libraries` 类似。Go 语言有超过 100个 的标准包，可以使用
 `go list std | wc -l` 查看包的数量。

更多 Go 语言开源包，可以在 [这里](http://godoc.org) 搜索。

Go 语言编译速度很快，主要依赖下面三点：
1. 导入的包必须在文件的头部显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。
2. 禁止包的循环依赖，每个包可以被独立编译，而且很可能是被并发编译。
3. 编译后包的目标文件不仅仅记录包本身的导出信息，同时还记录了包的依赖关系。
因此，在**编译一个包的时候，编译器只需读取每个导入包的目标文件，而不需要遍历所有依赖的的文件**。

## import
在 `package` 声明下面，我们需要导入一系列需要使用的包。比如 `import "fmt"`。注意如果导入了不需要的包，或者缺少了必要的包，
编译会失败。
```go
// 导入一个包
import "fmt"

// 导入多个
import (
  "fmt"
  "os"
)
```

## main
`main` 是一个特殊的包，`main` 包代表一个独立运行的程序，而不是一个 `modules` 或者 `libraries`。`main` 包里
必须有 `main` 函数，这个是程序的入口函数，并且 `mian` 函数没有参数。比如：
```go
func main() {
	fmt.Println("Hello, 世界")
}
```

### hello world
```go
package main

import "fmt"

func main() {
	fmt.Println(x)
}
```
**函数声明使用 `func` 关键字。Go 不需要在语句或者声明的末尾添加分号。除非一行代码上有多条语句。**

## 点操作
```go
 import(
    . "fmt"
 )
```
这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的 `fmt.Println("hello world")`
可以省略的写成 `Println("hello world")`。

### 导入包重命名
如果导入两个相同名字的包，如 `math/rand` 包和 `crypto/rand` 包，可以为一个包重命名来解决名字冲突：
```go
import (
    "crypto/rand"
    mrand "math/rand" // alternative name mrand avoids conflict
)
```
注意，重命名的包名只在当前源文件有效。

有些情况下也可以使用包重命名：
1. 包名很长。重命名一个简短的包名。
2. 与变量名冲突。

选择用简短名称重命名导入包时候最好统一，以避免包名混乱。

### 匿名导入
比如 `import _ "image/png"`，`_` 是空白标识符，不能被访问。
匿名导入有什么用？我们知道如果导入一个包而不使用会导致编译错误 `unused import`。当我们想要导入包，
仅仅只是想计算导入包的包级变量的初始化表达式和执行导入包的 `init` 初始化函数，就可以使用匿名导入。

### 声明所属的代码包与其所在目录的名称不同时
源码文件所在的目录相对于 `src` 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它
声明所属的代码包名称对应。为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。

## 包声明
包声明语句（包名）必须在每个源文件的开头。被其它包导入时默认的标识符。每个包都对应一个独立的名字空间，
如：`image` 包和 `unicode/utf16` 包中都包含了 `Decode`。要在外部引用该函数，必须显式使用 `image.Decode` 或 
`utf16.Decode` 形式访问。

**包内以大写字母开头定义的名字（包括变量，类型，函数等等），会被导出，可以在包的外部访问。**

默认包名一般采用导入路径名的最后一段，比如 `GOPTAH/src/packages/test` 的 `test` 就是包名。三种情况例外：
1. `main` 包，`go build` 命令编译完之后生成一个可执行程序。
2. 以 `_test` 为后缀包名的测试外部扩展包都由 `go test` 命令独立编译。(以 `_` 或 `.` 开头的源文件会被构建工具忽略)
3. 如 `gopkg.in/yaml.v2`。包的名字包含版本号后缀 `.v2`，这种情况下包名是 `yaml`。

## 包命名
包命名尽量有描述性且无歧义，简短，避免冲突。

## 初始化包
包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
```go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
```
如果包中含有多个源文件，构建工具首先会将 `.go` 文件根据文件名排序，然后依次调用编译器编译。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，
那么在 p 包初始化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，`main` 包最后被初始化。以这种方式，
可以确保在 `main` 函数执行之前，所有依赖的包都已经完成初始化工作了。

### 使用 `init` 函数
使用 `init` 函数来简化初始化工作，`init` 函数和普通函数类似，但是不能被调用或引用。
程序开始执行时按照它们声明的顺序自动调用。
`init` 函数不能有任何的参数和返回值，虽然一个 `package` 里面可以写任意多个 `init` 函数，但这无论是对于可读性还是以后的可维护性来说，
我们都强烈建议用户在一个 `package` 中每个文件只写一个 `init` 函数。

程序的初始化和执行都起始于 `main` 包。如果 `main` 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，
那么它只会被导入一次（例如很多包可能都会用到 `fmt` 包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了
其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 `init` 函数（如果有的话），依次类推。等所有
被导入的包都加载完毕了，就会开始对 `main` 包中的包级常量和变量进行初始化，然后执行 `main` 包中的 `init` 函数（如果存在的话），最后
执行 `main` 函数。