<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="数值类型 # 整型 # uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数 # float32 和 float64 的算术规范由 IEEE-754 浮点数国际标准定义。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="基础据类型"><meta property="og:description" content="数值类型 # 整型 # uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数 # float32 和 float64 的算术规范由 IEEE-754 浮点数国际标准定义。"><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-06T14:16:11+08:00"><title>基础据类型 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.b61ba6d90760fd8612220baf974a489819ffb4f242eaac5d0fddce0aa273deaf.js integrity="sha256-thum2Qdg/YYSIguvl0pImBn/tPJC6qxdD93OCqJz3q8=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/ class=active>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li><li><a href=/golang-learn/docs/advance/04_netpooler/>网络轮询器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>基础据类型</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#数值类型>数值类型</a><ul><li><a href=#整型>整型</a></li><li><a href=#浮点数>浮点数</a></li><li><a href=#复数>复数</a></li><li><a href=#其他数值类型>其他数值类型</a></li></ul></li><li><a href=#布尔类型>布尔类型</a></li><li><a href=#字符串>字符串</a><ul><li><a href=#字符串拼接>字符串拼接</a></li><li><a href=#类型转换>类型转换</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=数值类型>数值类型
<a class=anchor href=#%e6%95%b0%e5%80%bc%e7%b1%bb%e5%9e%8b>#</a></h2><h3 id=整型>整型
<a class=anchor href=#%e6%95%b4%e5%9e%8b>#</a></h3><ul><li><code>uint</code>，无符号 32 或 64 位整型</li><li><code>uint8</code>，无符号 8 位整型 (0 到 255)</li><li><code>uint16</code>，无符号 16 位整型 (0 到 65535)</li><li><code>uint32</code>，无符号 32 位整型 (0 到 4294967295)</li><li><code>uint64</code>，无符号 64 位整型 (0 到 18446744073709551615)</li><li><code>int</code>，有符号 32 或 64 位整型</li><li><code>int8</code>，有符号 8 位整型 (-128 到 127)</li><li><code>int16</code>，有符号 16 位整型 (-32768 到 32767)</li><li><code>int32</code>，有符号 32 位整型 (-2147483648 到 2147483647)</li><li><code>int64</code>，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</li></ul><p><code>int</code> 和 <code>uint</code> 对应的是 CPU 平台机器的字大小。</p><h3 id=浮点数>浮点数
<a class=anchor href=#%e6%b5%ae%e7%82%b9%e6%95%b0>#</a></h3><p><code>float32</code> 和 <code>float64</code> 的算术规范由 IEEE-754 浮点数国际标准定义。</p><ul><li><code>float32</code>，32 位浮点型数，<code>math.MaxFloat32</code> 表示 <code>float32</code> 能表示的最大数值，大约是 <code>3.4e38</code>。</li><li><code>float64</code>，64 位浮点型数，<code>math.MaxFloat64</code> 表示 <code>float64</code> 能表示的最大数值，大约是 <code>1.8e308</code>。</li></ul><h3 id=复数>复数
<a class=anchor href=#%e5%a4%8d%e6%95%b0>#</a></h3><ul><li><code>complex64</code>，对应 <code>float32</code> 浮点数精度。</li><li><code>complex128</code>，对应 <code>float64</code> 浮点数精度。</li></ul><p>内置 <code>complex</code> 函数创建复数。标准库 <code>math/cmplx</code> 提供了处理复数的函数。</p><h3 id=其他数值类型>其他数值类型
<a class=anchor href=#%e5%85%b6%e4%bb%96%e6%95%b0%e5%80%bc%e7%b1%bb%e5%9e%8b>#</a></h3><ul><li><strong><code>byte</code>，<code>uint8</code>的别名</strong>，一般用于强调数值是一个原始的数据而不是一个小的整数。</li><li><strong><code>rune</code>，<code>int32</code>的别名</strong>，通常用于表示一个 <code>Unicode</code> 码点。</li><li><code>uintptr</code>，无符号整型，没有指定具体的 <code>bit</code> 大小，用于存放一个指针。</li></ul><h2 id=布尔类型>布尔类型
<a class=anchor href=#%e5%b8%83%e5%b0%94%e7%b1%bb%e5%9e%8b>#</a></h2><p>布尔类型的值只有两种：<code>true</code> 和 <code>false</code>。</p><h2 id=字符串>字符串
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h2><p>字符串实际上是由<strong>字符组成的数组</strong>，C 语言中的字符串使用字符数组 <code>char[]</code> 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 中的字符串只是一个<strong>只读的字节数组</strong>。</p><p>字符串的结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/reflect/value.go#L1983
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>StringHeader</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Data</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Len</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>与切片的结构体很像，只不过少了一个容量 <code>Cap</code>。</p><p>因为字符串是一个只读的类型，不可以直接向字符串直接追加元素改变其本身的内存空间，所有在<strong>字符串上的写入操作都是通过拷贝实现的</strong>。</p><h3 id=字符串拼接>字符串拼接
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%8b%bc%e6%8e%a5>#</a></h3><p>拼接字符串的几种方式：</p><h4 id=-拼接字符串><code>+</code> 拼接字符串
<a class=anchor href=#-%e6%8b%bc%e6%8e%a5%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h4><p>例如 <code>fmt.Println("hello" + s[5:])</code> 输出 <code>"hello, world"</code>。这种方式每次运算都会产生一个新的字符串，需要重新分配内存，会给内存分配和 GC 带来额外的负担，所以性能比较差。</p><h4 id=fmtsprintf>fmt.Sprintf
<a class=anchor href=#fmtsprintf>#</a></h4><p><code>fmt.Sprintf()</code> 拼接字符串，内部使用 <code>[]byte</code> 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 <code>interface</code>，所以性能一般。</p><h4 id=stringsjoin>strings.Join
<a class=anchor href=#stringsjoin>#</a></h4><p><code>strings.Join()</code> 拼接字符串，<code>Join</code> 会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造
这个数据的代价也不小。</p><h4 id=bytesbuffer>bytes.Buffer
<a class=anchor href=#bytesbuffer>#</a></h4><p>利用 <code>bytes.Buffer</code> 拼接字符串，是比较理想的一种方式。对内存的增长有优化，如果能预估字符串的长度，还可以用 <code>buffer.Grow()</code> 接口来设置 <code>capacity</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buffer</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;, &#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;world&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Print</span>(<span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>String</span>())
</span></span></code></pre></div><h4 id=stringsbuilder>strings.Builder
<a class=anchor href=#stringsbuilder>#</a></h4><p><code>strings.Builder</code> 内部通过 <code>slice</code> 来保存和管理内容。<code>strings.Builder</code> 是非线程安全，性能上和 <code>bytes.Buffer</code> 相差无几。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b1</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Builder</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>b1</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;ABC&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>b1</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;DEF&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Print</span>(<span style=color:#a6e22e>b1</span>.<span style=color:#a6e22e>String</span>())
</span></span></code></pre></div><h3 id=类型转换>类型转换
<a class=anchor href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2>#</a></h3><p>在日常开发中，<code>string</code> 和 <code>[]byte</code> 之间的转换是很常见的，不管是 <code>string</code> 转 <code>[]byte</code> 还是 <code>[]byte</code> 转 <code>string</code> 都需要拷贝数据，而内存拷贝带来的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/8dd84e00e28127fae659507809861bef11ae174f title='Last modified by PengQi Shi | November 6, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 6, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/basic/01_basic_type.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#数值类型>数值类型</a><ul><li><a href=#整型>整型</a></li><li><a href=#浮点数>浮点数</a></li><li><a href=#复数>复数</a></li><li><a href=#其他数值类型>其他数值类型</a></li></ul></li><li><a href=#布尔类型>布尔类型</a></li><li><a href=#字符串>字符串</a><ul><li><a href=#字符串拼接>字符串拼接</a></li><li><a href=#类型转换>类型转换</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>