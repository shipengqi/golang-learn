<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>⚡ 并发编程 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/</link><description>Recent content in ⚡ 并发编程 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/docs/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>互斥锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</guid><description>互斥锁 # Go 的标准库 sync 提供了两种锁类型：sync.Mutex 和 sync.RWMutex，前者是互斥锁（排他锁），后者是读写锁。
互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。
Go 定义的锁接口只有两个方法：
type Locker interface { Lock() // 请求锁 Unlock() // 释放锁 } 使用 # import &amp;#34;sync&amp;#34; var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() defer mu.Unlock() balance = balance + amount } func Balance() int { mu.Lock() defer mu.Unlock() b := balance return b } 当已经有 goroutine 调用 Lock 方法获得了这个锁，再有 goroutine 请求这个锁就会阻塞在 Lock 方法的调用上， 直到持有这个锁的 goroutine 调用 UnLock 释放这个锁。</description></item><item><title>读写锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</guid><description>读写锁 # 读写互斥锁 sync.RWMutex 是细粒度的互斥锁，一般来说有几种情况：
读锁之间不互斥 写锁之间是互斥的 写锁与读锁是互斥的 sync.RWMutex 类型中的 Lock 方法和 Unlock 方法用于对写锁进行锁定和解锁，RLock 方法和 RUnlock 方法则分别用于对读锁进行锁定和解锁。
原理 # type RWMutex struct { w Mutex // 复用互斥锁提供的能力，解决多个 writer 的竞争 writerSem uint32 // writer 的信号量 readerSem uint32 // reader 的信号量 readerCount atomic.Int32 // 正在执行的 reader 的数量 readerWait atomic.Int32 // 当写操作被阻塞时需要等待 read 完成的 reader 的数量 } const rwmutexMaxReaders = 1 &amp;lt;&amp;lt; 30 rwmutexMaxReaders：定义了最大的 reader 数量。
RLock 和 RUnlock # 移除了 race 等无关紧要的代码：</description></item><item><title>WaitGroup</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</guid><description>WaitGroup # sync.WaitGroup 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。
使用 # 并发发送 HTTP 请求的示例：
requests := []*Request{...} wg := &amp;amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r) }(request) } wg.Wait() WaitGroup 提供了三个方法：
Add：用来设置 WaitGroup 的计数值。 Done：用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。 Wait：调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。 不要把 Add 和 Wait 方法的调用放在不同的 goroutine 中执行，以免 Add 还未执行，Wait 已经退出：
var wg sync.WaitGroup go func(){ wg.</description></item><item><title>条件变量</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</guid><description>条件变量 # Go 标准库提供了条件变量 sync.Cond 它可以让一组的 goroutine 都在满足特定条件时被唤醒。
sync.Cond 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 for {} 进行忙碌等待相比，sync.Cond 能够让出处理器的使用权，提高 CPU 的利用率。
sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么？
互斥锁 sync.Mutex 通常用来保护临界区和共享资源，条件变量 sync.Cond 用来协调想要访问共享资源的 goroutine。
sync.Cond 经常用在多个 goroutine 等待，一个 goroutine 通知的场景。
比如有一个 goroutine 在异步地接收数据，剩下的多个 goroutine 必须等待这个协程接收完数据，才能读取到正确的数据。这个时候，就需要有个全局的变量来标志第一 个 goroutine 数据是否接受完毕，剩下的 goroutine，反复检查该变量的值，直到满足要求。
当然也可以创建多个 channel，每个 goroutine 阻塞在一个 channel 上，由接收数据的 goroutine 在数据接收完毕后，逐个通知。但是这种方式更复杂一点。
使用 # NewCond 用来创建 sync.Cond 实例，sync.Cond 暴露了几个方法：
Broadcast 用来唤醒所有等待条件变量的 goroutine，无需锁保护。 Signal 唤醒一个 goroutine。 Wait 调用 Wait 会自动释放锁，并挂起调用者所在的 goroutine，也就是当前 goroutine 会阻塞在 Wait 方法调用的地方。如果其他 goroutine 调用了 Signal 或 Broadcast 唤醒 了该 goroutine，那么 Wait 方法在结束阻塞时，会重新加锁，并且继续执行 Wait 后面的代码。 var status int64 func main() { c := sync.</description></item><item><title>Once</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</guid><description>Once # Go 标准库中 sync.Once 可以保证 Go 程序运行期间的某段代码只会执行一次。常常用于单例对象的初始化场景。
使用 # sync.Once 只有一个对外唯一暴露的方法 Do，可以多次调用，但是只第一次调用时会执行一次。
func main() { o := &amp;amp;sync.Once{} for i := 0; i &amp;lt; 10; i++ { o.Do(func() { fmt.Println(&amp;#34;only once&amp;#34;) }) } } 运行：
$ go run main.go only once 原理 # sync.Once 的实现：
// src/sync/once.go type Once struct { done uint32 m Mutex } func (o *Once) Do(f func()) { // 如果传入的参数 f 已经执行过，直接返回 if atomic.LoadUint32(&amp;amp;o.done) == 0 { o.</description></item><item><title>Pool</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</guid><description>Pool # Go 从 1.3 版本开始提供了对象重用的机制，即 sync.Pool。sync.Pool 用来保存可以被重复使用的临时对象，避免了重复创建和销毁临时对象带来的消耗，降低 GC 压力，提高性能。
sync.Pool 是可伸缩的，也是并发安全的。可以在多个 goroutine 中并发调用 sync.Pool 存取对象。
使用 # var buffers = sync.Pool{ New: func() interface{} { return new(bytes.Buffer) }, } func GetBuffer() *bytes.Buffer { return buffers.Get().(*bytes.Buffer) } func PutBuffer(buf *bytes.Buffer) { buf.Reset() buffers.Put(buf) } New：类型是 func() interface{}，用来创建新的元素。 Get：从 Pool 中取出一个元素，如果没有更多的空闲元素，就调用 New 创建新的元素。如果没有设置 New 那么可能返回 nil。 Put：将一个元素放回 Pool 中，使该元素可以重复使用，如果 Put 的值是 nil，会被忽略。
可以先 Put，再 Get 么？ # 不可以。
type item struct { value int } func main() { pool := sync.</description></item><item><title>Context</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</guid><description>Context # Go 1.7 版本中正式引入新标准库 context。主要的作用是在在一组 goroutine 之间传递共享的值、取消信号、deadline 等。
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline — 返回当前 context 的截止时间。 Done — 返回一个只读的 channel，可用于识别当前 channel 是否已经被关闭，其原因可能是到期，也可能是被取消了。多次调用 Done 方法会返回同一个 channel。 Err — 返回当前 context 被关闭的原因。 如果 context 被取消，会返回 Canceled 错误。 如果 context 超时，会返回 DeadlineExceeded 错误。 Value — 返回当前 context 对应所存储的 context信息，可以用来传递请求特定的数据。 创建 context：
Background：创建一个空的 context，一般用在主函数、初始化、测试以及创建 root context 的时候。 TODO：创建一个空的 context，不知道要传递一些什么上下文信息的时候，就用这个。 WithCancel：基于 parent context 创建一个可以取消的新 context。 WithTimeout：基于 parent context 创建一个具有超时时间的新 context。 WithDeadline：和 WithTimeout 一样，只不过参数是截止时间（超时时间加上当前时间）。 WithValue：基于某个 context 创建并存储对应的上下文信息。 最常用的场景，使用 context 来取消一个 goroutine 的运行：</description></item><item><title>原子操作</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</guid><description>原子操作 # Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代 码包 sync/atomic 中。
sync/atomic 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、 存储（store）和交换（swap）。
这些函数针对的数据类型并不多。对这些类型中的每一个，sync/atomic 包都会有一套函数给予支持。这些数据类型有： int32、int64、uint32、uint64、uintptr，以及 unsafe 包中的 Pointer。不过，针对 unsafe.Pointer 类型，该包并未提供进行原子加法操作的函数。
sync/atomic 包还提供了一个名为 Value 的类型，它可以被用来存储任意类型的值。
atomic.AddInt32 函数的第一个参数，为什么不是 int32 而是 *int32 呢？ 因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数， 就已经与函数外的那个值毫无关系了。
所以，传入值本身没有任何意义。unsafe.Pointer 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向 的那个值，所以需要的仍然是指向这个指针值的指针。
只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内 存地址上的数据。
比较并交换操作与交换操作相比有什么不同 # 比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。
所谓的交换指的是，把新值赋给变量，并返回变量的旧值。
CAS 操作用途要更广泛一些。例如，我们将它与 for 语句联用就可以实现一种简易的自旋锁（spinlock）。
for { if atomic.CompareAndSwapInt32(&amp;amp;num2, 10, 0) { fmt.Println(&amp;#34;The second number has gone to zero.&amp;#34;) break } time.Sleep(time.Millisecond * 500) } 在 for 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 for 循环。这就相当于，只要条件未被满足， 当前的流程就会被一直“阻塞”在这里。</description></item><item><title>Channel</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</guid><description>Channel # 使用 channel 实现互斥锁 # 我们可以使用容量只有 1 的 channel 来保证最多只有一个 goroutine 在同一时刻访问一个共享变量：
var ( sema = make(chan struct{}, 1) // a binary semaphore guarding balance balance int ) func Deposit(amount int) { sema &amp;lt;- struct{}{} // acquire lock balance = balance + amount &amp;lt;-sema // release lock } func Balance() int { sema &amp;lt;- struct{}{} // acquire lock b := balance &amp;lt;-sema // release lock return b } Don’t communicate by sharing memory; share memory by communicating.</description></item><item><title>网络轮询器</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/10_netpooler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/10_netpooler/</guid><description>网络轮询器 # epoll
https://segmentfault.com/a/1190000003063859</description></item></channel></rss>