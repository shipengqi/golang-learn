<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go 编译 # 条件编译 # Go 支持两种条件编译方式：
编译标签（build tag） 文件后缀 编译标签 # 编译标签的规则：
空格表示：AND 逗号表示：OR ! 表示：NOT 换行表示：AND 每个条件项的名字用 &ldquo;字母+数字&rdquo; 表示。主要支持以下几种条件：
操作系统，例如：windows、linux 等，对应 runtime.GOOS 的值。 计算机架构，例如：amd64、386，对应 runtime.GOARCH 的值。 编译器，例如：gccgo、gc，是否开启 CGO,cgo。 Go 版本，例如：go1.19、go1.20 等。 自定义的标签，例如：编译时通过指定 -tags 传入的值。 //go:build ignore，编译时自动忽略该文件 go:build 之后必须有空行，否则会被编译器当做普通注释。
//go:build linux,386 darwin,!cgo package testpkg 运算表达式为：(linux && 386) || (darwin && !cgo)。
自定义 tag 只需要在 go build 指令后用 -tags 指定编译条件即可
go build -tags mytag1 mytag2 对于 -tags，多个标签既可以用逗号分隔，也可以用空格分隔，但它们都表示&#34;与&#34;的关系。早期 go 版本用空格分隔，后来改成了用逗号分隔，但空格依然可以识别。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Go 编译"><meta property="og:description" content="Go 编译 # 条件编译 # Go 支持两种条件编译方式：
编译标签（build tag） 文件后缀 编译标签 # 编译标签的规则：
空格表示：AND 逗号表示：OR ! 表示：NOT 换行表示：AND 每个条件项的名字用 &ldquo;字母+数字&rdquo; 表示。主要支持以下几种条件：
操作系统，例如：windows、linux 等，对应 runtime.GOOS 的值。 计算机架构，例如：amd64、386，对应 runtime.GOARCH 的值。 编译器，例如：gccgo、gc，是否开启 CGO,cgo。 Go 版本，例如：go1.19、go1.20 等。 自定义的标签，例如：编译时通过指定 -tags 传入的值。 //go:build ignore，编译时自动忽略该文件 go:build 之后必须有空行，否则会被编译器当做普通注释。
//go:build linux,386 darwin,!cgo package testpkg 运算表达式为：(linux && 386) || (darwin && !cgo)。
自定义 tag 只需要在 go build 指令后用 -tags 指定编译条件即可
go build -tags mytag1 mytag2 对于 -tags，多个标签既可以用逗号分隔，也可以用空格分隔，但它们都表示&#34;与&#34;的关系。早期 go 版本用空格分隔，后来改成了用逗号分隔，但空格依然可以识别。"><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/practice/01_build/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-31T16:48:48+08:00"><title>Go 编译 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.ba0b0d3a0587c533dd25391aa4ba8d81cdb07d80534438536c6592a0da5c5caf.js integrity="sha256-ugsNOgWHxTPdJTkapLqNgc2wfYBTRDhTbGWSoNpcXK8=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础数据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li><li><a href=/golang-learn/docs/concurrency/12_errorgroup/>ErrGroup</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/ class=active>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li></ul></li><li><span>🛠️ Go 工程实践</span><ul><li><a href=/golang-learn/docs/project/01_structure/>项目的目录结构</a></li><li><a href=/golang-learn/docs/project/02_commitizen/>Commit 规范</a></li><li><a href=/golang-learn/docs/project/03_gsemver/>版本规范</a></li><li><a href=/golang-learn/docs/project/04_flow/>Git 工作流程</a></li><li><a href=/golang-learn/docs/project/05_api/>API 风格</a></li><li><a href=/golang-learn/docs/project/06_api_doc/>API 文档</a></li><li><a href=/golang-learn/docs/project/07_make/>make</a></li><li><a href=/golang-learn/docs/project/08_github_actions/>基于 GitHub Actions 的 CI/CD</a></li></ul></li><li><a href=/golang-learn/docs/advance/>🔍 底层原理</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 编译</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#go-编译>Go 编译</a><ul><li><a href=#条件编译>条件编译</a><ul><li><a href=#编译标签>编译标签</a></li><li><a href=#文件后缀>文件后缀</a></li><li><a href=#如何选择编译标签和文件后缀>如何选择编译标签和文件后缀</a></li><li><a href=#build>+build</a></li></ul></li><li><a href=#交叉编译>交叉编译</a></li><li><a href=#编译选项>编译选项</a><ul><li><a href=#gcflags>gcflags</a></li><li><a href=#ldflags>ldflags</a></li></ul></li><li><a href=#内联优化inline>内联优化（inline）</a><ul><li><a href=#内联优化的效果>内联优化的效果</a></li><li><a href=#禁用内联>禁用内联</a></li></ul></li><li><a href=#减小编译体积>减小编译体积</a><ul><li><a href=#使用-upx>使用 upx</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=go-编译>Go 编译
<a class=anchor href=#go-%e7%bc%96%e8%af%91>#</a></h1><h2 id=条件编译>条件编译
<a class=anchor href=#%e6%9d%a1%e4%bb%b6%e7%bc%96%e8%af%91>#</a></h2><p>Go 支持两种条件编译方式：</p><ul><li>编译标签（build tag）</li><li>文件后缀</li></ul><h3 id=编译标签>编译标签
<a class=anchor href=#%e7%bc%96%e8%af%91%e6%a0%87%e7%ad%be>#</a></h3><p>编译标签的规则：</p><ol><li>空格表示：AND</li><li>逗号表示：OR</li><li><code>!</code> 表示：NOT</li><li>换行表示：AND</li></ol><p>每个条件项的名字用 &ldquo;字母+数字&rdquo; 表示。主要支持以下几种条件：</p><ul><li>操作系统，例如：<code>windows</code>、<code>linux</code> 等，对应 <code>runtime.GOOS</code> 的值。</li><li>计算机架构，例如：<code>amd64</code>、<code>386</code>，对应 <code>runtime.GOARCH</code> 的值。</li><li>编译器，例如：<code>gccgo</code>、<code>gc</code>，是否开启 CGO,cgo。</li><li>Go 版本，例如：<code>go1.19</code>、<code>go1.20</code> 等。</li><li>自定义的标签，例如：编译时通过指定 <code>-tags</code> 传入的值。</li><li><code>//go:build ignore</code>，编译时自动忽略该文件</li></ul><p><code>go:build</code> 之后必须有空行，否则会被编译器当做普通注释。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:build linux,386 darwin,!cgo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>testpkg</span>
</span></span></code></pre></div><p>运算表达式为：<code>(linux && 386) || (darwin && !cgo)</code>。</p><p>自定义 tag 只需要在 <code>go build</code> 指令后用 <code>-tags</code> 指定编译条件即可</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go build -tags mytag1 mytag2
</span></span></code></pre></div><p>对于 <code>-tags</code>，多个标签既可以用逗号分隔，也可以用空格分隔，但它们都表示"与"的关系。早期 go 版本用空格分隔，后来改成了用逗号分隔，但空格依然可以识别。</p><p><code>-tags</code> 也有 <code>!</code> 规则，它表示的是没有这个标签。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:build !hello
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go build -tags<span style=color:#f92672>=</span>!hello
</span></span></code></pre></div><h3 id=文件后缀>文件后缀
<a class=anchor href=#%e6%96%87%e4%bb%b6%e5%90%8e%e7%bc%80>#</a></h3><p>这个方法通过改变文件名的后缀来提供条件编译，如果你的源文件包含后缀：<code>_GOOS.go</code>，那么这个源文件只会在这个平台下编译，<code>_GOARCH.go</code> 也是如此。这两个后缀可以结合在一起使用，但是要注意顺序：<code>_GOOS_GOARCH.go</code>， 不能反过来用。
例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mypkg_freebsd_arm.go // only builds on freebsd/arm systems
</span></span><span style=display:flex><span>mypkg_plan9.go       // only builds on plan9
</span></span></code></pre></div><p>文件名必须提供，如果只由后缀的文件名会被编译器忽略：</p><pre tabindex=0><code># 这个文件会被编译器忽略
_linux.go
</code></pre><h3 id=如何选择编译标签和文件后缀>如何选择编译标签和文件后缀
<a class=anchor href=#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e7%bc%96%e8%af%91%e6%a0%87%e7%ad%be%e5%92%8c%e6%96%87%e4%bb%b6%e5%90%8e%e7%bc%80>#</a></h3><p>编译标签和文件后缀的功能上有重叠，例如一个文件名：<code>mypkg_linux.go</code> 包含了 <code>//go:build linux</code> 将会出现冗余</p><p>通常情况下，如果源文件与平台或者 cpu 架构完全匹配，那么使用文件后缀就可以满足，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mypkg_linux.go         // only builds on linux systems
</span></span><span style=display:flex><span>mypkg_windows_amd64.go // only builds on windows 64bit platforms
</span></span></code></pre></div><p>下面的情况，就可以使用编译标签：</p><ul><li>这个源文件可以在超过一个平台或者超过一个 cpu 架构</li><li>需要排除某个平台或架构</li><li>有一些自定义的编译条件</li></ul><h3 id=build>+build
<a class=anchor href=#build>#</a></h3><p><code>// +build</code> 功能和 <code>//go:build</code> 一样。只不过 <code>//go:build</code> 是在 go 1.17 才引入的。与其他现有 Go 指令保持一致，例如 <code>//go:generate</code>。</p><h2 id=交叉编译>交叉编译
<a class=anchor href=#%e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91>#</a></h2><p>Go 可以通过设置环境变量来实现交叉编译，用来在一个平台上生成另一个平台的可执行程序。：</p><pre tabindex=0><code>#  linux amd64
GOOS=linux GOARCH=amd64 go build main.go

# windows amd64
GOOS=windows GOARCH=amd64 go build main.go
</code></pre><p>环境变量 <code>GOOS</code> 设置平台, <code>GOARCH</code> 设置架构。</p><h2 id=编译选项>编译选项
<a class=anchor href=#%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go build <span style=color:#f92672>[</span>-o output<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>-i<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>build flags<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>packages<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li><code>-a</code> 强制重新编译所有包</li><li><code>-n</code> 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的</li><li><code>-p n</code> 指定可以并行可运行的编译数目，默认是 CPU 的数目</li><li><code>-o</code> 指定输出的可执行文件的文件名，可以带路径，例如 <code>go build -o a/b/c</code></li><li><code>-i</code> 安装相应的包，编译并且 <code>go install</code></li><li><code>-race</code> 开启编译的时候自动检测数据竞争的情况，目前只支持 64 位的机器</li><li><code>-v</code> 打印出来我们正在编译的包名</li><li><code>-work</code> 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除</li><li><code>-x</code> 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行</li><li><code>-ccflags 'arg list'</code> 传递参数给 5c, 6c, 8c 调用</li><li><code>-compiler name</code> 指定相应的编译器，gccgo 还是 gc</li><li><code>-gccgoflags 'arg list'</code> 传递参数给 gccgo 编译连接调用</li><li><code>-gcflags 'arg list'</code> 编译器参数</li><li><code>-installsuffix suffix</code> 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，<code>-race</code>的时候默认已经是 <code>-installsuffix race</code>,大家可以通过 <code>-n</code> 命令来验证</li><li><code>-ldflags 'arg list'</code> 链接器参数</li><li><code>-tags 'tag list'</code> 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints</li></ul><h3 id=gcflags>gcflags
<a class=anchor href=#gcflags>#</a></h3><p><code>-gcflags</code> 参数的格式是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-gcflags<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;pattern=arg list&#34;</span>
</span></span></code></pre></div><h4 id=pattern>pattern
<a class=anchor href=#pattern>#</a></h4><p>pattern 是选择包的模式，它可以有以下几种定义:</p><ul><li><code>main</code>: 表示 <code>main</code> 函数所在的顶级包路径</li><li><code>all</code>: 表示 <code>GOPATH</code> 中的所有包。如果是 <code>go modules</code> 模式，则表示主模块和它所有的依赖，包括 <code>test</code> 文件的依赖</li><li><code>std</code>: 表示 Go 标准库中的所有包</li><li><code>...</code>: <code>...</code> 是一个通配符，可以匹配任意字符串(包括空字符串)。<ul><li><code>net/...</code> 表示 net 模块和它的所有子模块</li><li><code>./...</code> 表示当前主模块和所有子模块</li><li>如果 pattern 中包含了 <code>/</code> 和 <code>...</code>，那么就不会匹配 <code>vendor</code> 目录
例如: <code>./...</code> 不会匹配 <code>./vendor</code> 目录。可以使用 <code>./vendor/...</code> 匹配 <code>vendor</code> 目录和它的子模块</li></ul></li></ul><p><code>go help packages</code> 查看模式说明。</p><h4 id=arg-list>arg list
<a class=anchor href=#arg-list>#</a></h4><p>空格分隔，如果编译选项中含有空格，可以使用引号包起来。</p><ul><li><code>-N</code>: 禁止编译器优化</li><li><code>-l</code>: 关闭内联 (<code>inline</code>)</li><li><code>-c</code>: <code>int</code> 编译过程中的并发数，默认是 <code>1</code></li><li><code>-B</code> 禁用越界检查</li><li><code>-u</code> 禁用 unsafe</li><li><code>-S</code> 输出汇编代码</li><li><code>-m</code> 输出优化信息</li></ul><h3 id=ldflags>ldflags
<a class=anchor href=#ldflags>#</a></h3><ul><li><code>-s</code> 禁用符号表</li><li><code>-w</code> 禁用 DRAWF 调试信息</li><li><code>-X</code> 设置字符串全局变量值 <code>-X ver="0.99"</code></li><li><code>-H</code> 设置可执行文件格式 <code>-H windowsgui</code></li></ul><h2 id=内联优化inline>内联优化（inline）
<a class=anchor href=#%e5%86%85%e8%81%94%e4%bc%98%e5%8c%96inline>#</a></h2><p>内联优化就是在编译期间，直接将调用函数的地方替换为函数的实现，它可以减少函数调用的开销（创建栈帧，读写寄存器，栈溢出检测等）以提高程序的性能。因为优化的对象为函数，所以也叫<strong>函数内联</strong>。</p><p>内联是一个递归的过程，一旦一个函数被内联到它的调用者中，编译器就可能将产生的代码内联到它的调用者中，依此类推。</p><p>内联优化示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;inline&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>a</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>b</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>内联优化后：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>a</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;inline&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>b</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;inline&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=内联优化的效果>内联优化的效果
<a class=anchor href=#%e5%86%85%e8%81%94%e4%bc%98%e5%8c%96%e7%9a%84%e6%95%88%e6%9e%9c>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>inlinetest</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> max(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span> &gt; <span style=color:#a6e22e>b</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>max_test.go</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>inlinetest</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Result</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkMax</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> = max(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Result</span> = <span style=color:#a6e22e>r</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在是在禁用内联优化的情况下运行基准测试：</p><pre tabindex=0><code>$ go test -bench=. 
cpu: Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz
BenchmarkMax-12         871122506                1.353 ns/op
</code></pre><p>去掉 <code>//go:noinline</code> 后（可以使用 <code>go build -gcflags="-m -m" main.go</code> 来查看编译器的优化）再次运行基准测试：</p><pre tabindex=0><code>$ go test -bench=. 
cpu: Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz
BenchmarkMax-12         1000000000               0.3534 ns/op
</code></pre><p>对比两次基准测试的结果，<code>1.353ns</code> 和 <code>0.3534ns</code>。打开内联优化的情况下，性能提高了 75%。</p><h3 id=禁用内联>禁用内联
<a class=anchor href=#%e7%a6%81%e7%94%a8%e5%86%85%e8%81%94>#</a></h3><p>Go 编译器默认开启内联优化，可以使用 <code>-gcflags="-l"</code> 来关闭。但是如果传递两个或两个以上的 <code>-l</code> 则会打开内联，并启用更激进的内联策略：</p><ul><li><code>-gcflags="-l -l"</code> 2 级内联</li><li><code>-gcflags="-l -l -l"</code> 3 级内联</li><li><code>gcflags=-l=4</code> 4 级别内联</li></ul><p><code>//go:noinline</code> 编译指令，可以禁用单个函数的内联：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> max(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> &gt; <span style=color:#a6e22e>y</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=减小编译体积>减小编译体积
<a class=anchor href=#%e5%87%8f%e5%b0%8f%e7%bc%96%e8%af%91%e4%bd%93%e7%a7%af>#</a></h2><p>Go 编译器默认编译出来的程序会带有符号表和调试信息，一般来说 release 版本可以去除调试信息以减小二进制体积。</p><p>使用 <code>-w</code> 和 <code>-s</code> 来减少可执行文件的体积。但删除了调试信息后，可执行文件将无法使用 gdb/dlv 调试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go build -ldflags<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-w -s&#34;</span> ./abc.go
</span></span></code></pre></div><h3 id=使用-upx>使用 upx
<a class=anchor href=#%e4%bd%bf%e7%94%a8-upx>#</a></h3><p><a href=https://github.com/upx/upx>upx</a> 是一个常用的压缩动态库和可执行文件的工具，通常可减少 50-70% 的体积。</p><p>下载 <a href=https://github.com/upx/upx/releases>upx</a> 后解压就可以使用了。</p><pre tabindex=0><code># 使用 upx
$ go build -o server main.go &amp;&amp; upx -9 server

# 结合编译选项
go build -ldflags=&#34;-s -w&#34; -o server main.go &amp;&amp; upx -9 server
</code></pre><p>upx 的参数 <code>-9</code> 指的是压缩率，1 代表最低压缩率，9 代表最高压缩率。</p><p>upx 压缩后的程序和压缩前的程序一样，无需解压仍然能够正常地运行，这种压缩方法称之为<strong>带壳压缩</strong>。</p><p>压缩包含两个部分：</p><ul><li>在程序开头或其他合适的地方插入解压代码</li><li>将程序的其他部分压缩</li></ul><p>执行时，也包含两个部分：</p><ul><li>首先执行的是程序开头的插入的解压代码，将原来的程序在内存中解压出来</li><li>再执行解压后的程序。</li></ul><p>也就是说，upx 在程序执行时，会有额外的解压动作，不过这个耗时几乎可以忽略。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/a4eb0f2f6655107302ced27bdcfdc68f4b5920cd title='Last modified by PengQi Shi | October 31, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 31, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/practice/01_build.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#go-编译>Go 编译</a><ul><li><a href=#条件编译>条件编译</a><ul><li><a href=#编译标签>编译标签</a></li><li><a href=#文件后缀>文件后缀</a></li><li><a href=#如何选择编译标签和文件后缀>如何选择编译标签和文件后缀</a></li><li><a href=#build>+build</a></li></ul></li><li><a href=#交叉编译>交叉编译</a></li><li><a href=#编译选项>编译选项</a><ul><li><a href=#gcflags>gcflags</a></li><li><a href=#ldflags>ldflags</a></li></ul></li><li><a href=#内联优化inline>内联优化（inline）</a><ul><li><a href=#内联优化的效果>内联优化的效果</a></li><li><a href=#禁用内联>禁用内联</a></li></ul></li><li><a href=#减小编译体积>减小编译体积</a><ul><li><a href=#使用-upx>使用 upx</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>