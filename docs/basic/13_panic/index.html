<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="panic # Panic 异常 # Go 运行时错误会引起 painc 异常。 一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（defer 机制）。随后，程序崩溃 并输出日志信息。
由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使 用 Go 提供的错误机制，而不是 panic，尽量避免程序的崩溃。
panic 函数 # panic 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 panic。
panic 详情中都有什么 # panic: runtime error: index out of range goroutine 1 [running]: main.main() /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d exit status 2 第一行是 panic: runtime error: index out of range。其中的 runtime error 的含义是，这是一个 runtime 代码包中 抛出的 panic。
goroutine 1 [running]，它表示有一个 ID 为1的 goroutine 在此 panic 被引发的时候正在运行。这里的 ID 其实并不重要。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="panic"><meta property="og:description" content="panic # Panic 异常 # Go 运行时错误会引起 painc 异常。 一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（defer 机制）。随后，程序崩溃 并输出日志信息。
由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使 用 Go 提供的错误机制，而不是 panic，尽量避免程序的崩溃。
panic 函数 # panic 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 panic。
panic 详情中都有什么 # panic: runtime error: index out of range goroutine 1 [running]: main.main() /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d exit status 2 第一行是 panic: runtime error: index out of range。其中的 runtime error 的含义是，这是一个 runtime 代码包中 抛出的 panic。
goroutine 1 [running]，它表示有一个 ID 为1的 goroutine 在此 panic 被引发的时候正在运行。这里的 ID 其实并不重要。"><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/basic/13_panic/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-06T14:16:11+08:00"><title>panic | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.d64093ecf3ff8f5788d85e2c4e0918fa84fa76b64df73c76f264f0831a527e22.js integrity="sha256-1kCT7PP/j1eI2F4sTgkY+oT6drZN9zx28mTwgxpSfiI=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>map</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/ class=active>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li><li><a href=/golang-learn/docs/advance/04_netpooler/>网络轮询器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>panic</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#panic>panic</a><ul><li><a href=#panic-异常>Panic 异常</a><ul><li><a href=#panic-函数>panic 函数</a></li><li><a href=#panic-详情中都有什么>panic 详情中都有什么</a></li><li><a href=#从-panic-被引发到程序终止运行的大致过程是什么>从 panic 被引发到程序终止运行的大致过程是什么</a></li><li><a href=#怎样让-panic-包含一个值以及应该让它包含什么样的值>怎样让 panic 包含一个值，以及应该让它包含什么样的值</a></li></ul></li><li><a href=#recover-捕获异常>Recover 捕获异常</a><ul><li><a href=#正确调用-recover-函数>正确调用 recover 函数</a></li></ul></li><li><a href=#panic-和-recover-原理>panic 和 recover 原理</a><ul><li><a href=#崩溃恢复>崩溃恢复</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=panic>panic
<a class=anchor href=#panic>#</a></h1><h2 id=panic-异常>Panic 异常
<a class=anchor href=#panic-%e5%bc%82%e5%b8%b8>#</a></h2><p>Go 运行时错误会引起 <code>painc</code> 异常。
一般而言，当 <code>panic</code> 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（<code>defer</code> 机制）。随后，程序崩溃
并输出日志信息。</p><p>由于 <code>panic</code> 会引起程序的崩溃，因此 <code>panic</code> 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使
用 Go 提供的错误机制，而不是 <code>panic</code>，尽量避免程序的崩溃。</p><h3 id=panic-函数>panic 函数
<a class=anchor href=#panic-%e5%87%bd%e6%95%b0>#</a></h3><p><code>panic</code> 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 <code>panic</code>。</p><h3 id=panic-详情中都有什么>panic 详情中都有什么
<a class=anchor href=#panic-%e8%af%a6%e6%83%85%e4%b8%ad%e9%83%bd%e6%9c%89%e4%bb%80%e4%b9%88>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>panic: runtime error: index out of range
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>goroutine <span style=color:#ae81ff>1</span> <span style=color:#f92672>[</span>running<span style=color:#f92672>]</span>:
</span></span><span style=display:flex><span>main.main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>/Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d
</span></span><span style=display:flex><span>exit status <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>第一行是 <code>panic: runtime error: index out of range</code>。其中的 <code>runtime error</code> 的含义是，这是一个 <code>runtime</code> 代码包中
抛出的<code> panic</code>。</p><p><code>goroutine 1 [running]</code>，它表示有一个 ID 为1的 goroutine 在此 <code>panic</code> 被引发的时候正在运行。这里的 ID 其实并不重要。</p><p><code>main.main()</code> 表明了这个 goroutine 包装的 go 函数就是命令源码文件中的那个<code>main</code>函数，也就是说这里的 goroutine 正
是<strong>主 goroutine</strong>。</p><p>再下面的一行，指出的就是这个 goroutine 中的哪一行代码在此 panic 被引发时正在执行。含了此行代码在其所属的源码文件中的行数，
以及这个源码文件的绝对路径。</p><p><code>+0x3d</code> 代表的是：此行代码相对于其所属函数的入口程序计数偏移量。用处并不大。</p><p><code>exit status 2</code> 表明我的这个程序是以退出状态码2结束运行的。<strong>在大多数操作系统中，只要退出状态码不是 0，都意味着程序运行的非正
常结束</strong>。在 Go 语言中，<strong>因 panic 导致程序结束运行的退出状态码一般都会是 2</strong>。</p><h3 id=从-panic-被引发到程序终止运行的大致过程是什么>从 panic 被引发到程序终止运行的大致过程是什么
<a class=anchor href=#%e4%bb%8e-panic-%e8%a2%ab%e5%bc%95%e5%8f%91%e5%88%b0%e7%a8%8b%e5%ba%8f%e7%bb%88%e6%ad%a2%e8%bf%90%e8%a1%8c%e7%9a%84%e5%a4%a7%e8%87%b4%e8%bf%87%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88>#</a></h3><p>此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一
级地沿着调用栈的反方向传播至顶端，
也就是我们编写的最外层函数那里。</p><p>这里的最外层函数指的是go函数，对于主 goroutine 来说就是 <code>main</code> 函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。</p><p>随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐
渐地积累和完善，并会在程序终止之前被打印出来。</p><h3 id=怎样让-panic-包含一个值以及应该让它包含什么样的值>怎样让 panic 包含一个值，以及应该让它包含什么样的值
<a class=anchor href=#%e6%80%8e%e6%a0%b7%e8%ae%a9-panic-%e5%8c%85%e5%90%ab%e4%b8%80%e4%b8%aa%e5%80%bc%e4%bb%a5%e5%8f%8a%e5%ba%94%e8%af%a5%e8%ae%a9%e5%ae%83%e5%8c%85%e5%90%ab%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e5%80%bc>#</a></h3><p>其实很简单，在调用 <code>panic</code> 函数时，把某个值作为参数传给该函数就可以了。<code>panic</code> 函数的唯一一个参数是空接口
（也就是<code>interface{}</code>）类型的，所以从语法上讲，它可以接受任何类型的值。</p><p>但是，我们<strong>最好传入 <code>error</code> 类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示
形式转换</strong>。</p><h2 id=recover-捕获异常>Recover 捕获异常
<a class=anchor href=#recover-%e6%8d%95%e8%8e%b7%e5%bc%82%e5%b8%b8>#</a></h2><p>一般情况下，我们不能因为某个处理函数引发的 <code>panic</code> 异常，杀掉整个进程，可以使用 <code>recover</code> 函数恢复 <code>panic</code> 异常。</p><p><code>panic</code> 时会调用 <code>recover</code>，但是 <code>recover</code> 不能滥用，可能会引起资源泄漏或者其他问题。我们可以将 <code>panic value</code> 设置成特
殊类型，来标识某个 <code>panic</code> 是否应该被恢复。<strong><code>recover</code> 只能在 <code>defer</code> 修饰的函数中使用</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>soleTitle</span>(<span style=color:#a6e22e>doc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>html</span>.<span style=color:#a6e22e>Node</span>) (<span style=color:#a6e22e>title</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bailout</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>p</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>nil</span>:       <span style=color:#75715e>// no panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>bailout</span>{}: <span style=color:#75715e>// &#34;expected&#34; panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;multiple title elements&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>                panic(<span style=color:#a6e22e>p</span>) <span style=color:#75715e>// unexpected panic; carry on panicking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>bailout</span>{}) 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码，<code>deferred</code> 函数调用 <code>recover</code>，并检查 <code>panic value</code>。当 <code>panic value</code> 是 <code>bailout{}</code> 类型时，<code>deferred</code> 函数生
成一个 <code>error</code> 返回给调用者。
当 <code>panic value</code> 是其他 <code>non-nil</code> 值时，表示发生了未知的 <code>panic</code> 异常。</p><h3 id=正确调用-recover-函数>正确调用 recover 函数
<a class=anchor href=#%e6%ad%a3%e7%a1%ae%e8%b0%83%e7%94%a8-recover-%e5%87%bd%e6%95%b0>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Enter function main.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 引发 panic。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    panic(<span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;something wrong&#34;</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> recover()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;panic: %s\n&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Exit function main.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码，<code>recover</code> 函数调用并不会起到任何作用，甚至都没有机会执行。因为 panic 一旦发生，控制权就会讯速地沿着调用栈的反方向
传播。所以，<strong>在 panic 函数调用之后的代码，根本就没有执行的机会</strong>。</p><p>先调用 <code>recover</code> 函数，再调用 <code>panic</code> 函数会怎么样呢？
如果在我们调用 <code>recover</code> 函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个 <code>nil</code>。</p><p><strong><code>defer</code> 语句调用 <code>recover</code> 函数才是正确的打开方式</strong>。</p><p>无论函数结束执行的原因是什么，其中的 <code>defer</code> 函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一
个 panic 也会是这样。</p><p>要注意，我们要<strong>尽量把 <code>defer</code> 语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会</strong>。</p><p>注意下面的方式，也是无法捕获 panic 的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;recover: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }()
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    panic(<span style=color:#e6db74>&#34;EDDYCJY.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 <strong><code>panic</code> 发生时，程序会中断运行，并执行在当前 goroutine 中 <code>defer</code> 的函数</strong>，新起一个 goroutine 中的 <code>defer</code>
函数并不会执行。</p><p><strong>注意连续调用 <code>panic</code> 只有最后一个会被 <code>recover</code> 捕获</strong>。</p><h2 id=panic-和-recover-原理>panic 和 recover 原理
<a class=anchor href=#panic-%e5%92%8c-recover-%e5%8e%9f%e7%90%86>#</a></h2><p>panic 能够改变程序的控制流，函数调用panic 时会立刻停止执行函数的其他代码，并在执行结束后在当前 Goroutine 中递归执行调用方的延迟函数调用 defer；
recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥任何作用；</p><ul><li>panic 只会触发当前 Goroutine 的延迟函数调用；</li><li>recover 只有在 defer 函数中调用才会生效；</li><li>panic 允许在 defer 中嵌套多次调用；</li></ul><p>defer 关键字对应的 runtime.deferproc 会将延迟调用函数与调用方所在 Goroutine 进行关联。所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数也是非常合理的。</p><p>多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 panic 时也不应该执行其他 Goroutine 的延迟函数。</p><p>recover 只有在发生 panic 之后调用才会生效。需要在 defer 中使用 recover 关键字。</p><p>多次调用 panic 也不会影响 defer 函数的正常执行。所以使用 defer 进行收尾的工作一般来说都是安全的。</p><p>数据结构 runtime._panic</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_panic</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>argp</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>arg</span>       <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span> <span style=color:#a6e22e>link</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>recovered</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>aborted</span>   <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>pc</span>        <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>sp</span>        <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>goexit</span>    <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>runtime.gopanic，该函数的执行过程包含以下几个步骤：</p><ol><li>创建新的 runtime._panic 结构并添加到所.在 Goroutine_panic 链表的最前面；</li><li>在循环中不断从当前 Goroutine 的 _defer .中链表获取 runtime._defer 并调用 runtime.reflectcall 运行延迟调用函数；</li><li>调用 runtime.fatalpanic 中止整个程序；</li></ol><h3 id=崩溃恢复>崩溃恢复
<a class=anchor href=#%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d>#</a></h3><p>编译器会将关键字 recover 转换成 runtime.gorecover：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gorecover</span>(<span style=color:#a6e22e>argp</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>argp</span> <span style=color:#f92672>==</span> uintptr(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>argp</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果当前 Goroutine 没有调用 panic，那么该函数会直接返回 nil，这也是崩溃恢复在非 defer 中调用会失效的原因。</p><p>在正常情况下，它会修改 runtime._panic 结构体的 recovered 字段，runtime.gorecover 函数本身不包含恢复程序的逻辑，程序的恢复也是由 runtime.gopanic 函数负责的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopanic</span>(<span style=color:#a6e22e>e</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 执行延迟调用函数，可能会设置 p.recovered = true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pc</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>link</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>aborted</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>link</span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sig</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode0</span> = uintptr(<span style=color:#a6e22e>sp</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode1</span> = <span style=color:#a6e22e>pc</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>recovery</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;recovery failed&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器会负责做转换关键字的工作；
将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover；
将 defer 转换成 deferproc 函数；
在调用 defer 的函数末尾调用 deferreturn 函数；
在运行过程中遇到 gopanic 方法时，会从 Goroutine 的链表依次取出 _defer 结构体并执行；
如果调用延迟执行函数时遇到了 gorecover 就会将 _panic.recovered 标记成 true 并返回 panic 的参数；
在这次调用结束之后，gopanic 会从 _defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 recovery 函数进行恢复程序；
recovery 会根据传入的 pc 和 sp 跳转回 deferproc；
编译器自动生成的代码会发现 deferproc 的返回值不为 0，这时会跳回 deferreturn 并恢复到正常的执行流程；
如果没有遇到 gorecover 就会依次遍历所有的 _defer 结构，并在最后调用 fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/8dd84e00e28127fae659507809861bef11ae174f title='Last modified by PengQi Shi | November 6, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 6, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/basic/13_panic.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#panic>panic</a><ul><li><a href=#panic-异常>Panic 异常</a><ul><li><a href=#panic-函数>panic 函数</a></li><li><a href=#panic-详情中都有什么>panic 详情中都有什么</a></li><li><a href=#从-panic-被引发到程序终止运行的大致过程是什么>从 panic 被引发到程序终止运行的大致过程是什么</a></li><li><a href=#怎样让-panic-包含一个值以及应该让它包含什么样的值>怎样让 panic 包含一个值，以及应该让它包含什么样的值</a></li></ul></li><li><a href=#recover-捕获异常>Recover 捕获异常</a><ul><li><a href=#正确调用-recover-函数>正确调用 recover 函数</a></li></ul></li><li><a href=#panic-和-recover-原理>panic 和 recover 原理</a><ul><li><a href=#崩溃恢复>崩溃恢复</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>