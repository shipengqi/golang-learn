<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang Learning</title>
    <link>http://shipengqi.github.io/golang-learn/</link>
    <description>Recent content on Golang Learning</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="http://shipengqi.github.io/golang-learn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/errors/</guid>
      <description>错误处理#go mod tidy error message: &amp;ldquo;but go 1.16 would select&amp;rdquo;#$ go mod tidy github.com/shipengqi/crtctl/internal/secret-writer imports github.com/shipengqi/kube imports k8s.io/client-go/kubernetes imports k8s.io/client-go/kubernetes/typed/admissionregistration/v1 imports k8s.io/client-go/applyconfigurations/admissionregistration/v1 imports k8s.io/apimachinery/pkg/util/managedfields imports k8s.io/kube-openapi/pkg/util/proto tested by k8s.io/kube-openapi/pkg/util/proto.test imports github.com/onsi/ginkgo imports github.com/onsi/ginkgo/internal/remote imports github.com/nxadm/tail imports github.com/nxadm/tail/winfile loaded from github.com/nxadm/tail@v1.4.4, but go 1.16 would select v1.4.8 To upgrade to the versions selected by go 1.16: go mod tidy -go=1.16 &amp;amp;&amp;amp; go mod tidy -go=1.17 If reproducibility with go 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/gin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/gin/</guid>
      <description>Gin#Gin 打包 Angular (React/Vue) 项目#Gin 作为 Web 框架提供 API 接口非常方便，但是在同一个项目中，既提供 API 接口，又要作为前端网页的静态服务器，就比较麻烦。通常 Angular (React/Vue) 项目需要在 Nginx 或者 Tomcat 转发才可以。有些小项目并不需要前后端分离，如何解决？
1.16 版本的 embed#Go 的 1.16 版本增加了 embed 的标签，可以利用这个标签将静态资源打包到二进制文件中。
. ├── config ├── controller ├── model ├── options ├── pkg │ └── response │ └── response.go ├── resources │ ├── dist │ └── html.go ├── html.go ├── resource.go ├── router.go ├── server.go └── store ├── audited.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/ginkgo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/ginkgo/</guid>
      <description>Ginkgo#</description>
    </item>
    
    <item>
      <title></title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/unsafe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/unsafe/</guid>
      <description>Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。
限制一：Go的指针不能进行数学运算。
a := 5 p := &amp;amp;a p++ p = &amp;amp;a + 3 上面的代码将不能通过编译，会报编译错误：invalid operation，也就是说不能对指针做数学运算。
限制二：不同类型的指针不能相互转换。
func main() { a :=int(100) var f *float64 f = &amp;amp;a } 也会报编译错误：cannot use &amp;amp;a (type *int) as type *float64 in assignment
限制三：不同类型的指针不能使用==或!=比较。
只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 == 和 != 直接和 nil 作比较。
限制四：不同类型的指针变量不能相互赋值。
这一点同限制三。
unsafe#Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。
unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。
它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。
Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。</description>
    </item>
    
    <item>
      <title>big</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/data/big/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/data/big/</guid>
      <description>big#big 是 Go 语言提供的进行大数操作的标准库，实现了任意精度算术（大数）。
Go 语言中的 float64 类型进行浮点运算，返回结果将精确到 15 位，足以满足大多数的任务。但是当对超出 int64 或者 uint64 类型这样的大 数进行计算时，如果对精度没有要求，float32 或者 float64 可以胜任，但如果对精度有严格要求的时候，则不能使用浮点数，在内存中它们只能 被近似的表示。
对于整数的高精度计算 Go 语言中提供了 big 包，被包含在 math 包下：有用来表示大整数的 big.Int 和表示大有理数的 big.Rat 类型 （可以表示为 2/5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存 和处理开销使它们使用起来要比内置的数字类型慢很多。
大的整型数字是通过 big.NewInt(n) 来构造的，其中 n 为 int64 类型整数。而大有理数是通过 big.NewRat(n, d) 方法构造。n（分子） 和 d（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 Add() 和 Mul() 这样的方法。它们作用 于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 big.Int 类型的临 时变量来存放中间结果，所以运算可以被链式地调用，并节省内存。</description>
    </item>
    
    <item>
      <title>bufio</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/io/bufio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/io/bufio/</guid>
      <description>bufio#bufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 io.Reader 和 io.Writer 对象。
bufio包中的数据类型#bufio包中的数据类型主要有：
Reader； Scanner； Writer 和 ReadWriter。 bufio.Reader#两个用于初始化 bufio.Reader 的函数：
NewReader 函数初始化的 Reader 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 4096 个字节，即：4 KB。 NewReaderSize 函数则将缓冲区尺寸的决定权抛给了使用方。 func NewReader(rd io.Reader) *Reader func NewReaderSize(rd io.Reader, size int) *Reader // 可以配置缓冲区的大小 bufio.Reader 类型值中的缓冲区的作用#缓冲区其实就是一个数据存储中介，它介于底层读取器与读取方法及其调用方之间。所谓的底层读取器是指 io.Reader。
Reader 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂 存于缓冲区之中以备后用。
缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。
type Reader struct { buf []byte rd io.Reader r, w int err error lastByte int lastRuneSize int } bufio.</description>
    </item>
    
    <item>
      <title>build</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/build/</guid>
      <description>build#go build [-o output] [-i] [build flags] [packages] 主要用于编译代码，go build 命令编译命令行参数指定的每个包。 有两种情况：
main 包，go build 将调用链接器在当前目录创建一个可执行程序，以导入路径的最后一段作为可执行程序的名字。 如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。 被编译的包会被保存到 $GOPATH/pkg 目录下，目录路径和 src 目录路径对应，可执行程序被保存到 $GOPATH/bin 目录。
OPTIONS#-a 强制重新编译所有包 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是 CPU 的数目 -o 指定输出的可执行文件的文件名，可以带路径，例如go build -o a/b/c -i 安装相应的包，编译并且go install -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags &#39;arg list&#39; 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags &#39;arg list&#39; 传递参数给gccgo编译连接调用 -gcflags &#39;arg list&#39; 编译器参数 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags &#39;arg list&#39; 链接器参数 -tags &#39;tag list&#39; 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints gcflags#-gcflags 参数的格式是</description>
    </item>
    
    <item>
      <title>channel</title>
      <link>http://shipengqi.github.io/golang-learn/docs/concurrent/channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/concurrent/channel/</guid>
      <description>Don’t communicate by sharing memory; share memory by communicating.（不要通过共享内存来通信，而应该通过通信来共享内存。） 这是作为 Go 语言最重要的编程理念。
通道类型的值是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。
channel 是 goroutine 之间的通信机制。goroutine 通过 channel 向另一个 goroutine 发送消息 channel 和 goroutine 结合，可以实现用通信代替共享内存的 CSP (Communicating Sequential Process)模型。
创建 channel：
ch := make(chan int) ch = make(chan int, 3) // buffered channel with capacity 3 上面的代码中，int 代表这个 channel 要发送的数据的类型。第二个参数代表创建一带缓存的 channel，容量为 3。
channel 的零值是 nil。关闭一个 nil 的 channel 会导致程序 panic。
发送和接收两个操作使用 &amp;lt;- 运算符，一个左尖括号紧接着一个减号形象地代表了元素值的传输方向：
// 发送一个值 ch &amp;lt;- x // 将数据 push 到 channel // 接受一个值 x = &amp;lt;-ch // 取出 channel 的值并复制给变量x &amp;lt;-ch // 接受的值会被丢弃 close#使用 close 函数关闭 channel，channel 关闭后不能再发送数据，但是可以接受已经发送成功的数据， 如果 channel 中没有数据，那么返回一个零值。</description>
    </item>
    
    <item>
      <title>container</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/data/container/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/data/container/</guid>
      <description>container#container 该包实现了三个复杂的数据结构：链表，环，堆。也就是说使用这三个数据结构的时候不需要再从头开始写算法了。
链表#链表就是一个有 prev 和 next 指针的数组了。 container 包中有两个公开的结构—— List 和 Element，List 实现了一个双向链表（简称链表）， 而 Element 则代表了链表中元素的结构。
type Element struct { next, prev *Element // 上一个元素和下一个元素 list *List // 元素所在链表 Value interface{} // 元素 } type List struct { root Element // 链表的根元素 len int // 链表的长度 } List的四种方法:
MoveBefore 方法和 MoveAfter 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。 MoveToFront 方法和 MoveToBack 方法，分别用于把给定的元素移动到链表的最前端和最后端。 // moves element &amp;#34;e&amp;#34; to its new position before &amp;#34;mark&amp;#34;.</description>
    </item>
    
    <item>
      <title>doc</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/doc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/doc/</guid>
      <description>doc#usage: go doc [-u] [-c] [package|[package.]symbol[.methodOrField]] Doc prints the documentation comments associated with the item identified by its arguments (a package, const, func, type, var, method, or struct field) followed by a one-line summary of each of the first-level items &amp;#34;under&amp;#34; that item (package-level declarations for a package, methods for a type, etc.). Doc accepts zero, one, or two arguments. Given no arguments, that is, when run as go doc it prints the package documentation for the package in the current directory.</description>
    </item>
    
    <item>
      <title>env</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/env/</guid>
      <description>env#usage: go env [-json] [var ...] Env prints Go environment information. By default env prints information as a shell script (on Windows, a batch file). If one or more variable names is given as arguments, env prints the value of each named variable on its own line. The -json flag prints the environment in JSON format instead of as a shell script. For more about environment variables, see &amp;#39;go help environment&amp;#39;.</description>
    </item>
    
    <item>
      <title>filepath</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/os/filepath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/os/filepath/</guid>
      <description>filepath#filepath 的功能和 path 包类似，但是对于不同操作系统提供了更好的支持。filepath 包能够自动的根据不同的操作系统文件路径进行转换， 通常情况下应该总是使用 filepath 包，而不是 path 包。
path/filepath 包涉及到路径操作时，路径分隔符使用 os.PathSeparator。不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。
例如，在 Unix 中，路径的分隔符是 /，但 Windows 是 \。
path/filepath 能够处理所有的文件路径，不管是什么系统。注意，路径操作函数并不会校验路径是否真实存在。
解析路径名字符串#Dir() 和 Base() 函数将一个路径名字符串分解成目录和文件名两部分。（一般情况，这些函数与 Unix 中 dirname 和 basename 命令类似，但如果 路径以 / 结尾，Dir 的行为和 dirname 不太一致。）
func Dir(path string) string func Base(path string) string Dir 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 Split 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。 如果路径是空字符串，会返回 .；如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 /；其他任何情况下都不会返回以斜杠结尾的路径。
Base 函数返回路径的最后一个元素。在提取元素前会去掉末尾的斜杠。如果路径是 &amp;ldquo;&amp;quot;，会返回 .；如果路径是只有一个斜杆构成的，会返回 /。</description>
    </item>
    
    <item>
      <title>fmt</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/fmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/fmt/</guid>
      <description>fmt#usage: go fmt [-n] [-x] [packages] Fmt runs the command &amp;#39;gofmt -l -w&amp;#39; on the packages named by the import paths. It prints the names of the files that are modified. For more about gofmt, see &amp;#39;go doc cmd/gofmt&amp;#39;. For more about specifying packages, see &amp;#39;go help packages&amp;#39;. The -n flag prints commands that would be executed. The -x flag prints commands as they are executed. To run gofmt with specific options, run gofmt itself.</description>
    </item>
    
    <item>
      <title>fmt 包</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/io/fmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/io/fmt/</guid>
      <description>fmt 包#fmt 包实现了格式化 I/O 函数，有关格式化输入输出的方法有两大类：Scan 和 Print。
print.go 文件中定义了如下函数：
Print#// 普通输出，不带换行符 func Print(a ...interface{}) (n int, err error) func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Sprint(a ...interface{}) string // 输出内容时会加上换行符 func Println(a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) func Sprintln(a ...interface{}) string // 按照指定格式化文本输出内容 func Printf(format string, a ...interface{}) (n int, err error) func Fprintf(w io.</description>
    </item>
    
    <item>
      <title>get</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/get/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/get/</guid>
      <description>get#usage: go get [-d] [-m] [-u] [-v] [-insecure] [build flags] [packages] Get resolves and adds dependencies to the current development module and then builds and installs them. The first step is to resolve which dependencies to add. For each named package or package pattern, get must decide which version of the corresponding module to use. By default, get chooses the latest tagged release version, such as v0.4.5 or v1.</description>
    </item>
    
    <item>
      <title>Go PProf</title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/pprof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/pprof/</guid>
      <description>PProf 是 Go 提供的用于可视化和分析性能分析数据的工具。
runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析 主要可以用于：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期 时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 性能分析#分析 HTTP Server#Web#import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; ) var datas []string func Add(str string) string { data := []byte(str) sData := string(data) datas = append(datas, sData) return sData } func main() { go func() { for { log.</description>
    </item>
    
    <item>
      <title>Go trace</title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/trace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/trace/</guid>
      <description>Go PProf 很难完成 Goroutine 的分析。这就需要使用 go tool trace 命令。
go tool pprof 可以跟踪运行缓慢的函数，或者找到大部分 CPU 时间花费在哪里。 go tool trace 更适合于找出程序在一段时间内正在做什么，而不是总体上的开销。
package main import ( &amp;#34;os&amp;#34; &amp;#34;runtime/trace&amp;#34; ) func main() { f, err := os.Create(&amp;#34;trace.out&amp;#34;) if err != nil { panic(err) } defer f.Close() err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() ch := make(chan string) go func() { ch &amp;lt;- &amp;#34;hello&amp;#34; }() // read from channel &amp;lt;-ch } 生成跟踪文件：</description>
    </item>
    
    <item>
      <title>Go 命令</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/summary/</guid>
      <description>Go 命令#$ go Go is a tool for managing Go source code. Usage: go command [arguments] The commands are: build 编译指定的源码包以及它们的依赖包 clean 删除掉执行其它命令时产生的一些文件和目录 doc show documentation for package or symbol env 打印 Go 的环境信息 bug start a bug report fix 把指定代码包的所有 Go 语言源码文件中的旧版本代码修正为新版本的代码 fmt gofmt (reformat) package sources generate generate Go files by processing source get 下载或更新指定的代码包及其依赖包，并对它们进行编译和安装 install 编译并安装指定的源码包以及它们的依赖包 list 列出指定的代码包的信息 mod Go 的依赖包管理工具 run 编译并运行 Go 程序 test 对指定包进行测试 tool 运行指定的 go 工具 version 打印 Go 的版本信息 vet 检查 Go 语言源码中静态错误的工具，报告包中可能出现的错误 Use &amp;#34;go help [command]&amp;#34; for more information about a command.</description>
    </item>
    
    <item>
      <title>Go 数据竞争检测器</title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/go-race/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/go-race/</guid>
      <description>数据竞争是并发系统中最常见，同时也最难处理的 Bug 类型之一。数据竞争会在两个 Go 程并发访问同一个变量， 且至少有一个访问为写入时产生。
这个数据竞争的例子可导致程序崩溃和内存数据损坏（memory corruption）。
func main() { c := make(chan bool) m := make(map[string]string) go func() { m[&amp;#34;1&amp;#34;] = &amp;#34;a&amp;#34; // 第一个冲突的访问。 c &amp;lt;- true }() m[&amp;#34;2&amp;#34;] = &amp;#34;b&amp;#34; // 第二个冲突的访问。 &amp;lt;-c for k, v := range m { fmt.Println(k, v) } } 数据竞争检测器#Go内建了数据竞争检测器。要使用它，请将 -race 标记添加到 go 命令之后：
go test -race mypkg // 测试该包 go run -race mysrc.go // 运行其源文件 go build -race mycmd // 构建该命令 go install -race mypkg // 安装该包 选项#GORACE 环境变量可以设置竞争检测的选项：</description>
    </item>
    
    <item>
      <title>Go 环境配置</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/env_config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/env_config/</guid>
      <description>Go 环境配置#安装#Windows 下安装，官网 下载安装包，直接安装。 默认情况下 .msi 文件会安装在 c:\Go 目录下。安装完成后默认会将 c:\Go\bin 目录添加到 PATH 环境变量中。 并添加环境变量 GOROOT，值为 Go 安装根目录 C:\Go\。重启命令窗口生效。
打开 CMD 输入 go 命令，验证是否安装成功。否则检查环境变量 Path 和 GOROOT。
工作区#GOROOT#环境变量 GOROOT 用来指定 Go 的安装目录，Go 的标准库也在这个位置。目录结构与 GOPATH 类似。
GOPATH#我们安装好 Go 之后，必须配置一个环境变量 GOPATH，这个 GOPATH 路径是用来指定当前工作目录的。 不能和 Go 的安装目录（GOROOT）一样。
工作区的目录结构：
GOPATH/ src/ # 源码目录 bin/ # 存放编译后的可执行程序 pkg/ # 存放编译后的包的目标文件 GOPATH 允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候 Windows 是分号 ;，Linux 系统是冒号 :， 当有多个 GOPATH 时，默认会将 go get 的内容放在第一个目录下。</description>
    </item>
    
    <item>
      <title>Go 的相对路径</title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/go_relative_path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/go_relative_path/</guid>
      <description>在构建 Go 项目时，有没有碰到 go build 编译好的二进制文件（或者 go run main.go），在不同的目录下执行，得到的结果却不一样？
例如，我的目录结构是下面这样的：
backend├── app│ ├── cmd│ │ └── cmd.go│ ├── conf│ │ └── conf.yaml│ ├── config│ │ └── config.go│ ├── dao│ │ └── dao.go│ ├── http│ │ └── http.go│ └── main.go├── go.mod├── go.sum└── suiteinstaller suiteinstaller 是构建好的二进制文件，在 backend 目录下运行或者执行 go run ./app/main.go 可以正常运行。但是如果在 app 目录下执行同样的命令则会报错：
# go run .</description>
    </item>
    
    <item>
      <title>Golang 条件编译</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/build/</guid>
      <description>Golang 支持两种条件编译方式：
编译标签( build tag) 文件后缀 编译标签#编译标签添加的规则：
a build tag is evaluated as the OR of space-separated options each option evaluates as the AND of its comma-separated terms each term is an alphanumeric word or, preceded by !, its negation 翻译了就是：
编译标签由空格分隔的编译选项(options)以&amp;quot;或&amp;quot;的逻辑关系组成 每个编译选项由逗号分隔的条件项以逻辑&amp;quot;与&amp;quot;的关系组成 每个条件项的名字用字母+数字表示，在前面加 ! 表示否定的意思 +build 之后必须有空行，否则会被编译器当做普通注释
// +build darwin freebsd netbsd openbsd package testpkg 这个将会让这个源文件只能在支持 kqueue 的 BSD 系统里编译
一个源文件里可以有多行编译标签，多行编译标签之间是逻辑&amp;quot;与&amp;quot;的关系
// +build linux darwin // +build 386 这个将限制此源文件只能在 linux/386 或者 darwin/386 平台下编译.</description>
    </item>
    
    <item>
      <title>golint</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/golint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/golint/</guid>
      <description>golint#</description>
    </item>
    
    <item>
      <title>goroutine</title>
      <link>http://shipengqi.github.io/golang-learn/docs/concurrent/goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/concurrent/goroutine/</guid>
      <description>goroutine 是 Go 语言最显著的特征，Go 从根上将一切都并发化，用 goroutine 运行一切，包括入口函数 main。 goroutine 用类似协程的方式处理并发单元，并且做的更深度的优化。这就让并发编程变的简单，不需要处理回调，不需要关注 执行绪切换，一个 go 就搞定。
goroutine#Go 语言在语言层面上支持了并发，简单将 goroutine 归为协程并不合适。Go runtime 会创建多个线程来执行并发任务，而且任务 可以跨线程调度。所以 goroutine 更像是多线程和协程的结合体。
goroutine 可以简单理解为协程，开销较低 (大概是 4~5KB )，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千 上万个并发任务。goroutine 比 thread 更易用、更高效、更轻便。我们程序运行的 main 函数在一个单独的 goroutine 中运行， 叫做 主 goroutine。在代码中可以使用 go 关键字创建 goroutine。
go f() main 函数返回时，所有 goroutine 都会被打断，程序退出。除了从 main 函数退出或者直接终止程序之外，没有其它 的编程方法能够让一个 goroutine 来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过 goroutine 之间 的通信来让一个 goroutine 请求其它的 goroutine，使被请求 goroutine 自行结束执行。
什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同#package main import &amp;#34;fmt&amp;#34; func main() { for i := 0; i &amp;lt; 10; i++ { go func() { fmt.</description>
    </item>
    
    <item>
      <title>Goroutine 调度器</title>
      <link>http://shipengqi.github.io/golang-learn/docs/advance/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/advance/scheduler/</guid>
      <description>Goroutine 调度器#type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</description>
    </item>
    
    <item>
      <title>http</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/net/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/net/http/</guid>
      <description>http#net/http 可以用来处理 HTTP 协议，包括 HTTP 服务器和 HTTP 客户端，主要组成：
Request，HTTP 请求对象 Response，HTTP 响应对象 Client，HTTP 客户端 Server，HTTP 服务端 创建一个 server ：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func MyHandler(w http.ResponseWriter, r *http.Request) { _, _ = fmt.Fprintf(w, &amp;#34;hello&amp;#34;) } func main() { http.HandleFunc(&amp;#34;/&amp;#34;, MyHandler) _ = http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) } 发送请求：
resp, err := http.Get(&amp;#34;http://example.com/&amp;#34;) // GET resp, err := http.Post(&amp;#34;http://example.com/&amp;#34;) // POST resp, err := http.PostForm(&amp;#34;http://example.com/&amp;#34;, url.Values{&amp;#34;foo&amp;#34;: &amp;#34;bar&amp;#34;}) // 提交表单 Request#Request 对象是对 http 请求报文的抽象。包括起始行, Headers, Body 等。</description>
    </item>
    
    <item>
      <title>install</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/install/</guid>
      <description>install#usage: go install [-i] [build flags] [packages] Install compiles and installs the packages named by the import paths. The -i flag installs the dependencies of the named packages as well. For more about the build flags, see &amp;#39;go help build&amp;#39;. For more about specifying packages, see &amp;#39;go help packages&amp;#39;. See also: go build, go get, go clean. </description>
    </item>
    
    <item>
      <title>io</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/io/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/io/io/</guid>
      <description>io#io 是对输入输出设备的抽象。io 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。 最重要的是两个接口：Reader 和 Writer。
Reader#Reader 接口：
type Reader interface { Read(p []byte) (n int, err error) } Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)） 以及任何遇到的错误。 即使 Read 返回的 n &amp;lt; len(p)，它也会在调用过程中占用 len(p) 个字节作为暂存空间。若可读取的数据不到 len(p) 个 字节，Read 会返回可用数据，而不是等待更多数据。
当 Read 在成功读取 n &amp;gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。它可能会同时在本次的调 用中返回一个 non-nil 错误,或在下一次的调用中返回这个错误（且 n 为 0）。 一般情况下, Reader 会返回一个 非 0 字节数 n, 若 n = len(p) 个字节从输入源的结尾处由 Read 返回，Read 可能返回 err == EOF 或者 err == nil。并且之后的 Read 都应该返回 (n:0, err:EOF)。</description>
    </item>
    
    <item>
      <title>ioutil</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/io/ioutil/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/io/ioutil/</guid>
      <description>ioutil#ioutil 提供了一些常用、方便的 IO 操作函数。
NopCloser 函数#有时候我们需要传递一个 io.ReadCloser 的实例，而我们现在有一个 io.Reader 的实例，比如：strings.Reader ，这个时候 NopCloser 就派上用场了。它包装一个 io.Reader，返回一个 io.ReadCloser ，而相应的 Close 方法啥也不做，只是返回 nil。
比如，在标准库 net/http 包中的 NewRequest，接收一个 io.Reader 的 body，而实际上，Request 的 Body 的类 型是 io.ReadCloser，因此，代码内部进行了判断，如果传递的 io.Reader 也实现了 io.ReadCloser 接口，则转换，否则通 过 ioutil.NopCloser 包装转换一下。相关代码如下：
rc, ok := body.(io.ReadCloser) if !ok &amp;amp;&amp;amp; body != nil { rc = ioutil.NopCloser(body) } ReadAll 函数#很多时候，我们需要一次性读取 io.Reader 中的数据，考虑到读取所有数据的需求比较多，Go 提供了 ReadAll 这个函数，用来从 io.Reader 中 一次读取所有数据。</description>
    </item>
    
    <item>
      <title>Json Unmarshal</title>
      <link>http://shipengqi.github.io/golang-learn/docs/practice/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/practice/json/</guid>
      <description>Json Unmarshal#Go 官方的 encoding/json 包可以实现 json 互转。如：
type AuthResponse struct { Auth AuthData `json:&amp;#34;auth&amp;#34;` } type AuthData struct { ClientToken string `json:&amp;#34;client_token&amp;#34;` } var authResponse AuthResponse err = json.Unmarshal(response.Body(), &amp;amp;authResponse) encoding/json 包的 json.Marshal/Unmarshal 是非常慢的，因为是通过大量反射来实现的。
可以使用第三方库来替代标准库：
json-iterator/go，完全兼容标准库，性能有很大提升。 ffjson </description>
    </item>
    
    <item>
      <title>log</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/log/</guid>
      <description>log#log 模块用于在程序中输出日志。
package main import &amp;#34;log&amp;#34; func main() { log.Print(&amp;#34;Hello World&amp;#34;) // 2019/09/12 13:56:36 Hello World } Logger#通过 New 函数可以创建多个 Logger 实例，函数声明如下：
func New(out io.Writer, prefix string, flag int) *Logger 参数：
out：日志输出的 IO 对象，通常是标准输出 os.Stdout，os.Stderr，或者绑定到文件的 IO。 prefix：日志前缀，可以是任意字符串。 flag：日志包含的通用信息标识位 一条日志的结构：
{日志前缀} {标识1} {标识2} ... {标识n} {日志内容} 标识通过 flag 参数设置，当某个标识被设置，会在日志中进行显示，log 模块中已经提供了如下标识，多个标识通过 | 组合：
Ldate 显示当前日期（当前时区） Ltime 显示当前时间（当前时区） microseconds 显示当前时间（微秒） Llongfile 包含路径的完整文件名 Lshortfile 不包含路径的文件名 LUTC Ldata 和 Ltime 使用 UTC 时间 LstdFlags 标准 Logger 的标识，等价于 Ldate | Ltime package main import ( &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) func main() { prefix := &amp;#34;[THIS IS THE LOG]&amp;#34; logger := log.</description>
    </item>
    
    <item>
      <title>map</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/map/</guid>
      <description>map 是一个无序的 key/value 对的集合。map 是引用类型。这意味着它拥有对底层数据结构的引用， 就像指针一样。它底层的数据结构是 hash table 或 hash map。
map 作为引用类型是非常好的，因为无论 map 有多大，都只会有一个副本。
定义 map，使用 map 关键字：
/* 声明变量，默认 map 是 nil */ var 变量名 map[键类型]值类型 /* 使用 make 函数 */ 变量名 := make(map[键类型]值类型) /* 字面值的语法创建 */ 变量名 := map[键类型]值类型{ key1: value1, key2: value2, ... } 一个 map 在未初始化之前默认为 nil。 通过索引下标 key 来访问 map 中对应的 value
age, ok := ages[&amp;#34;bob&amp;#34;] if !ok { /* &amp;#34;bob&amp;#34; is not a key in this map; age == 0.</description>
    </item>
    
    <item>
      <title>math</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/data/math/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/data/math/</guid>
      <description>math#math 包实现的就是数学函数计算。
三角函数#正弦函数，反正弦函数，双曲正弦，反双曲正弦
- func Sin(x float64) float64- func Asin(x float64) float64- func Sinh(x float64) float64- func Asinh(x float64) float64 一次性返回 sin,cos
func Sincos(x float64) (sin, cos float64) 余弦函数，反余弦函数，双曲余弦，反双曲余弦
- func Cos(x float64) float64- func Acos(x float64) float64- func Cosh(x float64) float64- func Acosh(x float64) float64 正切函数，反正切函数，双曲正切，反双曲正切
- func Tan(x float64) float64- func Atan(x float64) float64 和 func Atan2(y, x float64) float64- func Tanh(x float64) float64- func Atanh(x float64) float64 幂次函数#- func Cbrt(x float64) float64 // 立方根函数- func Pow(x, y float64) float64 // x 的幂函数- func Pow10(e int) float64 // 10 根的幂函数- func Sqrt(x float64) float64 // 平方根- func Log(x float64) float64 // 对数函数- func Log10(x float64) float64 // 10 为底的对数函数- func Log2(x float64) float64 // 2 为底的对数函数- func Log1p(x float64) float64 // log(1 + x)- func Logb(x float64) float64 // 相当于 log2(x) 的绝对值- func Ilogb(x float64) int // 相当于 log2(x) 的绝对值的整数部分- func Exp(x float64) float64 // 指数函数- func Exp2(x float64) float64 // 2 为底的指数函数- func Expm1(x float64) float64 // Exp(x) - 1 特殊函数#- func Inf(sign int) float64 // 正无穷- func IsInf(f float64, sign int) bool // 是否正无穷- func NaN() float64 // 无穷值- func IsNaN(f float64) (is bool) // 是否是无穷值- func Hypot(p, q float64) float64 // 计算直角三角形的斜边长 类型转化函数#- func Float32bits(f float32) uint32 // float32 和 unit32 的转换- func Float32frombits(b uint32) float32 // uint32 和 float32 的转换- func Float64bits(f float64) uint64 // float64 和 uint64 的转换- func Float64frombits(b uint64) float64 // uint64 和 float64 的转换 其他函数#- func Abs(x float64) float64 // 绝对值函数- func Ceil(x float64) float64 // 向上取整- func Floor(x float64) float64 // 向下取整- func Mod(x, y float64) float64 // 取模- func Modf(f float64) (int float64, frac float64) // 分解 f，以得到 f 的整数和小数部分- func Frexp(f float64) (frac float64, exp int) // 分解 f，得到 f 的位数和指数- func Max(x, y float64) float64 // 取大值- func Min(x, y float64) float64 // 取小值- func Dim(x, y float64) float64 // 复数的维数- func J0(x float64) float64 // 0 阶贝塞尔函数- func J1(x float64) float64 // 1 阶贝塞尔函数- func Jn(n int, x float64) float64 // n 阶贝塞尔函数- func Y0(x float64) float64 // 第二类贝塞尔函数 0 阶- func Y1(x float64) float64 // 第二类贝塞尔函数 1 阶- func Yn(n int, x float64) float64 // 第二类贝塞尔函数 n 阶- func Erf(x float64) float64 // 误差函数- func Erfc(x float64) float64 // 余补误差函数- func Copysign(x, y float64) float64 // 以 y 的符号返回 x 值- func Signbit(x float64) bool // 获取 x 的符号- func Gamma(x float64) float64 // 伽玛函数- func Lgamma(x float64) (lgamma float64, sign int) // 伽玛函数的自然对数- func Ldexp(frac float64, exp int) float64 // value 乘以 2 的 exp 次幂- func Nextafter(x, y float64) (r float64) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x- func Nextafter32(x, y float32) (r float32) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x- func Remainder(x, y float64) float64 // 取余运算- func Trunc(x float64) float64 // 截取函数 </description>
    </item>
    
    <item>
      <title>mod</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/mod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/mod/</guid>
      <description>mod#Golang 在 1.11 推出了 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，解决了 GOPATH 的问题，相当于弃用了 GOPATH。
Go Module 机制#Go Module 不同于基于 GOPATH 和 Vendor 的项目构建，其主要是通过 $GOPATH/pkg/mod 下缓存的模块来对项目进行构建。 同一个模块版本的数据只缓存一份，所有其他模块共享使用。
可以使用 go clean -modcache 清理所有已缓存的模块版本数据。
GO111MODULE#Go Module 目前是可选的，可以通过环境变量 GO111MODULE 来控制是否启用，GO111MODULE 有三种类型:
on 所有的构建，都使用 Module 机制 off 所有的构建，都不使用 Module 机制，而是使用 GOPATH 和 Vendor auto 在 GOPATH 下的项目，不使用 Module 机制，不在 GOPATH 下的项目使用 GOPROXY#GOPROXY 用于设置 Go Module 代理。使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它的值是一个以 , 分割的 Go module proxy 列表。Golang 1.</description>
    </item>
    
    <item>
      <title>os</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/os/os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/os/os/</guid>
      <description>os#os 包提供了平台无关的操作系统功能接口。例如 Linux、macOS、Windows 等系统 os 包提供统一的使用接口。
例子，打开一个文件并从中读取一些数据：
file, err := os.Open(&amp;#34;file.go&amp;#34;) // For read access. if err != nil { log.Fatal(err) // `open file.go: no such file or directory` } 文件 I/O#在 Go 中，文件描述符封装在 os.File 结构中，通过 File.Fd() 可以获得底层的文件描述符：fd。
大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。os 包提供了 3 个 File 对象，分别 代表这 3 种标准描述符：Stdin、Stdout 和 Stderr，它们对应的文件名分别是：/dev/stdin、/dev/stdout 和 /dev/stderr。 注意，这里说的文件名，并不一定存在，比如 Windows 下就没有。
OpenFile#func OpenFile(name string, flag int, perm FileMode) (*File, error) OpenFile 既能打开一个已经存在的文件，也能创建并打开一个新文件。</description>
    </item>
    
    <item>
      <title>run</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/run/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/run/</guid>
      <description>run#usage: go run [build flags] [-exec xprog] package [arguments...] Run compiles and runs the named main Go package. Typically the package is specified as a list of .go source files, but it may also be an import path, file system path, or pattern matching a single known package, as in &amp;#39;go run .&amp;#39; or &amp;#39;go run my/cmd&amp;#39;. By default, &amp;#39;go run&amp;#39; runs the compiled binary directly: &amp;#39;a.out arguments.</description>
    </item>
    
    <item>
      <title>slice</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/slice/</guid>
      <description>slice 的语法和数组很像，由于数组长度是固定的，所以使用 slice 相比数组会更灵活，slice 是动态的。
切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型。
定义切片，和定义数组的区别就是不需要指定 SIZE：
var 变量名 []类型 一个 slice 由三个部分构成：指针、长度和容量。长度不能超过容量。 一个切片在未初始化之前默认为 nil，长度为 0。
初始化切片：
// 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3.其 cap=len=3 s :=[]int {1,2,3} // 初始化切片 s,是数组 arr 的引用 s := arr[:] // 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片 s := arr[startIndex:endIndex] // 缺省 endIndex 时将表示一直到 arr 的最后一个元素 s := arr[startIndex:] // 缺省 startIndex 时将表示从 arr 的第一个元素开始 s := arr[:endIndex] // 使用 make 函数来创建切片 // len 是数组的长度并且也是切片的初始长度 // capacity 为可选参数, 指定容量 s := make([]int, len, capacity) len() 和 cap()#len获取切片长度。 cap计算切片的最大容量 append() 和 copy()#append 向切片追加新元素 copy 拷贝切片 append 的使用#使用 append 函数时要注意，append 总是从 slice 的尾部开始追加数据。比如下面的代码：</description>
    </item>
    
    <item>
      <title>sort</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/data/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/data/sort/</guid>
      <description>sort#sort 包中实现了几种基本的排序算法：插入排序、归并排序、堆排序和快速排序。但是这四种排序方法是不公开的，只用于 sort 包 内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法就可以对数据集合进 行排序。sort 包会根据实际数据自动选择高效的排序算法。
type Interface interface { // Len 为集合内元素的总数 Len() int // 如果 index 为 i 的元素小于 index 为 j 的元素，则返回 true，否则 false Less(i, j int) bool // Swap 交换索引为 i 和 j 的元素 Swap(i, j int) } 为了方便对常用数据类型的操作，sort 包原生支持 []int、[]float64 和 []string 三种内建数据类型切片的排序操作。 即不必实现 sort.Interface 接口的三个方法。
数据集合排序#对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法：
数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下：
func Sort(data Interface) Sort() 方法惟一的参数就是待排序的数据集合。</description>
    </item>
    
    <item>
      <title>sql</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/database/sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/database/sql/</guid>
      <description>sql#database/sql 提供了操作 SQL/SQL-Like 数据库的通用接口，但 Go 标准库并没有提供具体数据库的实现，需要结合第三方的驱动来使用该接口。 例如 mysql 的驱动：github.com/go-sql-driver/mysql。
类型#database/sql 提供了一些类型：
sql.DB 类型代表了一个数据库。它并不代表一个到数据库的具体连接，而是一个能操作的数据库对象，具体的连接在内部通过连接池来管理， 对外不暴露。 sql.Rows、sql.Row 和 sql.Result，分别用于获取多个多行结果、一行结果和修改数据库影响的行数（或其返回 last insert id）。 sql.Stmt 代表一个语句，如：DDL、DML 等。 sql.Tx 代表带有特定属性的一个事务。 sql.DB 的使用#sql.DB 是一个数据库句柄，代表一个具有零到多个底层连接的连接池，它可以安全的被多个 goroutine 同时使用。
sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。 一旦调用了 BD.Begin，返回的 Tx 会绑定到单个连接。当调用事务 Tx 的 Commit 或 Rollback 后，该事务使用的连接会归还到 DB 的闲 置连接池中。连接池的大小可以用 SetMaxIdleConns 方法控制。
由于 DB 并非一个实际的到数据库的连接，而且可以被多个 goroutine 并发使用，因此，程序中只需要拥有一个全局的实例即可：
db, err := sql.Open(&amp;#34;mysql&amp;#34;, &amp;#34;root:@tcp(localhost:3306)/test?charset=utf8&amp;#34;) if err != nil { panic(err) } defer db.</description>
    </item>
    
    <item>
      <title>strconv</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/text/strconv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/text/strconv/</guid>
      <description>strconv#strconv 包包含了一系列字符串与相关的类型转换的函数。
转换错误处理#strconv 中的错误处理。
由于将字符串转为其他数据类型可能会出错，strconv 包定义了两个 error 类型的变量：ErrRange 和 ErrSyntax。其中，ErrRange 表示 值超过了类型能表示的最大范围，比如将 &amp;ldquo;128&amp;rdquo; 转为 int8 就会返回这个错误；ErrSyntax 表示语法错误，比如将 &amp;quot;&amp;quot; 转为 int 类型会返 回这个错误。
然而，在返回错误的时候，通过构造一个 NumError 类型的 error 对象返回。NumError 结构的定义如下：
// A NumError records a failed conversion. type NumError struct { Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat) Num string // the input Err error // the reason the conversion failed (ErrRange, ErrSyntax) } 该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 error 类型的成员，记录具体的错误信息，包的实现中，定义了两个便捷函数， 用于构造 NumError 对象：</description>
    </item>
    
    <item>
      <title>strings</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/text/strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/text/strings/</guid>
      <description>strings#字符串常见操作有：
字符串长度； 求子串； 是否存在某个字符或子串； 子串出现的次数（字符串匹配）； 字符串分割（切分）为 []string； 字符串是否有某个前缀或后缀； 字符或子串在字符串中首次出现的位置或最后一次出现的位置； 通过某个字符串将 []string 连接起来； 字符串重复几次； 字符串中子串替换； 大小写转换； Trim 操作； &amp;hellip; 前缀和后缀#HasPrefix 判断字符串 s 是否以 prefix 开头：
strings.HasPrefix(s, prefix string) bool HasSuffix 判断字符串 s 是否以 suffix 结尾：
strings.HasSuffix(s, suffix string) bool 示例：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { var str string = &amp;#34;This is an example of a string&amp;#34; fmt.Printf(&amp;#34;T/F? Does the string \&amp;#34;%s\&amp;#34; have prefix %s?</description>
    </item>
    
    <item>
      <title>test</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/test/</guid>
      <description>usage: go test [build/test flags] [packages] [build/test flags &amp;amp; test binary flags] &amp;#39;Go test&amp;#39; automates testing the packages named by the import paths. It prints a summary of the test results in the format: ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... followed by detailed output for each failed package. &amp;#39;Go test&amp;#39; recompiles each package along with any files with names matching the file pattern &amp;#34;*_test.go&amp;#34;. These additional files can contain test functions, benchmark functions, and example functions.</description>
    </item>
    
    <item>
      <title>time</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/time/</guid>
      <description>time#time 提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数，比如：
time.Now() 获取当前时间。 t.Day()、t.Minute() 获取时间的一部分。 time.After、time.Ticker 在经过一定时间或周期执行某项任务（事件处理的特例）。 time.Sleep（Duration d） 暂停某个进程（ goroutine），暂停时长为 d。 Duration 代表两个时间点之间经过的时间，以纳秒为单位，类型为 int64。 Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。 时区#Go 语言使用 Location 来表示地区相关的时区，一个 Location 可能表示多个时区。
time 包提供了 Location 的两个实例：
Local 代表当前系统本地时区； UTC 代表通用协调时间，也就是零时区。time 包默认（为显示提供时区）使用 UTC 时区。 Local 是如何做到表示本地时区的？#在初始化 Local 时，通过读取 /etc/localtime （这是一个符号链接，指向 /usr/share/zoneinfo 中某一个时区）可以获取到系统本地时区。
如果设置了环境变量 TZ，则会优先使用它。
tz, ok := syscall.Getenv(&amp;#34;TZ&amp;#34;) switch { case !ok: z, err := loadZoneFile(&amp;#34;&amp;#34;, &amp;#34;/etc/localtime&amp;#34;) if err == nil { localLoc = *z localLoc.</description>
    </item>
    
    <item>
      <title>tool</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/tool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/tool/</guid>
      <description>usage: go tool [-n] command [args...] Tool runs the go tool command identified by the arguments. With no arguments it prints the list of known tools. The -n flag causes tool to print the command that would be executed but not execute it. For more about each tool command, see &amp;#39;go doc cmd/&amp;lt;command&amp;gt;&amp;#39;. </description>
    </item>
    
    <item>
      <title>unicode</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/text/unicode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/text/unicode/</guid>
      <description>unicode#go 对 unicode 的支持包含三个包 :
unicode unicode/utf8 unicode/utf16 unicode 包包含基本的字符判断函数。utf8 包主要负责 rune 和 byte 之间的转换。utf16 包负责 rune 和 uint16 数组之间 的转换。
unicode 包#unicode 包含了对 rune 的判断。这个包把所有 unicode 涉及到的编码进行了分类，使用结构
type RangeTable struct { R16 []Range16 R32 []Range32 LatinOffset int } 来表示这个功能的字符集。这些字符集都集中列表在 table.go 这个源码里面。
比如控制字符集：
var _Pc = &amp;amp;RangeTable{ R16: []Range16{ {0x005f, 0x203f, 8160}, {0x2040, 0x2054, 20}, {0xfe33, 0xfe34, 1}, {0xfe4d, 0xfe4f, 1}, {0xff3f, 0xff3f, 1}, }, } 回到包的函数，我们看到有下面这些判断函数：</description>
    </item>
    
    <item>
      <title>vet</title>
      <link>http://shipengqi.github.io/golang-learn/docs/commands/vet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/commands/vet/</guid>
      <description>vet#usage: go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages] Vet runs the Go vet command on the packages named by the import paths. For more about vet and its flags, see &amp;#39;go doc cmd/vet&amp;#39;. For more about specifying packages, see &amp;#39;go help packages&amp;#39;. For a list of checkers and their flags, see &amp;#39;go tool vet help&amp;#39;. For details of a specific checker such as &amp;#39;printf&amp;#39;, see &amp;#39;go tool vet help printf&amp;#39;.</description>
    </item>
    
    <item>
      <title>作用域</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/scope/</guid>
      <description>作用域#声明语句的作用域是指源代码中可以有效使用这个名字的范围。
局部变量 在函数体内或代码块内声明的变量称之为局部变量，它们的作用域只在代码块内，参数和返回值变量也是局部变量。 全局变量 作用域都是全局的（在本包范围内） 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包 （被导出后 首字母大写）使用。 全局变量可以在任何函数中使用。 Go 的标识符作用域是基于代码块的。代码块就是包裹在一对大括号内部的声明和语句，并且是可嵌套的。代码块内部声明的名字是无法 被外部块访问的。
声明语句作用域范围的大小。
内置的类型、函数和常量，比如 int、len 和 true 是全局作用域 在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问 导入的包，如 import &amp;quot;packages/test&amp;quot;，是对应源文件级的作用域，只能在当前的源文件中访问 在函数内部声明的名字，只能在函数内部访问 一个程序可能包含多个同名的声明，只要它们在不同的词法域就可以。内层的词法域会屏蔽外部的声明。</description>
    </item>
    
    <item>
      <title>内存分配</title>
      <link>http://shipengqi.github.io/golang-learn/docs/advance/mm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/advance/mm/</guid>
      <description>内存分配器#函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。
分配方法#内存分配器一般包含两种分配方法，一种是线性分配器（Sequential Allocator，Bump Allocator），另一种是空闲链表分配器（Free-List Allocator）
线性分配器#高效的内存分配方法，但是有较大的局限性。当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：
但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器是无法重新利用红色的这部分内存的：
需要合适的垃圾回收算法配合使用。标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。
空闲链表分配器#可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：
因为不同的内存块以链表的方式连接，所以使用这种方式分配内存的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度就是 O(n)。
可以选择不同的策略在链表中的内存块中进行选择，最常见的就是以下四种方式：
首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块； 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块； 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块； 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块； Go 语言使用的内存分配策略与第四种策略有些相似
如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，我们会在上图中的第二个链表找到空闲的内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。
分级分配#线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多2。Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。
Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：
类别 大小 微对象 (0, 16B) 小对象 [16B, 32KB] 大对象 (32KB, +∞)
TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存：</description>
    </item>
    
    <item>
      <title>函数</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/function/</guid>
      <description>声明函数#func 关键字声明函数：
func 函数名(形式参数列表) (返回值列表) { 函数体 } 如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。如果一个函数声明没有返回值列表，那么这个 函数不会返回任何值。
// 两个 int 类型参数 返回一个 int 类型的值 func max(num1, num2 int) int { /* 定义局部变量 */ var result int if (num1 &amp;gt; num2) { result = num1 } else { result = num2 } return result } // 返回多个类型的值 func swap(x int, y string) (string, int) { return y, x } // 有名返回值 func Size(rect image.Rectangle) (width, height int, err error) 在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值（函数调用必须按照声明顺序为所有参数提供实参）。函数的形参和有 名返回值（也就是对返回值命名）作为函数最外层的局部变量，被存储在相同的词法块中。</description>
    </item>
    
    <item>
      <title>包</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/package/</guid>
      <description>包#Go 语言的包与其他语言的 modules 或者 libraries 类似。Go 语言有超过 100个 的标准包，可以使用 go list std | wc -l 查看包的数量。
更多 Go 语言开源包，可以在 这里 搜索。
Go 语言编译速度很快，主要依赖下面三点：
导入的包必须在文件的头部显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。 禁止包的循环依赖，每个包可以被独立编译，而且很可能是被并发编译。 编译后包的目标文件不仅仅记录包本身的导出信息，同时还记录了包的依赖关系。 因此，在编译一个包的时候，编译器只需读取每个导入包的目标文件，而不需要遍历所有依赖的的文件。 import#在 package 声明下面，我们需要导入一系列需要使用的包。比如 import &amp;quot;fmt&amp;quot;。注意如果导入了不需要的包，或者缺少了必要的包， 编译会失败。
// 导入一个包 import &amp;#34;fmt&amp;#34; // 导入多个 import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) main#main 是一个特殊的包，main 包代表一个独立运行的程序，而不是一个 modules 或者 libraries。main 包里 必须有 main 函数，这个是程序的入口函数，并且 mian 函数没有参数。比如：
func main() { fmt.Println(&amp;#34;Hello, 世界&amp;#34;) } hello world#package main import &amp;#34;fmt&amp;#34; func main() { fmt.</description>
    </item>
    
    <item>
      <title>反射</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/reflect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/reflect/</guid>
      <description>反射#反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道 这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。
reflect.TypeOf#reflect.TypeOf 获取类型信息。 reflect.TypeOf 接受任意的 interface{} 类型, 并以 reflect.Type 形式返回其动态类型：
t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; type X int func main() { var a X = 20 t := reflect.TypeOf(a) fmt.Println(t.Name(), t.Kind()) // X int } 上面的代码，注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型。所以在判断类型时， 要选择正确的方式。
type X int type Y int func main() { var a, b X = 10, 20 var c Y = 30 ta, tb, tc := reflect.</description>
    </item>
    
    <item>
      <title>变量</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/var/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/var/</guid>
      <description>变量#var 声明变量，必须使用空格隔开：
var 变量名字 类型 = 表达式 类型或者表达式可以省略其中的一个。也就是如果没有类型，可以通过表达式推断出类型，没有表达式，将会根据类型初始化为对应的零值。
零值 并不是空值，而是一种“变量未填充前”的默认值，通常为 0，对应关系：
数值类型：0 布尔类型：false 字符串: &amp;quot;&amp;quot; 接口或引用类型（包括 slice、指针、map、chan 和函数）：nil 注意：
map 的零值是 nil， 也就是或如果用 var testMap map[string]string 的方式声明，是不能直接通过 unmarshal 或 map[key] 操 作，应该使用 make 函数。 slice 的零值是 nil，不能直接通过下标操作。应该使用 make 函数。 对于 struct 的指针，要注意使用 var testStruct *testResponse的方式声明，如果 testResponse 内嵌套结构体指针，unmarshal 会失败，因为指针的零值是 nil，应该使用 testStruct := &amp;amp;testResponse{} 的方式。 声明一组变量#var 变量名字, 变量名字, 变量名字 ... 类型 = 表达式, 表达式, 表达式, ... 比如：</description>
    </item>
    
    <item>
      <title>同步和锁</title>
      <link>http://shipengqi.github.io/golang-learn/docs/concurrent/sync_lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/concurrent/sync_lock/</guid>
      <description>同步和锁#channel 不是用来代替锁的，channel 倾向于解决逻辑层次的并发处理，而锁用来保护局部范围的数据安全。
共享变量#无论任何时候，只要有两个以上 goroutine 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。 避免数据竞争的三种方式：
不去写变量。读取不可能出现数据竞争。 避免从多个 goroutine 访问变量，尽量把变量限定在了一个单独的 goroutine 中。(不要使用共享数据来通信，使用通信 来共享数据) 互斥锁 同步锁#Go 语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex，前者是互斥锁，后者是读写锁。
互斥锁#使用 channel 实现互斥锁#我们可以使用容量只有 1 的 channel 来保证最多只有一个 goroutine 在同一时刻访问一个共享变量：
var ( sema = make(chan struct{}, 1) // a binary semaphore guarding balance balance int ) func Deposit(amount int) { sema &amp;lt;- struct{}{} // acquire lock balance = balance + amount &amp;lt;-sema // release lock } func Balance() int { sema &amp;lt;- struct{}{} // acquire lock b := balance &amp;lt;-sema // release lock return b } sync.</description>
    </item>
    
    <item>
      <title>垃圾回收</title>
      <link>http://shipengqi.github.io/golang-learn/docs/advance/gc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/advance/gc/</guid>
      <description>Go 语言中使用的垃圾回收使用的是标记清扫算法。标记清理最典型的做法是三⾊标记。进行垃圾回收时会 STW(stop the world）， 就是 runtime 把所有的线程全部冻结掉，意味着⽤户逻辑都是暂停的，所有的⽤户对象都不会被修改了，这时候去扫描肯定是安全的， 对象要么活着要么死着，所以会造成中间暂停时间可能会很⻓，⽤户逻辑对于⽤户的反应就中⽌了。
Go GC 的基本特征：非分代，非紧缩，写屏障，并发标记清理。
三色标记和写屏障#白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收； 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象； 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；
三色标记算法原理如下：
起初所有对象都是白色。 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。 重复 3，直到灰色对象队列为空。 扫描和标记完成后，只剩下白色（待回收）和黑色（活跃对象）的对象，清理操作将白色对象内存回收。
在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。
因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW。在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。
本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性
屏障技术#想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：
强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象； 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径 遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性。而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。
垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。
增量和并发#增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间
增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序对内存的修改都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只有优点的。
并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响
虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。
何时触发 GC#垃圾回收器在初始化时，设置 gcpercent 和 next_gc 阈值。</description>
    </item>
    
    <item>
      <title>基础据类型</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/basic_data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/basic_data/</guid>
      <description>数值类型#整型#uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数#float32，IEEE-754 32 位浮点型数，math.</description>
    </item>
    
    <item>
      <title>常量</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/constant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/constant/</guid>
      <description>常量#const 声明常量，运行时不可改变（只读），注意常量的底层数据类型只能是基础类型（布尔型、数值型和字符串型）：
const 常量名字 类型 = 表达式 &amp;ldquo;类型&amp;quot;可以省略。也就是如果没有类型，可以通过表达式推导出类型。
比如：
// 声明一个`string`类型 const b string = &amp;#34;abc&amp;#34; const a = &amp;#34;abc&amp;#34; // 声明一组不同类型 const c, f, s = true, 2.3, &amp;#34;four&amp;#34; // bool, float64, string // 批量声明多个常量 const ( Unknown = 0 Female = 1 Male = 2 ) const strSize = len(&amp;#34;hello, world&amp;#34;) 常量表达式的值在编译期计算。因此常量表达式中，函数必须是内置函数。如 unsafe.Sizeof()，len(), cap()。 也就是说常量并不是像变量一样在运行期分配内存，通常在编译器预处理阶段，作为指令数据使用。
常量组中，如果不指定类型和初始值，那么就和上一行非空常量右值相同： 例如：
const ( a = 1 b c = 2 d ) fmt.</description>
    </item>
    
    <item>
      <title>并发和并行</title>
      <link>http://shipengqi.github.io/golang-learn/docs/concurrent/concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/concurrent/concurrent/</guid>
      <description>并发和并行的区别：
并发：逻辑上具备同时处理多个任务的能力 并行：物理上同时处理多个并发任务的能力 并发#一个 cpu 上能同时执行多项任务，在很短时间内，cpu 来回切换任务执行(在某段很短时间内执行程序 a，然后又迅速得切换到程序 b 去执行)， 有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是并发。
并行#当系统有多个 CPU 时,每个 CPU 同一时刻都运行任务，互不抢占自己所在的 CPU 资源，同时进行，称为并行。并行是并发设计的 理想模式。
进程#cpu 在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的 context &amp;ndash;上下文），直接切换下一个程序，就会丢失上一个 程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单 位（也可以说是程序运行的一个实体）。
线程#cpu 切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程 一旦多起来，cpu 调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不 会那么像进程切换那么耗费资源。
协程#多线程和多进程是并行的基本条件，但是单线程可以利用协程做到并发。协程拥有自己的寄存器上下文和栈。协程在线程上通过主动 切换来实现并发，减少了阻塞时间，还避免了线程切换的开销。但协程运行的并发本质上还是串行的。线程和进程的操作是由程序触发系统 接口，最后的执行者是系统；协程的操作执行者则是用户自身程序。
https://segmentfault.com/a/1190000003063859</description>
    </item>
    
    <item>
      <title>序列化</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/json/</guid>
      <description>序列化#Go 对于其他序列化协议如 Json，XML，Protocol Buffers，都有良好的支持，
由标准库中的 encoding/json、encoding/xml、encoding/asn1 等包提供支持，Protocol Buffers 的 由 github.com/golang/protobuf 包提供支持，并且这类包都有着相似的 API 接口。
GO 中结构体转为 JSON 使用 json.Marshal，也就是编码操作：
type Movie struct { Title string Year int `json:&amp;#34;released&amp;#34;` Color bool `json:&amp;#34;color,omitempty&amp;#34;` Actors []string Actors []string } var movies = []Movie{ { Title: &amp;#34;Casablanca&amp;#34;, Year: 1942, Color: false, Actors: []string{&amp;#34;Humphrey Bogart&amp;#34;, &amp;#34;Ingrid Bergman&amp;#34;}}, { Title: &amp;#34;Cool Hand Luke&amp;#34;, Year: 1967, Color: true, Actors: []string{&amp;#34;Paul Newman&amp;#34;}}, { Title: &amp;#34;Bullitt&amp;#34;, Year: 1968, Color: true, Actors: []string{&amp;#34;Steve McQueen&amp;#34;, &amp;#34;Jacqueline Bisset&amp;#34;}}}	data, err := json.</description>
    </item>
    
    <item>
      <title>指针</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/pointer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/pointer/</guid>
      <description>指针#指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个 保存内存地址的整形变量。
x := 1 p := &amp;amp;x // p, of type *int, points to x fmt.Println(*p) // &amp;#34;1&amp;#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &amp;#34;2&amp;#34; 上面的代码，初始化一个变量 x，&amp;amp; 是取地址操作，&amp;amp;x 就是取变量 x 的内存地址，那么 p 就是一个指针， 类型是 *int，p 这个指针保存了变量 x 的内存地址。接下来 *p 表示读取指针指向的变量的值，也就是变量 x 的值 1。 *p也可以被赋值。
任何类型的指针的零值都是 nil。当指针指向同一个变量或者 nil 时是相等的。 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
指向指针的指针#var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;amp;a /* 指向指针 ptr 地址 */ pptr = &amp;amp;ptr /* 获取 pptr 的值 */ fmt.</description>
    </item>
    
    <item>
      <title>接口</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/interface/</guid>
      <description>Go 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实 现了这个接口，无须显示声明。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。
一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。
接口的零值就是它的类型和值的部分都是 nil。
简单的说，interface 是一组 method 的组合，我们通过 interface 来定义对象的一组行为。
定义接口：
type 接口名 interface { 方法名1 [返回类型] 方法名2 [返回类型] 方法名3 [返回类型] ... } /* 定义结构体 */ type struct_name struct { /* variables */ } /* 实现接口方法 */ func (struct_name_variable struct_name) 方法名1() [返回类型] { /* 方法实现 */ } ... func (struct_name_variable struct_name) 方法名2() [返回类型] { /* 方法实现*/ } 实例：
type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.</description>
    </item>
    
    <item>
      <title>控制语句</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/flow/</guid>
      <description>if#if 布尔表达式 { } if&amp;hellip;else#if 布尔表达式 { } else { } switch#switch var1 { case val1: ... // 不需要显示的 break，case 执行完会自动中断 case val2: ... case val3,val4,...: default: ... } val1,val2 &amp;hellip; 类型不被局限于常量或整数，但必须是相同的类型。
switch 语句，你要明白其中的 case 表达式的所有子表达式的结果值都是要与 switch 表达式的结果值判等的，因此它们的类型必须相 同或者能够都统一到 switch 表达式的结果类型。 如果无法做到，那么这条 switch 语句就不能通过编译。
switch语句在 case 子句的选择上是具有唯一性的。正因为如此，switch 语句不允许 case 表达式中的子表达式结果值存 在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的 case 表达式中，都会是这样的结果。
普通 case 子句的编写顺序很重要，最上边的 case 子句中的子表达式总是会被最先求值，在判等的时候顺序也是这样。因此， 如果某些子表达式的结果值有重复并且它们与 switch 表达式的结果值相等，那么位置靠上的 case 子句总会被选中。</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/array/</guid>
      <description>数组是一个由固定长度的指定类型元素组成的序列。数组的长度在编译阶段确定。数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。
声明数组：
var 变量名 [SIZE]类型 内置函数 len 获取数组长度。通过下标访问元素：
var a [3]int // array of 3 integers fmt.Println(a[0]) // print the first element fmt.Println(a[len(a)-1]) // print the last element, a[2] 默认情况下，数组的每个元素都被初始化为元素类型对应的零值。 初始化数组：
var q [3]int = [3]int{1, 2, 3} var r [3]int = [3]int{1, 2} fmt.Println(r[2]) // &amp;#34;0&amp;#34; var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0} mt.Println(len(balance)) // 5 var balance2 = []float32 fmt.Println(len(balance2)) // type []float32 is not an expression q := [.</description>
    </item>
    
    <item>
      <title>测试</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/test/</guid>
      <description>go test 命令测试代码，包目录内，所有以 _test.go 为后缀名的源文件在执行 go build 时不会被构建成包的一部分， 它们是 go test 测试的一部分。
在 *_test.go 文件中，有三种类型的函数：
测试函数，测试程序的一些逻辑行为是否正确。go test 命令会调用这些测试函数并报告测试结果是 PASS 或 FAIL。 基准测试函数，衡量一些函数的性能。go test 命令会多次运行基准函数以计算一个平均的执行时间。 示例函数，提供一个由编译器保证正确性的示例文档。 go test 会生成一个临时 main 包调用测试函数。 参数
-v，打印每个测试函数的名字和运行时间。 -run，指定一个正则表达式，只有匹配到的测试函数名才会被 go test 运行，如 go test -v -run=&amp;quot;French|Canal&amp;quot;。 -cover，测试覆盖率。 -bench，运行基准测试。例如 go test -bench=.（如果在 Windows Powershell 环境下使用 go test -bench=&amp;quot;.&amp;quot;） -c，生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为 pkg.test，其中的 pkg 即为被测试代码包的 导入路径的最后一个元素的名称。 -i，安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。 -o，指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记 -c 或 -i。 测试函数#测试函数必须导入 testing 包，并以 Test 为函数名前缀，后缀名必须以大写字母开头，并且参数列表中只应有一个 *testing.T 类型的参数声明：</description>
    </item>
    
    <item>
      <title>结构体</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/struct/</guid>
      <description>结构体#结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 结构体定义需要使用 type 和 struct 语句, struct 语句定义一个新的数据类型, type 语句定义了结构体的名称：
// 定义了结构体类型 type struct_variable_type struct { member definition; member definition; ... member definition; } variable_name := structure_variable_type{value1, value2...valuen} // 或 variable_name := structure_variable_type{ key1: value1, key2: value2..., keyn: valuen} 用点号 . 操作符访问结构体成员, 实例：
type Books struct { title string author string subject string book_id int } func main() { var Book1 Books /* 声明 Book1 为 Books 类型 */ /* book 1 描述 */ Book1.</description>
    </item>
    
    <item>
      <title>运算符</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/operator/</guid>
      <description>运算符#优先级#*，/，%，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;amp;，&amp;amp;^ +，-，|，^ ==，!=，&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt;= &amp;amp;&amp;amp; || 上面的运算符得优先级，从上到下，从左到右。也就是 * 的优先级最高，|| 的优先级最低。
算术运算符#+、-、* 和 / 可以适用于整数、浮点数和复数。
在 Go 中，% 取模运算符的符号和被取模数的符号总是一致的，因此 -5 % 3 和 -5 % -3 结果都是 -2。% 仅用于整数间的运算。除法运算符 / 的行为则依赖于操作数是否为全为整数，比如 5.0/4.0 的结果是 1.25，但是 5/4 的结果是 1，因为整数除法会向着 0 方向截断余数。
++ 自增，-- 自减
关系运算符#==，!=，&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt;=。
布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 == 和 != 进行比较。
逻辑运算符#&amp;amp;&amp;amp;，||，!（逻辑 NOT 运算符）。
位运算符#&amp;amp;，|，^，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;amp;^（位清空 AND NOT）
&amp;amp;^：如果对应 y 中 bit 位为 1 的话, 表达式 z = x &amp;amp;^ y 结果 z 的对应的 bit 位为 0，否则 z 对应的 bit 位等于 x 相应的 bit 位的值。如：</description>
    </item>
    
    <item>
      <title>错误</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/error/</guid>
      <description>错误#error 类型#error 类型是内置的接口类型。error 类型可能是 nil 或者 non-nil，nil 表示成功。
错误处理#当函数调用返回错误时，最常用的处理方式是传播错误，如。
resp, err := http.Get(url) if err != nil{ // 将这个HTTP错误返回给调用者 return nil, err } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { // fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回 // 使用该函数前缀添加额外的上下文信息到原始错误信息。 return nil, fmt.Errorf(&amp;#34;parsing %s as HTML: %v&amp;#34;, url,err) } 由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。
编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内 的同一组函数返回的错误在构成和处理方式上是相似的。
根据不同的场景，我们可能要对错误做些特殊处理，比如错误重试机制，或者打印错误日志，或者直接忽略错误。
文件结尾错误#io 包在任何由文件结束引起的读取失败都返回同一个错误 io.EOF：
in := bufio.NewReader(os.Stdin) for { r, _, err := in.</description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/oop/</guid>
      <description>GO 支持面向对象编程。
方法#方法声明：
func (变量名 类型) 方法名() [返回类型]{ /* 函数体*/ } 实例：
/* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&amp;#34;Area of Circle(c1) = &amp;#34;, c1.getArea()) } // 该 method 属于 Circle 类型对象中的方法 // 这里的 c 叫作方法的接收器，类似 Javascript 的 this func (c Circle) getArea() float64 { // c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.radius * c.radius } Go 没有像其它语言那样用 this 或者 self 作为接收器。Go 可以给任意类型定义方法。</description>
    </item>
    
  </channel>
</rss>
