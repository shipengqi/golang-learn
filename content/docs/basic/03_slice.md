---
title: 切片
weight: 3
---

# 切片

切片 (slice) 在使用上和数组差不多，区别是切片是**可变长**的，定义的时候不需要指定 size。

## 初始化

初始化切片有三种方式：

1. 使用 `make`
   ```go
    // len 是切片的初始长度
    // capacity 为可选参数, 指定容量
    s := make([]int, len, capacity)
   ```
2. 使用字面量
   ```go
   arr :=[]int{1,2,3}
   ```
3. 使用下标截取数组或者切片的一部分，这里可以传入三个参数 `[low:high:max]`，`max - low` 是新的切片的容量 cap。
   ```go
   numbers := []int{0,1,2,3,4,5,6,7,8}
   s := numbers[1:4] // [1 2 3]
   s := numbers[4:] // [4 5 6 7 8]
   s := numbers[:3]) // [0 1 2]
   ```



切片的结构体：

```go
// src/reflect/value.go
type SliceHeader struct {
	Data uintptr // 指向底层数组
	Len  int     // 长度
	Cap  int     // 当前切片容量
}
```

### 切片是如何扩容的？ 

`append` 是用来向 slice 追加元素的，并**返回一个新的 slice**。

`append` 实际上就是向底层数组添加元素，但是数组的长度是固定的：

1. 当追加元素后长度大于底层数组的长度，slice 会
2. 当追加元素后长度大于底层数组的长度，slice 会
3. 


## 长度和容量

`Slice` 有两个比较混淆的概念，就是长度和容量。这个长度跟数组的长度是一个概念，即在内存中进行了初始化实际存在的元素的个数。

何谓容量？

如果通过 `make` 函数创建 `Slice` 的时候指定了容量参数，那内存管理器会根据指定的容量的值先划分一块内存空间，然后才在其中存放有数组元素，多余部分处于空闲状态，在 `Slice` 上追加元素的时候，首先会放到这块空闲的内存中，如果添加的参数个数超过了容量值，内存管理器会重新划分一块容量值为原容量值 `*2` 大小的内存空间，依次类推。这个机制的好处在能够提升运算性能，因为内存的重新划分会降低性能。


## 怎样估算切片容量的增长

一旦**一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中**。一般的情况下，你**可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍**。

但是，当原切片的长度（以下简称原长度）大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与 1.25 相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会、比新长度大一些，当然，相等也是可能的。

一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。它是把新的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。

**在无需扩容时，`append` 函数返回的是指向“原底层数组”的新切片，而在需要扩容时，`append` 函数返回的是指向“新底层数组”的新切片**。

在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于 1024 就会将容量翻倍；
- 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；
