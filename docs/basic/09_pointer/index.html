<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="指针 # 指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个 保存内存地址的整形变量。
x := 1 p := &amp;x // p, of type *int, points to x fmt.Println(*p) // &#34;1&#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &#34;2&#34; 上面的代码，初始化一个变量 x，& 是取地址操作，&amp;x 就是取变量 x 的内存地址，那么 p 就是一个指针， 类型是 *int，p 这个指针保存了变量 x 的内存地址。接下来 *p 表示读取指针指向的变量的值，也就是变量 x 的值 1。 *p也可以被赋值。
任何类型的指针的零值都是 nil。当指针指向同一个变量或者 nil 时是相等的。 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
指向指针的指针 # var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;a /* 指向指针 ptr 地址 */ pptr = &amp;ptr /* 获取 pptr 的值 */ fmt."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="指针"><meta property="og:description" content="指针 # 指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个 保存内存地址的整形变量。
x := 1 p := &amp;x // p, of type *int, points to x fmt.Println(*p) // &#34;1&#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &#34;2&#34; 上面的代码，初始化一个变量 x，& 是取地址操作，&amp;x 就是取变量 x 的内存地址，那么 p 就是一个指针， 类型是 *int，p 这个指针保存了变量 x 的内存地址。接下来 *p 表示读取指针指向的变量的值，也就是变量 x 的值 1。 *p也可以被赋值。
任何类型的指针的零值都是 nil。当指针指向同一个变量或者 nil 时是相等的。 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
指向指针的指针 # var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;a /* 指向指针 ptr 地址 */ pptr = &amp;ptr /* 获取 pptr 的值 */ fmt."><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-15T17:52:38+08:00"><title>指针 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.be9b99fd8d24644b00dc1ccdf4499458237a0c707fb70c097160e0299b550984.js integrity="sha256-vpuZ/Y0kZEsA3BzN9EmUWCN6DHB/twwJcWDgKZtVCYQ=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>map</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/ class=active>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_netpooler/>网络轮询器</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>指针</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#指针>指针</a><ul><li><a href=#指向指针的指针>指向指针的指针</a></li><li><a href=#为什么需要指针>为什么需要指针</a><ul><li><a href=#struct><code>struct</code></a></li><li><a href=#slice><code>slice</code></a></li><li><a href=#map>map</a></li></ul></li><li><a href=#哪些值是不可寻址的>哪些值是不可寻址的</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=指针>指针
<a class=anchor href=#%e6%8c%87%e9%92%88>#</a></h1><p><strong>指针和内存地址不能混为一谈</strong>。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个
保存内存地址的整形变量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>x</span>         <span style=color:#75715e>// p, of type *int, points to x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) <span style=color:#75715e>// &#34;1&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>*</span><span style=color:#a6e22e>p</span> = <span style=color:#ae81ff>2</span>          <span style=color:#75715e>// equivalent to x = 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>)  <span style=color:#75715e>// &#34;2&#34;
</span></span></span></code></pre></div><p>上面的代码，初始化一个变量 <code>x</code>，<code>&</code> 是取地址操作，<code>&amp;x</code> 就是取变量 <code>x</code> 的内存地址，那么 <code>p</code> 就是一个指针，
类型是 <code>*int</code>，<code>p</code> 这个指针保存了变量 <code>x</code> 的内存地址。接下来 <code>*p</code> 表示读取指针指向的变量的值，也就是变量 <code>x</code> 的值 1。
<code>*p</code>也可以被赋值。</p><p>任何类型的指针的零值都是 <code>nil</code>。当指针指向同一个变量或者 <code>nil</code> 时是相等的。
当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>。<code>nil</code> 指针也称为空指针。</p><h2 id=指向指针的指针>指向指针的指针
<a class=anchor href=#%e6%8c%87%e5%90%91%e6%8c%87%e9%92%88%e7%9a%84%e6%8c%87%e9%92%88>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pptr</span> <span style=color:#f92672>**</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 指针 ptr 地址 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 指向指针 ptr 地址 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pptr</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 获取 pptr 的值 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;变量 a = %d\n&#34;</span>, <span style=color:#a6e22e>a</span> )
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;指针变量 *ptr = %d\n&#34;</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>ptr</span> )
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;指向指针的指针变量 **pptr = %d\n&#34;</span>, <span style=color:#f92672>**</span><span style=color:#a6e22e>pptr</span>)
</span></span></code></pre></div><h2 id=为什么需要指针>为什么需要指针
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%8c%87%e9%92%88>#</a></h2><p>相比 Java，Python，Javascript 等引用类型的语言，Golang 拥有类似C语言的指针这个相对古老的特性。但不同于 C 语言，Golang 的指
针是单独的类型，而且也不能对指针做整数运算。从这一点看，Golang 的指针基本就是一种引用。</p><p>在学习引用类型语言的时候，总是要先搞清楚，当给一个 <code>函数/方法</code> 传参的时候，传进去的是值还是引用。实际上，在大部分引用型语言里，
参数为基本类型时，传进去的大都是值，也就是另外复制了一份参数到当前的函数调用栈。参数为高级类型时，传进去的基本都是引用。</p><p>内存管理中的内存区域一般包括 <code>heap</code> 和 <code>stack</code>，<code>stack</code> 主要用来存储当前调用栈用到的简单类型数据：<code>string</code>，<code>boolean</code>，
<code>int</code>，<code>float</code> 等。这些类型的内存占用小，容易回收，基本上它们的值和指针占用的空间差不多，因此可以直接复制，<code>GC</code> 也比较容易做针对性的
优化。复杂的高级类型占用的内存往往相对较大，存储在 <code>heap</code> 中，<code>GC</code> 回收频率相对较低，代价也较大，因此传 <code>引用/指针</code> 可以避免进行成本较
高的复制操作，并且节省内存，提高程序运行效率。</p><p>因此，在下列情况可以考虑使用指针：</p><ol><li><strong>需要改变参数的值</strong></li><li><strong>避免复制操作</strong></li><li><strong>节省内存</strong></li></ol><p>而在 Golang 中，具体到高级类型 <code>struct</code>，<code>slice</code>，<code>map</code> 也各有不同。实际上，只有 <code>struct</code> 的使用有点复杂，<strong><code>slice</code>，<code>map</code>，
<code>chan</code>都可以直接使用，不用考虑是值还是指针</strong>。</p><h3 id=struct><code>struct</code>
<a class=anchor href=#struct>#</a></h3><p>对于函数（<code>function</code>），由函数的参数类型指定，传入的参数的类型不对会报错，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>passValue</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>struct</span>){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>passPointer</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>struct</span>){}
</span></span></code></pre></div><p>对于方法（<code>method</code>），接收者（<code>receiver</code>）可以是指针，也可以是值，Golang 会在传递参数前自动适配以符合参数的类型。也就是：如果方法的参数
是值，那么按照传值的方式 ，方法内部对 <code>struct</code> 的改动无法作用在外部的变量上，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyPoint</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>X</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Y</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>printFuncValue</span>(<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>MyPoint</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>X</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Y</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; -&gt; %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>printFuncPointer</span>(<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyPoint</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>X</span> = <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 实际上应该写做 (*pp).X，Golang 给了语法糖，减少了麻烦，但是也导致了 * 的不一致
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>Y</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; -&gt; %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>MyPoint</span>) <span style=color:#a6e22e>printMethodValue</span>(){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>X</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Y</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; -&gt; %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 建议使用指针作为方法（method：printMethodPointer）的接收者（receiver：*MyPoint），一是可以修改接收者的值，二是可以避免大对象的复制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyPoint</span>) <span style=color:#a6e22e>printMethodPointer</span>(){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>X</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>Y</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; -&gt; %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>MyPoint</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>MyPoint</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n value to func(value): %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printFuncValue</span>(<span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; --&gt; %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Output: value to func(value): {0 0} -&gt; {1 1} --&gt; {0 0}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//printFuncValue(pp) // cannot use pp (type *MyPoint) as type MyPoint in argument to printFuncValue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//printFuncPointer(p) // cannot use p (type MyPoint) as type *MyPoint in argument to printFuncPointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n pointer to func(pointer): %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printFuncPointer</span>(<span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; --&gt; %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Output: pointer to func(pointer): &amp;{0 0} -&gt; &amp;{1 1} --&gt; &amp;{1 1}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n value to method(value): %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>printMethodValue</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; --&gt; %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Output: value to method(value): {0 0} -&gt; {1 1} --&gt; {0 0}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n value to method(pointer): %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>printMethodPointer</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; --&gt; %v&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Output: value to method(pointer): {0 0} -&gt; &amp;{1 1} --&gt; {1 1}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n pointer to method(value): %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>printMethodValue</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; --&gt; %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Output: pointer to method(value): &amp;{1 1} -&gt; {2 2} --&gt; &amp;{1 1}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n pointer to method(pointer): %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>printMethodPointer</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34; --&gt; %v&#34;</span>, <span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Output: pointer to method(pointer): &amp;{1 1} -&gt; &amp;{2 2} --&gt; &amp;{2 2}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=slice><code>slice</code>
<a class=anchor href=#slice>#</a></h3><p><strong><code>slice</code> 实际上相当于对其依附的 <code>array</code> 的引用，它不存储数据，只是对 <code>array</code> 进行描述。因此，修改 <code>slice</code> 中的元素，
改变会体现在 <code>array</code> 上，当然也会体现在该 <code>array</code> 的所有 <code>slice</code> 上</strong>。</p><h3 id=map>map
<a class=anchor href=#map>#</a></h3><p><strong>使用 <code>make(map[string]string)</code> 返回的本身是个引用，可以直接用来操作</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>map</span>[<span style=color:#e6db74>&#34;name&#34;</span>]=<span style=color:#e6db74>&#34;Jason&#34;</span>
</span></span></code></pre></div><p>而<strong>如果使用 <code>map</code> 的指针，反而会产生错误</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>*</span><span style=color:#66d9ef>map</span>[<span style=color:#e6db74>&#34;name&#34;</span>]=<span style=color:#e6db74>&#34;Jason&#34;</span>  <span style=color:#75715e>//  invalid indirect of m[&#34;title&#34;] (type string)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>map</span>)[<span style=color:#e6db74>&#34;name&#34;</span>]=<span style=color:#e6db74>&#34;Jason&#34;</span>  <span style=color:#75715e>// invalid indirect of m (type map[string]string)
</span></span></span></code></pre></div><h2 id=哪些值是不可寻址的>哪些值是不可寻址的
<a class=anchor href=#%e5%93%aa%e4%ba%9b%e5%80%bc%e6%98%af%e4%b8%8d%e5%8f%af%e5%af%bb%e5%9d%80%e7%9a%84>#</a></h2><ol><li><strong>不可变的值不可寻址</strong>。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。
其实这样规定也有安全性方面的考虑。</li><li>绝大多数被视为<strong>临时结果的值都是不可寻址的</strong>。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。
但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。函数的返回值也是临时结果。<code>++</code> 和 <code>--</code> 并不属
于操作符。</li><li><strong>不安全的值不可寻址</strong>，若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的。由于字典的内部机制，对字典的索
引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/e2c1b9369331db41bcc14cb50249d04165b4bc8c title='Last modified by shipengqi | October 15, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 15, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/basic/09_pointer.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#指针>指针</a><ul><li><a href=#指向指针的指针>指向指针的指针</a></li><li><a href=#为什么需要指针>为什么需要指针</a><ul><li><a href=#struct><code>struct</code></a></li><li><a href=#slice><code>slice</code></a></li><li><a href=#map>map</a></li></ul></li><li><a href=#哪些值是不可寻址的>哪些值是不可寻址的</a></li></ul></li></ul></nav></div></aside></main></body></html>