<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🛠️ 实践 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/docs/practice/</link><description>Recent content in 🛠️ 实践 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/docs/practice/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 编译</title><link>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</guid><description>Go 编译 # 条件编译 # Go 支持两种条件编译方式：
编译标签（build tag） 文件后缀 编译标签 # 编译标签的规则：
空格表示：AND 逗号表示：OR` ! 表示：NOT 换行表示：AND 每个条件项的名字用 &amp;ldquo;字母+数字&amp;rdquo; 表示。主要支持以下几种条件：
操作系统，例如：windows、linux 等，对应 runtime.GOOS 的值。 计算机架构，例如：amd64、386，对应 runtime.GOARCH 的值。 编译器，例如：gccgo、gc，是否开启 CGO,cgo。 Go 版本，例如：go1.19、go1.20 等。 自定义的标签，例如：编译时通过指定 -tags 传入的值。 //go:build ignore，编译时自动忽略该文件 go:build 之后必须有空行，否则会被编译器当做普通注释。
//go:build linux,386 darwin,!cgo package testpkg 运算表达式为：(linux &amp;amp;&amp;amp; 386) || (darwin &amp;amp;&amp;amp; !cgo)。
自定义 tag 只需要在 go build 指令后用 -tags 指定编译条件即可
go build -tags mytag1 mytag2 对于 -tags，多个标签既可以用逗号分隔，也可以用空格分隔，但它们都表示&amp;quot;与&amp;quot;的关系。早期 go 版本用空格分隔，后来改成了用逗号分隔，但空格依然可以识别。</description></item><item><title>Go 数据竞争检测器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</guid><description>Go 数据竞争检测器 # 数据竞争是并发系统中最常见，同时也最难处理的 Bug 类型之一。数据竞争会在两个 goroutine 并发访问同一个变量，且至少有一个访问为写入时产生。
下面是一个会导致程序崩溃的例子：
package main import &amp;#34;fmt&amp;#34; func main() { c := make(chan bool) m := make(map[string]string) go func() { m[&amp;#34;1&amp;#34;] = &amp;#34;a&amp;#34; // 第一个冲突的访问 c &amp;lt;- true }() m[&amp;#34;2&amp;#34;] = &amp;#34;b&amp;#34; // 第二个冲突的访问 &amp;lt;-c for k, v := range m { fmt.Println(k, v) } } 运行 go run -race ./main.go 程序会马上崩溃：
================== WARNING: DATA RACE Write at 0x00c00010a090 by goroutine 7: runtime.mapassign_faststr() /usr/local/go/src/runtime/map_faststr.</description></item><item><title>Go 性能分析（上）</title><link>https://shipengqi.github.io/golang-learn/docs/practice/04_pprof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/04_pprof/</guid><description>Go 性能分析（上） # Go 提供的 pprof 工具可以用来做性能分析。pprof 可以读取分析样本的集合，并生成报告以可视化并帮助分析数据。
pprof 可以用于：
CPU 分析（CPU Profiling）：按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期 时花费时间的位置。 内存分析（Memory Profiling）：在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 阻塞分析（Block Profiling）：记录 goroutine 阻塞等待同步（包括定时器通道）的位置。 互斥锁分析（Mutex Profiling）：报告互斥锁的竞争情况。 如何生成分析样本 # 生成分析样本的三种方式：
runtime/pprof：采集程序（非 Server）的运行数据。通过调用如 runtime.StartCPUProfile, runtime.StopCPUProfile 方法生成分析样本。主要用于本地测试。 pkg/profile 封装了 runtime/pprof，使用起来更加简便。 net/http/pprof：采集 HTTP Server 的运行时数据，通过 HTTP 服务获取 Profile 分析样本，底层还是调用的 runtime/pprof。主要用于服务器端测试。 go test -bench：使用 go test -bench=. -cpuprofile cpuprofile.out ... 运行基准测试来生成分析样本，可以指定所需标识来进行数据采集。 以 net/http/pprof 为例：
package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; // net/http/pprof 注册的是默认的 mux ) var datas []string func Add(str string) string { data := []byte(str) sData := string(data) datas = append(datas, sData) return sData } func main() { go func() { for { log.</description></item><item><title>Go 性能分析（下）</title><link>https://shipengqi.github.io/golang-learn/docs/practice/05_trace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/05_trace/</guid><description>Go 性能分析（下） # Go 提供了完善的性能分析工具：pprof 和 trace。
pprof 主要适用于 CPU 占用、内存分配等资源的分析。 trace 记录了程序运行中的行为，更适合于找出程序在一段时间内正在做什么。例如指定的 goroutine 在何时执行、执行了多长时间、什么时候陷入了堵塞、什么时候解除了堵塞、GC 如何影响了 goroutine 的执行。 如何生成分析样本 # 生成 Trace 分析样本的方式主要有三种：
1. 使用 runtime/trace 标准库来生成：
package main import ( &amp;#34;os&amp;#34; &amp;#34;runtime/trace&amp;#34; ) func main() { f, err := os.Create(&amp;#34;trace.out&amp;#34;) if err != nil { panic(err) } defer f.Close() err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() ch := make(chan string) go func() { ch &amp;lt;- &amp;#34;hello&amp;#34; }() // read from channel &amp;lt;-ch } 执行程序就可以生成跟踪文件 trace.</description></item><item><title>Go 性能优化</title><link>https://shipengqi.github.io/golang-learn/docs/practice/06_performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/06_performance/</guid><description>Go 性能优化 # JSON 优化 # Go 的标准库 encoding/json 是通过反射来实现的。性能相对有些慢。 可以使用第三方库来替代标准库：
json-iterator/go，完全兼容标准库，性能有很大提升。 go-json，完全兼容标准库，性能强于 json-iterator/go。 sonic，字节开发的的 JSON 序列化/反序列化库，速度快，但是对硬件有一些要求。 实际开发中可以根据编译标签来选择 JSON 库，参考 component-base/json。
使用空结构体 # 在 Go 中空结构体 struct{} 不占据内存空间：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { fmt.Println(unsafe.Sizeof(struct{}{})) // 0 } 空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用，可以节省资源。
集合 Set # 要实现一个 Set，通常会使用 map 来实现，比如 map[string]bool。 但是对于集合来说， 只需要 map 的键，而不需要值。将值设置为 bool 类型，就会多占据 1 个字节。这个时候就可以使用空结构体 map[string]struct{}。
channel 通知 # 有时候使用 channel 不需要发送任何的数据，只用来通知 goroutine 执行任务，或结束等。这个时候就可以使用空结构体。
内存对齐 # 为什么需要内存对齐？ # CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如：</description></item><item><title>Go Core Dump 调试</title><link>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</guid><description>Go Core Dump 调试 # Go 也可以开启类似 C++ Core Dump 功能，Core Dump 是程序崩溃时的内存快照。程序崩溃时，可以帮助定位 crash 发生的原因。
开启 Core Dump 功能 # 在 Linux 中，可以通过 ulimit -c 查看 Core Dump 功能是否开启：
$ ulimit -c 0 输出为 0，表示未开启。
使用 ulimit -c [size] 来指定 core dump 文件的大小，也就是开启 Core Dump。ulimit -c unlimited 表示不限制 core dump 文件的大小。
例如，下面的命令是将 core dump 文件大小设置为 1MB：
$ ulimit -c 1048576 如何生成 Core Dump 文件 # Go 提供的环境变量 GOTRACEBACK 可以用来控制程序崩溃时输出的详细程度。可选值有：</description></item><item><title>Go Modules</title><link>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</guid><description>Go Modules # Go 在 1.11 推出了 Go Modules，这是一个新的包管理器，解决了 GOPATH 存在的问题。并且 Go 1.13 起不再推荐使用 GOPATH。
Go Modules 机制 # Go Modules 将依赖缓存放在 $GOPATH/pkg/mod 目录，并且同一个依赖的版本，只会缓存一份，供所有项目使用。
启用 Go Modules # Go 1.11 引入了环境变量 GO111MODULE 来控制是否启用 Go Modules，GO111MODULE 有三个值可选：
on 启用 Go Modules off 禁用 Go Modules auto，在 GOPATH 下的项目，使用 GOPATH，否则启用 Go Modules。 Go 1.16 之前 GO111MODULE 的默认值是 auto，Go 1.16 起 GO111MODULE 的默认值为 on。
初始化 # 初始化 Go Modules 项目，首先要开启 Go Modules，然后在项目目录下运行：</description></item><item><title>Gin 静态服务器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</guid><description>Gin 如何实现前端网页的静态服务器 # Gin 作为 Web 框架提供 API 非常方便，但是在同一个项目中，既提供 API，又要作为前端网页的静态服务器，就比较麻烦。通常 Angular (React/Vue) 项目需要在 Nginx 或者 Tomcat 转发才可以。有些小项目并不需要前后端分离，如何解决？
利用 embed 标签 # Go 1.16 增加了 embed 的标签，可以利用这个标签将静态资源打包到二进制文件中。
. ├── config ├── controller ├── model ├── options ├── pkg │ └── response │ └── response.go ├── resources │ ├── dist │ └── html.go ├── html.go ├── resource.go ├── router.go ├── server.go └── store ├── audited.go ├── groups.go ├── mysql.go ├── settings.go ├── store.</description></item><item><title>Go 远程开发调试</title><link>https://shipengqi.github.io/golang-learn/docs/practice/10_remote_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/10_remote_dev/</guid><description>Go 远程开发调试 # VS Code 是一款开源的代码编辑器，功能强大，支持远程开发调试。
搭建环境 # 要实现 Go 远程开发调试，需要先安装 Go for Visual Studio Code 插件。
VS Code 的 Remote 功能由三个插件组成，分别适用于三种不同的场景：
Remote - SSH：利用 SSH 连接远程主机进行开发。 Remote - Container：连接当前机器上的容器进行开发。 Remote - WSL：连接子系统（Windows Subsystem for Linux）进行开发。 SSH 模式的原理：
图片来自于 Visual Studio Code 官网
连接远程机器 # 安装插件 Remote SSH。
服务器需要支持 SSH 连接。
安装后，点击左下角的 Open a Remote Window，选择 Connect to Host。
点击 Add New SSH Host 配置你的远程机器，或者选择已经配置好的 Hosts。
也可以使用快捷键 F1 或者 ctrl+shift+p 打开 commands，输入 Open SSH Configuration File 直接编辑配置文件：</description></item></channel></rss>