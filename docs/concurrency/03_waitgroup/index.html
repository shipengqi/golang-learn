<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="WaitGroup # sync.WaitGroup 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。
使用 # 并发发送 HTTP 请求的示例：
requests := []*Request{...} wg := &amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r) }(request) } wg.Wait() WaitGroup 提供了三个方法：
Add：用来设置 WaitGroup 的计数值。 Done：用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。 Wait：调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。 不要把 Add 和 Wait 方法的调用放在不同的 goroutine 中执行，以免 Add 还未执行，Wait 已经退出：
var wg sync.WaitGroup go func(){ wg."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="WaitGroup"><meta property="og:description" content="WaitGroup # sync.WaitGroup 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。
使用 # 并发发送 HTTP 请求的示例：
requests := []*Request{...} wg := &amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r) }(request) } wg.Wait() WaitGroup 提供了三个方法：
Add：用来设置 WaitGroup 的计数值。 Done：用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。 Wait：调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。 不要把 Add 和 Wait 方法的调用放在不同的 goroutine 中执行，以免 Add 还未执行，Wait 已经退出：
var wg sync.WaitGroup go func(){ wg."><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-03T10:03:13+08:00"><title>WaitGroup | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.5b3b2caa04bf03c9a75447ae23c75f7d0163a4f572abe92e7249e71c90862e81.js integrity="sha256-WzssqgS/A8mnVEeuI8dffQFjpPVyq+kucknnHJCGLoE=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>map</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/ class=active>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li><li><a href=/golang-learn/docs/advance/04_netpooler/>网络轮询器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>WaitGroup</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#waitgroup>WaitGroup</a><ul><li><a href=#使用>使用</a><ul><li><a href=#syncwaitgroup-类型值中计数器的值可以小于-0-么>sync.WaitGroup 类型值中计数器的值可以小于 0 么？</a></li><li><a href=#syncwaitgroup-可以复用么>sync.WaitGroup 可以复用么？</a></li><li><a href=#wait-可以在多个-goroutine-调用多次么>Wait 可以在多个 goroutine 调用多次么？</a></li></ul></li><li><a href=#原理>原理</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=waitgroup>WaitGroup
<a class=anchor href=#waitgroup>#</a></h1><p><code>sync.WaitGroup</code> 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。</p><h2 id=使用>使用
<a class=anchor href=#%e4%bd%bf%e7%94%a8>#</a></h2><p>并发发送 HTTP 请求的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>requests</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>{<span style=color:#f92672>...</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
</span></span><span style=display:flex><span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(len(<span style=color:#a6e22e>requests</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>request</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>requests</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// res, err := service.call(r)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }(<span style=color:#a6e22e>request</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span></code></pre></div><p><code>WaitGroup</code> 提供了三个方法：</p><ul><li><code>Add</code>：用来设置 <code>WaitGroup</code> 的计数值。</li><li><code>Done</code>：用来将 <code>WaitGroup</code> 的计数值减 1，其实就是调用了 <code>Add(-1)</code>。</li><li><code>Wait</code>：调用这个方法的 <code>goroutine</code> 会一直阻塞，直到 <code>WaitGroup</code> 的计数值变为 0。</li></ul><p>不要把 <code>Add</code> 和 <code>Wait</code> 方法的调用放在不同的 goroutine 中执行，以免 <code>Add</code> 还未执行，<code>Wait</code> 已经退出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;test&#34;</span>)
</span></span><span style=display:flex><span>}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;exit.&#34;</span>)
</span></span></code></pre></div><h3 id=syncwaitgroup-类型值中计数器的值可以小于-0-么>sync.WaitGroup 类型值中计数器的值可以小于 0 么？
<a class=anchor href=#syncwaitgroup-%e7%b1%bb%e5%9e%8b%e5%80%bc%e4%b8%ad%e8%ae%a1%e6%95%b0%e5%99%a8%e7%9a%84%e5%80%bc%e5%8f%af%e4%bb%a5%e5%b0%8f%e4%ba%8e-0-%e4%b9%88>#</a></h3><p>不可以。小于 0，会引发 panic。所以尽量不要传递负数给 <code>Add</code> 方法，只通过 <code>Done</code> 来给计数值减 1。</p><h3 id=syncwaitgroup-可以复用么>sync.WaitGroup 可以复用么？
<a class=anchor href=#syncwaitgroup-%e5%8f%af%e4%bb%a5%e5%a4%8d%e7%94%a8%e4%b9%88>#</a></h3><p>可以。但是必须在 <code>Wait</code> 方法返回之后才能被重新使用。否则会引发 panic。所以尽量不要重用 <code>WaitGroup</code>。新建一个 <code>WaitGroup</code> 不会带来多大的资源
开销，重用反而更容易出错。</p><h3 id=wait-可以在多个-goroutine-调用多次么>Wait 可以在多个 goroutine 调用多次么？
<a class=anchor href=#wait-%e5%8f%af%e4%bb%a5%e5%9c%a8%e5%a4%9a%e4%b8%aa-goroutine-%e8%b0%83%e7%94%a8%e5%a4%9a%e6%ac%a1%e4%b9%88>#</a></h3><p>可以。当前 <code>sync.WaitGroup</code> 计数器的归零时，这些 goroutine 会被同时唤醒。</p><h2 id=原理>原理
<a class=anchor href=#%e5%8e%9f%e7%90%86>#</a></h2><p><code>sync.WaitGroup</code> 结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/sync/waitgroup.go#L20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WaitGroup</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>noCopy</span> <span style=color:#a6e22e>noCopy</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>state1</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>noCopy</code> 是 go 1.7 开始引入的一个静态检查机制，它只是一个辅助类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/sync/cond.go#L117
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>noCopy</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Lock is a no-op used by -copylocks checker from `go vet`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>noCopy</span>) <span style=color:#a6e22e>Lock</span>()   {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>noCopy</span>) <span style=color:#a6e22e>Unlock</span>() {}
</span></span></code></pre></div><p><code>tools/go/analysis/passes/copylock</code> 包中的分析器会在编译期间检查被拷贝的变量中是否包含 <code>noCopy</code> 或者实现了 <code>Lock</code> 和 <code>Unlock</code> 方法，如果包含该结构体或者实现了对应的方法就会报错：</p><pre tabindex=0><code>$ go vet proc.go
./prog.go:10:10: assignment copies lock value to yawg: sync.WaitGroup
./prog.go:11:14: call of fmt.Println copies lock value: sync.WaitGroup
./prog.go:11:18: call of fmt.Println copies lock value: sync.WaitGroup
</code></pre><p><code>state1</code> 包含一个总共占用 12 字节的数组，这个数组会存储当前结构体的状态，在 64 位与 32 位的机器上表现也非常不同。</p><p><img src=https://raw.githubusercontent.com/shipengqi/illustrations/3039de62b8205f48431e7568e30a26c2f16524d9/go/waitgroup-state1.png alt=waitgroup-state1></p><p><code>state</code> 方法用来从 <code>state1</code> 字段中取出它的状态和信号量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 得到 state 的地址和信号量的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>state</span>() (<span style=color:#a6e22e>statep</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>semap</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state1</span>))<span style=color:#f92672>%</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果地址是 64bit 对齐的，数组前两个元素做 state，后一个元素做信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state1</span>)), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state1</span>[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果地址是 32bit 对齐的，数组后两个元素用来做 state，它可以用来做 64bit 的原子操作，第一个元素 32bit 用来做信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state1</span>[<span style=color:#ae81ff>1</span>])), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state1</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Add</code> 的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>statep</span>, <span style=color:#a6e22e>semap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 高 32bit 是计数值 v，所以把 delta 左移 32，更新计数器 counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>state</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddUint64</span>(<span style=color:#a6e22e>statep</span>, uint64(<span style=color:#a6e22e>delta</span>)<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#75715e>// 当前计数值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#a6e22e>state</span>) <span style=color:#75715e>// waiter count
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#e6db74>&#34;sync: negative WaitGroup counter&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 并发的 Add 会导致 panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>delta</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> int32(<span style=color:#a6e22e>delta</span>) {
</span></span><span style=display:flex><span>        panic(<span style=color:#e6db74>&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 waiter 调用计数器归零，也就是 *statep 直接设置为 0 即可。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 通过 sync.runtime_Semrelease 唤醒处于等待状态的 goroutine。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>statep</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>w</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>w</span><span style=color:#f92672>--</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>runtime_Semrelease</span>(<span style=color:#a6e22e>semap</span>, <span style=color:#66d9ef>false</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Done 方法实际就是计数器减 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Done</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Wait</code> 方法的实现逻辑：不断检查 state 的值。如果其中的计数值变为了 0，那么说明所有的任务已完成，调用者不必再等待，直接返回。如果计数值大于 0，说明此时还有任
务没完成，那么调用者就变成了等待者，需要加入 waiter 队列，并且阻塞住自己。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Wait</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>statep</span>, <span style=color:#a6e22e>semap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state</span>()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>state</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUint64</span>(<span style=color:#a6e22e>statep</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#75715e>// 当前计数值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#a6e22e>state</span>) <span style=color:#75715e>// waiter 的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果计数值为 0, 调用这个方法的 goroutine 不必再等待，继续执行它后面的逻辑即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 否则把 waiter 数量加 1。期间可能有并发调用 Wait 的情况，所以最外层使用了一个 for 循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapUint64</span>(<span style=color:#a6e22e>statep</span>, <span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>state</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 阻塞休眠等待
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>runtime_Semacquire</span>(<span style=color:#a6e22e>semap</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 被唤醒，不再阻塞，返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/c3f5fc9206b580b4993549de65beb4210f2967a9 title='Last modified by PengQi Shi | November 3, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 3, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/concurrency/03_waitgroup.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#waitgroup>WaitGroup</a><ul><li><a href=#使用>使用</a><ul><li><a href=#syncwaitgroup-类型值中计数器的值可以小于-0-么>sync.WaitGroup 类型值中计数器的值可以小于 0 么？</a></li><li><a href=#syncwaitgroup-可以复用么>sync.WaitGroup 可以复用么？</a></li><li><a href=#wait-可以在多个-goroutine-调用多次么>Wait 可以在多个 goroutine 调用多次么？</a></li></ul></li><li><a href=#原理>原理</a></li></ul></li></ul></nav></div></aside></main></body></html>