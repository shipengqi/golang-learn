<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="原子操作 # Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代 码包 sync/atomic 中。
sync/atomic 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、 存储（store）和交换（swap）。
这些函数针对的数据类型并不多。对这些类型中的每一个，sync/atomic 包都会有一套函数给予支持。这些数据类型有： int32、int64、uint32、uint64、uintptr，以及 unsafe 包中的 Pointer。不过，针对 unsafe.Pointer 类型，该包并未提供进行原子加法操作的函数。
sync/atomic 包还提供了一个名为 Value 的类型，它可以被用来存储任意类型的值。
atomic.AddInt32 函数的第一个参数，为什么不是 int32 而是 *int32 呢？ 因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数， 就已经与函数外的那个值毫无关系了。
所以，传入值本身没有任何意义。unsafe.Pointer 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向 的那个值，所以需要的仍然是指向这个指针值的指针。
只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内 存地址上的数据。
比较并交换操作与交换操作相比有什么不同 # 比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。
所谓的交换指的是，把新值赋给变量，并返回变量的旧值。
CAS 操作用途要更广泛一些。例如，我们将它与 for 语句联用就可以实现一种简易的自旋锁（spinlock）。
for { if atomic.CompareAndSwapInt32(&amp;num2, 10, 0) { fmt.Println(&#34;The second number has gone to zero.&#34;) break } time.Sleep(time.Millisecond * 500) } 在 for 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 for 循环。这就相当于，只要条件未被满足， 当前的流程就会被一直“阻塞”在这里。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="原子操作"><meta property="og:description" content="原子操作 # Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代 码包 sync/atomic 中。
sync/atomic 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、 存储（store）和交换（swap）。
这些函数针对的数据类型并不多。对这些类型中的每一个，sync/atomic 包都会有一套函数给予支持。这些数据类型有： int32、int64、uint32、uint64、uintptr，以及 unsafe 包中的 Pointer。不过，针对 unsafe.Pointer 类型，该包并未提供进行原子加法操作的函数。
sync/atomic 包还提供了一个名为 Value 的类型，它可以被用来存储任意类型的值。
atomic.AddInt32 函数的第一个参数，为什么不是 int32 而是 *int32 呢？ 因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数， 就已经与函数外的那个值毫无关系了。
所以，传入值本身没有任何意义。unsafe.Pointer 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向 的那个值，所以需要的仍然是指向这个指针值的指针。
只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内 存地址上的数据。
比较并交换操作与交换操作相比有什么不同 # 比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。
所谓的交换指的是，把新值赋给变量，并返回变量的旧值。
CAS 操作用途要更广泛一些。例如，我们将它与 for 语句联用就可以实现一种简易的自旋锁（spinlock）。
for { if atomic.CompareAndSwapInt32(&amp;num2, 10, 0) { fmt.Println(&#34;The second number has gone to zero.&#34;) break } time.Sleep(time.Millisecond * 500) } 在 for 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 for 循环。这就相当于，只要条件未被满足， 当前的流程就会被一直“阻塞”在这里。"><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-31T16:48:48+08:00"><title>原子操作 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.ec43262b18c4c5bad2a2846e73f04ff636abc29077bbc6c6ffaaf560f8f9c962.js integrity="sha256-7EMmKxjExbrSooRuc/BP9jarwpB3u8bG/6r1YPj5yWI=" crossorigin=anonymous></script>
<script defer src=/golang-learn/sw.min.e9a55528e030e44ecbe1b5a8da7dd8fb40bd282d02dc4574e81b999a6a21bc84.js integrity="sha256-6aVVKOAw5E7L4bWo2n3Y+0C9KC0C3EV06BuZmmohvIQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>map</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/ class=active>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_netpooler/>网络轮询器</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>原子操作</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#原子操作>原子操作</a><ul><li><a href=#比较并交换操作与交换操作相比有什么不同>比较并交换操作与交换操作相比有什么不同</a><ul><li><a href=#aba-问题>ABA 问题</a></li></ul></li><li><a href=#syncatomicvalue><code>sync/atomic.Value</code></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=原子操作>原子操作
<a class=anchor href=#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c>#</a></h1><p>Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代
码包 <code>sync/atomic</code> 中。</p><p><code>sync/atomic</code> 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、
存储（store）和交换（swap）。</p><p>这些函数针对的数据类型并不多。对这些类型中的每一个，<code>sync/atomic</code> 包都会有一套函数给予支持。这些数据类型有：
<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>，以及 <code>unsafe</code> 包中的 <code>Pointer</code>。不过，针对
<code>unsafe.Pointer</code> 类型，该包并未提供进行原子加法操作的函数。</p><p><code>sync/atomic</code> 包还提供了一个名为 <code>Value</code> 的类型，它可以被用来存储任意类型的值。</p><p><code>atomic.AddInt32</code> 函数的第一个参数，为什么不是 <code>int32</code> 而是 <code>*int32</code> 呢？
因为<strong>原子操作函数需要的是被操作值的指针，而不是这个值本身</strong>；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，
就已经与函数外的那个值毫无关系了。</p><p>所以，传入值本身没有任何意义。<code>unsafe.Pointer</code> 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向
的那个值，所以需要的仍然是指向这个指针值的指针。</p><p>只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内
存地址上的数据。</p><h2 id=比较并交换操作与交换操作相比有什么不同>比较并交换操作与交换操作相比有什么不同
<a class=anchor href=#%e6%af%94%e8%be%83%e5%b9%b6%e4%ba%a4%e6%8d%a2%e6%93%8d%e4%bd%9c%e4%b8%8e%e4%ba%a4%e6%8d%a2%e6%93%8d%e4%bd%9c%e7%9b%b8%e6%af%94%e6%9c%89%e4%bb%80%e4%b9%88%e4%b8%8d%e5%90%8c>#</a></h2><p><strong>比较并交换操作即 CAS 操作</strong>，是有条件的交换操作，<strong>只有在条件满足的情况下才会进行值的交换</strong>。</p><p><strong>所谓的交换指的是，把新值赋给变量，并返回变量的旧值</strong>。</p><p>CAS 操作用途要更广泛一些。例如，我们将它与 <code>for</code> 语句联用就可以实现一种简易的自旋锁（spinlock）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>num2</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;The second number has gone to zero.&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 <code>for</code> 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 <code>for</code> 循环。这就相当于，只要条件未被满足，
当前的流程就会被一直“阻塞”在这里。</p><p>这在效果上与互斥锁有些类似。不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他
的 goroutine 频繁地改变。</p><p>而 <code>for</code> 语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，
或者说更加宽松的做法。</p><p><strong>假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原
子操作吗</strong>？</p><p>很有必要。其中的道理你可以对照一下读写锁。为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有
被修改完的值，对吗？</p><p>如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。</p><p>所以，一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护。不完全的保护基本上与不保护没有什么区别。</p><h3 id=aba-问题>ABA 问题
<a class=anchor href=#aba-%e9%97%ae%e9%a2%98>#</a></h3><p>2.什么是ABA问题？怎么解决？
答：当一个值从A更新为B，再从B更新为A，普通CAS机制会误判通过检测。解决方案是使用版本号，通过比较值和版本号才判断是否可以替换。</p><p><a href=https://blog.csdn.net/weixin_41832850/article/details/100095677>https://blog.csdn.net/weixin_41832850/article/details/100095677</a></p><p>添加版本号解决 ABA 问题
真正要做到严谨的CAS机制，我们在 compare 阶段不仅需要比较内存地址V中的值是否和旧的期望值A相同，还需要比较变量的版本号是否一致。</p><h2 id=syncatomicvalue><code>sync/atomic.Value</code>
<a class=anchor href=#syncatomicvalue>#</a></h2><p>此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。开箱即用。</p><p>它只有两个指针方法—— <code>Store</code> 和 <code>Load</code>。不过，虽然简单，但还是有一些值得注意的地方的。</p><ol><li>一旦 <code>atomic.Value</code> 类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。只要用它来存储值了，就相当于开始真正使用了。
<code>atomic.Value</code> 类型属于结构体类型，而结构体类型属于值类型。所以，复制该类型的值会产生一个完全分离的新值。这个新值相当于被
复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者。</li><li>不能用原子值存储 <code>nil</code>。</li><li>我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。</li><li>尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>box6</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Value</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>v6</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>box6</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#a6e22e>v6</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>v6</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#ae81ff>4</span> <span style=color:#75715e>// 注意，此处的操作不是并发安全的！
</span></span></span></code></pre></div><p>切片类型属于引用类型。所以，我在外面改动这个切片值，就等于修改了 <code>box6</code> 中存储的那个值。这相当于绕过了原子值而进行了非并发
安全的操作。怎样修补：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>store</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>v</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>replica</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>v</span>))
</span></span><span style=display:flex><span>    copy(<span style=color:#a6e22e>replica</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>box6</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#a6e22e>replica</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>store</span>(<span style=color:#a6e22e>v6</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>v6</span>[<span style=color:#ae81ff>2</span>] = <span style=color:#ae81ff>5</span> <span style=color:#75715e>// 此处的操作是安全的。
</span></span></span></code></pre></div><p>先为切片值 <code>v6</code> 创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入 <code>box6</code>。如此一来，
无论我再对 <code>v6</code> 的值做怎样的修改，都不会破坏 <code>box6</code> 提供的安全保护。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/a4eb0f2f6655107302ced27bdcfdc68f4b5920cd title='Last modified by PengQi Shi | October 31, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 31, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/concurrency/08_atomic.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#原子操作>原子操作</a><ul><li><a href=#比较并交换操作与交换操作相比有什么不同>比较并交换操作与交换操作相比有什么不同</a><ul><li><a href=#aba-问题>ABA 问题</a></li></ul></li><li><a href=#syncatomicvalue><code>sync/atomic.Value</code></a></li></ul></li></ul></nav></div></aside></main></body></html>