<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>语言基础 on Golang Learning</title>
    <link>http://shipengqi.github.io/golang-learn/docs/basic/</link>
    <description>Recent content in 语言基础 on Golang Learning</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="http://shipengqi.github.io/golang-learn/docs/basic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 环境配置</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/env_config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/env_config/</guid>
      <description>Go 环境配置#安装#Windows 下安装，官网 下载安装包，直接安装。 默认情况下 .msi 文件会安装在 c:\Go 目录下。安装完成后默认会将 c:\Go\bin 目录添加到 PATH 环境变量中。 并添加环境变量 GOROOT，值为 Go 安装根目录 C:\Go\。重启命令窗口生效。
打开 CMD 输入 go 命令，验证是否安装成功。否则检查环境变量 Path 和 GOROOT。
工作区#GOROOT#环境变量 GOROOT 用来指定 Go 的安装目录，Go 的标准库也在这个位置。目录结构与 GOPATH 类似。
GOPATH#我们安装好 Go 之后，必须配置一个环境变量 GOPATH，这个 GOPATH 路径是用来指定当前工作目录的。 不能和 Go 的安装目录（GOROOT）一样。
工作区的目录结构：
GOPATH/ src/ # 源码目录 bin/ # 存放编译后的可执行程序 pkg/ # 存放编译后的包的目标文件 GOPATH 允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候 Windows 是分号 ;，Linux 系统是冒号 :， 当有多个 GOPATH 时，默认会将 go get 的内容放在第一个目录下。</description>
    </item>
    
    <item>
      <title>Golang 条件编译</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/build/</guid>
      <description>Golang 支持两种条件编译方式：
编译标签( build tag) 文件后缀 编译标签#编译标签添加的规则：
a build tag is evaluated as the OR of space-separated options each option evaluates as the AND of its comma-separated terms each term is an alphanumeric word or, preceded by !, its negation 翻译了就是：
编译标签由空格分隔的编译选项(options)以&amp;quot;或&amp;quot;的逻辑关系组成 每个编译选项由逗号分隔的条件项以逻辑&amp;quot;与&amp;quot;的关系组成 每个条件项的名字用字母+数字表示，在前面加 ! 表示否定的意思 +build 之后必须有空行，否则会被编译器当做普通注释
// +build darwin freebsd netbsd openbsd package testpkg 这个将会让这个源文件只能在支持 kqueue 的 BSD 系统里编译
一个源文件里可以有多行编译标签，多行编译标签之间是逻辑&amp;quot;与&amp;quot;的关系
// +build linux darwin // +build 386 这个将限制此源文件只能在 linux/386 或者 darwin/386 平台下编译.</description>
    </item>
    
    <item>
      <title>map</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/map/</guid>
      <description>map 是一个无序的 key/value 对的集合。map 是引用类型。这意味着它拥有对底层数据结构的引用， 就像指针一样。它底层的数据结构是 hash table 或 hash map。
map 作为引用类型是非常好的，因为无论 map 有多大，都只会有一个副本。
定义 map，使用 map 关键字：
/* 声明变量，默认 map 是 nil */ var 变量名 map[键类型]值类型 /* 使用 make 函数 */ 变量名 := make(map[键类型]值类型) /* 字面值的语法创建 */ 变量名 := map[键类型]值类型{ key1: value1, key2: value2, ... } 一个 map 在未初始化之前默认为 nil。 通过索引下标 key 来访问 map 中对应的 value
age, ok := ages[&amp;#34;bob&amp;#34;] if !ok { /* &amp;#34;bob&amp;#34; is not a key in this map; age == 0.</description>
    </item>
    
    <item>
      <title>slice</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/slice/</guid>
      <description>slice 的语法和数组很像，由于数组长度是固定的，所以使用 slice 相比数组会更灵活，slice 是动态的。
切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型。
定义切片，和定义数组的区别就是不需要指定 SIZE：
var 变量名 []类型 一个 slice 由三个部分构成：指针、长度和容量。长度不能超过容量。 一个切片在未初始化之前默认为 nil，长度为 0。
初始化切片：
// 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3.其 cap=len=3 s :=[]int {1,2,3} // 初始化切片 s,是数组 arr 的引用 s := arr[:] // 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片 s := arr[startIndex:endIndex] // 缺省 endIndex 时将表示一直到 arr 的最后一个元素 s := arr[startIndex:] // 缺省 startIndex 时将表示从 arr 的第一个元素开始 s := arr[:endIndex] // 使用 make 函数来创建切片 // len 是数组的长度并且也是切片的初始长度 // capacity 为可选参数, 指定容量 s := make([]int, len, capacity) len() 和 cap()#len获取切片长度。 cap计算切片的最大容量 append() 和 copy()#append 向切片追加新元素 copy 拷贝切片 append 的使用#使用 append 函数时要注意，append 总是从 slice 的尾部开始追加数据。比如下面的代码：</description>
    </item>
    
    <item>
      <title>作用域</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/scope/</guid>
      <description>作用域#声明语句的作用域是指源代码中可以有效使用这个名字的范围。
局部变量 在函数体内或代码块内声明的变量称之为局部变量，它们的作用域只在代码块内，参数和返回值变量也是局部变量。 全局变量 作用域都是全局的（在本包范围内） 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包 （被导出后 首字母大写）使用。 全局变量可以在任何函数中使用。 Go 的标识符作用域是基于代码块的。代码块就是包裹在一对大括号内部的声明和语句，并且是可嵌套的。代码块内部声明的名字是无法 被外部块访问的。
声明语句作用域范围的大小。
内置的类型、函数和常量，比如 int、len 和 true 是全局作用域 在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问 导入的包，如 import &amp;quot;packages/test&amp;quot;，是对应源文件级的作用域，只能在当前的源文件中访问 在函数内部声明的名字，只能在函数内部访问 一个程序可能包含多个同名的声明，只要它们在不同的词法域就可以。内层的词法域会屏蔽外部的声明。</description>
    </item>
    
    <item>
      <title>函数</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/function/</guid>
      <description>声明函数#func 关键字声明函数：
func 函数名(形式参数列表) (返回值列表) { 函数体 } 如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。如果一个函数声明没有返回值列表，那么这个 函数不会返回任何值。
// 两个 int 类型参数 返回一个 int 类型的值 func max(num1, num2 int) int { /* 定义局部变量 */ var result int if (num1 &amp;gt; num2) { result = num1 } else { result = num2 } return result } // 返回多个类型的值 func swap(x int, y string) (string, int) { return y, x } // 有名返回值 func Size(rect image.Rectangle) (width, height int, err error) 在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值（函数调用必须按照声明顺序为所有参数提供实参）。函数的形参和有 名返回值（也就是对返回值命名）作为函数最外层的局部变量，被存储在相同的词法块中。</description>
    </item>
    
    <item>
      <title>包</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/package/</guid>
      <description>包#Go 语言的包与其他语言的 modules 或者 libraries 类似。Go 语言有超过 100个 的标准包，可以使用 go list std | wc -l 查看包的数量。
更多 Go 语言开源包，可以在 这里 搜索。
Go 语言编译速度很快，主要依赖下面三点：
导入的包必须在文件的头部显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。 禁止包的循环依赖，每个包可以被独立编译，而且很可能是被并发编译。 编译后包的目标文件不仅仅记录包本身的导出信息，同时还记录了包的依赖关系。 因此，在编译一个包的时候，编译器只需读取每个导入包的目标文件，而不需要遍历所有依赖的的文件。 import#在 package 声明下面，我们需要导入一系列需要使用的包。比如 import &amp;quot;fmt&amp;quot;。注意如果导入了不需要的包，或者缺少了必要的包， 编译会失败。
// 导入一个包 import &amp;#34;fmt&amp;#34; // 导入多个 import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) main#main 是一个特殊的包，main 包代表一个独立运行的程序，而不是一个 modules 或者 libraries。main 包里 必须有 main 函数，这个是程序的入口函数，并且 mian 函数没有参数。比如：
func main() { fmt.Println(&amp;#34;Hello, 世界&amp;#34;) } hello world#package main import &amp;#34;fmt&amp;#34; func main() { fmt.</description>
    </item>
    
    <item>
      <title>反射</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/reflect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/reflect/</guid>
      <description>反射#反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道 这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。
reflect.TypeOf#reflect.TypeOf 获取类型信息。 reflect.TypeOf 接受任意的 interface{} 类型, 并以 reflect.Type 形式返回其动态类型：
t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; type X int func main() { var a X = 20 t := reflect.TypeOf(a) fmt.Println(t.Name(), t.Kind()) // X int } 上面的代码，注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型。所以在判断类型时， 要选择正确的方式。
type X int type Y int func main() { var a, b X = 10, 20 var c Y = 30 ta, tb, tc := reflect.</description>
    </item>
    
    <item>
      <title>变量</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/var/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/var/</guid>
      <description>变量#var 声明变量，必须使用空格隔开：
var 变量名字 类型 = 表达式 类型或者表达式可以省略其中的一个。也就是如果没有类型，可以通过表达式推断出类型，没有表达式，将会根据类型初始化为对应的零值。
零值 并不是空值，而是一种“变量未填充前”的默认值，通常为 0，对应关系：
数值类型：0 布尔类型：false 字符串: &amp;quot;&amp;quot; 接口或引用类型（包括 slice、指针、map、chan 和函数）：nil 注意：
map 的零值是 nil， 也就是或如果用 var testMap map[string]string 的方式声明，是不能直接通过 unmarshal 或 map[key] 操 作，应该使用 make 函数。 slice 的零值是 nil，不能直接通过下标操作。应该使用 make 函数。 对于 struct 的指针，要注意使用 var testStruct *testResponse的方式声明，如果 testResponse 内嵌套结构体指针，unmarshal 会失败，因为指针的零值是 nil，应该使用 testStruct := &amp;amp;testResponse{} 的方式。 声明一组变量#var 变量名字, 变量名字, 变量名字 ... 类型 = 表达式, 表达式, 表达式, ... 比如：</description>
    </item>
    
    <item>
      <title>基础据类型</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/basic_data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/basic_data/</guid>
      <description>数值类型#整型#uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数#float32，IEEE-754 32 位浮点型数，math.</description>
    </item>
    
    <item>
      <title>常量</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/constant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/constant/</guid>
      <description>常量#const 声明常量，运行时不可改变（只读），注意常量的底层数据类型只能是基础类型（布尔型、数值型和字符串型）：
const 常量名字 类型 = 表达式 &amp;ldquo;类型&amp;quot;可以省略。也就是如果没有类型，可以通过表达式推导出类型。
比如：
// 声明一个`string`类型 const b string = &amp;#34;abc&amp;#34; const a = &amp;#34;abc&amp;#34; // 声明一组不同类型 const c, f, s = true, 2.3, &amp;#34;four&amp;#34; // bool, float64, string // 批量声明多个常量 const ( Unknown = 0 Female = 1 Male = 2 ) const strSize = len(&amp;#34;hello, world&amp;#34;) 常量表达式的值在编译期计算。因此常量表达式中，函数必须是内置函数。如 unsafe.Sizeof()，len(), cap()。 也就是说常量并不是像变量一样在运行期分配内存，通常在编译器预处理阶段，作为指令数据使用。
常量组中，如果不指定类型和初始值，那么就和上一行非空常量右值相同： 例如：
const ( a = 1 b c = 2 d ) fmt.</description>
    </item>
    
    <item>
      <title>序列化</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/json/</guid>
      <description>序列化#Go 对于其他序列化协议如 Json，XML，Protocol Buffers，都有良好的支持，
由标准库中的 encoding/json、encoding/xml、encoding/asn1 等包提供支持，Protocol Buffers 的 由 github.com/golang/protobuf 包提供支持，并且这类包都有着相似的 API 接口。
GO 中结构体转为 JSON 使用 json.Marshal，也就是编码操作：
type Movie struct { Title string Year int `json:&amp;#34;released&amp;#34;` Color bool `json:&amp;#34;color,omitempty&amp;#34;` Actors []string Actors []string } var movies = []Movie{ { Title: &amp;#34;Casablanca&amp;#34;, Year: 1942, Color: false, Actors: []string{&amp;#34;Humphrey Bogart&amp;#34;, &amp;#34;Ingrid Bergman&amp;#34;}}, { Title: &amp;#34;Cool Hand Luke&amp;#34;, Year: 1967, Color: true, Actors: []string{&amp;#34;Paul Newman&amp;#34;}}, { Title: &amp;#34;Bullitt&amp;#34;, Year: 1968, Color: true, Actors: []string{&amp;#34;Steve McQueen&amp;#34;, &amp;#34;Jacqueline Bisset&amp;#34;}}}	data, err := json.</description>
    </item>
    
    <item>
      <title>指针</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/pointer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/pointer/</guid>
      <description>指针#指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个 保存内存地址的整形变量。
x := 1 p := &amp;amp;x // p, of type *int, points to x fmt.Println(*p) // &amp;#34;1&amp;#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &amp;#34;2&amp;#34; 上面的代码，初始化一个变量 x，&amp;amp; 是取地址操作，&amp;amp;x 就是取变量 x 的内存地址，那么 p 就是一个指针， 类型是 *int，p 这个指针保存了变量 x 的内存地址。接下来 *p 表示读取指针指向的变量的值，也就是变量 x 的值 1。 *p也可以被赋值。
任何类型的指针的零值都是 nil。当指针指向同一个变量或者 nil 时是相等的。 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
指向指针的指针#var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;amp;a /* 指向指针 ptr 地址 */ pptr = &amp;amp;ptr /* 获取 pptr 的值 */ fmt.</description>
    </item>
    
    <item>
      <title>接口</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/interface/</guid>
      <description>Go 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实 现了这个接口，无须显示声明。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。
一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。
接口的零值就是它的类型和值的部分都是 nil。
简单的说，interface 是一组 method 的组合，我们通过 interface 来定义对象的一组行为。
定义接口：
type 接口名 interface { 方法名1 [返回类型] 方法名2 [返回类型] 方法名3 [返回类型] ... } /* 定义结构体 */ type struct_name struct { /* variables */ } /* 实现接口方法 */ func (struct_name_variable struct_name) 方法名1() [返回类型] { /* 方法实现 */ } ... func (struct_name_variable struct_name) 方法名2() [返回类型] { /* 方法实现*/ } 实例：
type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.</description>
    </item>
    
    <item>
      <title>控制语句</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/flow/</guid>
      <description>if#if 布尔表达式 { } if&amp;hellip;else#if 布尔表达式 { } else { } switch#switch var1 { case val1: ... // 不需要显示的 break，case 执行完会自动中断 case val2: ... case val3,val4,...: default: ... } val1,val2 &amp;hellip; 类型不被局限于常量或整数，但必须是相同的类型。
switch 语句，你要明白其中的 case 表达式的所有子表达式的结果值都是要与 switch 表达式的结果值判等的，因此它们的类型必须相 同或者能够都统一到 switch 表达式的结果类型。 如果无法做到，那么这条 switch 语句就不能通过编译。
switch语句在 case 子句的选择上是具有唯一性的。正因为如此，switch 语句不允许 case 表达式中的子表达式结果值存 在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的 case 表达式中，都会是这样的结果。
普通 case 子句的编写顺序很重要，最上边的 case 子句中的子表达式总是会被最先求值，在判等的时候顺序也是这样。因此， 如果某些子表达式的结果值有重复并且它们与 switch 表达式的结果值相等，那么位置靠上的 case 子句总会被选中。</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/array/</guid>
      <description>数组是一个由固定长度的指定类型元素组成的序列。数组的长度在编译阶段确定。数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。
声明数组：
var 变量名 [SIZE]类型 内置函数 len 获取数组长度。通过下标访问元素：
var a [3]int // array of 3 integers fmt.Println(a[0]) // print the first element fmt.Println(a[len(a)-1]) // print the last element, a[2] 默认情况下，数组的每个元素都被初始化为元素类型对应的零值。 初始化数组：
var q [3]int = [3]int{1, 2, 3} var r [3]int = [3]int{1, 2} fmt.Println(r[2]) // &amp;#34;0&amp;#34; var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0} mt.Println(len(balance)) // 5 var balance2 = []float32 fmt.Println(len(balance2)) // type []float32 is not an expression q := [.</description>
    </item>
    
    <item>
      <title>测试</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/test/</guid>
      <description>go test 命令测试代码，包目录内，所有以 _test.go 为后缀名的源文件在执行 go build 时不会被构建成包的一部分， 它们是 go test 测试的一部分。
在 *_test.go 文件中，有三种类型的函数：
测试函数，测试程序的一些逻辑行为是否正确。go test 命令会调用这些测试函数并报告测试结果是 PASS 或 FAIL。 基准测试函数，衡量一些函数的性能。go test 命令会多次运行基准函数以计算一个平均的执行时间。 示例函数，提供一个由编译器保证正确性的示例文档。 go test 会生成一个临时 main 包调用测试函数。 参数
-v，打印每个测试函数的名字和运行时间。 -run，指定一个正则表达式，只有匹配到的测试函数名才会被 go test 运行，如 go test -v -run=&amp;quot;French|Canal&amp;quot;。 -cover，测试覆盖率。 -bench，运行基准测试。例如 go test -bench=.（如果在 Windows Powershell 环境下使用 go test -bench=&amp;quot;.&amp;quot;） -c，生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为 pkg.test，其中的 pkg 即为被测试代码包的 导入路径的最后一个元素的名称。 -i，安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。 -o，指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记 -c 或 -i。 测试函数#测试函数必须导入 testing 包，并以 Test 为函数名前缀，后缀名必须以大写字母开头，并且参数列表中只应有一个 *testing.T 类型的参数声明：</description>
    </item>
    
    <item>
      <title>结构体</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/struct/</guid>
      <description>结构体#结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 结构体定义需要使用 type 和 struct 语句, struct 语句定义一个新的数据类型, type 语句定义了结构体的名称：
// 定义了结构体类型 type struct_variable_type struct { member definition; member definition; ... member definition; } variable_name := structure_variable_type{value1, value2...valuen} // 或 variable_name := structure_variable_type{ key1: value1, key2: value2..., keyn: valuen} 用点号 . 操作符访问结构体成员, 实例：
type Books struct { title string author string subject string book_id int } func main() { var Book1 Books /* 声明 Book1 为 Books 类型 */ /* book 1 描述 */ Book1.</description>
    </item>
    
    <item>
      <title>运算符</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/operator/</guid>
      <description>运算符#优先级#*，/，%，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;amp;，&amp;amp;^ +，-，|，^ ==，!=，&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt;= &amp;amp;&amp;amp; || 上面的运算符得优先级，从上到下，从左到右。也就是 * 的优先级最高，|| 的优先级最低。
算术运算符#+、-、* 和 / 可以适用于整数、浮点数和复数。
在 Go 中，% 取模运算符的符号和被取模数的符号总是一致的，因此 -5 % 3 和 -5 % -3 结果都是 -2。% 仅用于整数间的运算。除法运算符 / 的行为则依赖于操作数是否为全为整数，比如 5.0/4.0 的结果是 1.25，但是 5/4 的结果是 1，因为整数除法会向着 0 方向截断余数。
++ 自增，-- 自减
关系运算符#==，!=，&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt;=。
布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 == 和 != 进行比较。
逻辑运算符#&amp;amp;&amp;amp;，||，!（逻辑 NOT 运算符）。
位运算符#&amp;amp;，|，^，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;amp;^（位清空 AND NOT）
&amp;amp;^：如果对应 y 中 bit 位为 1 的话, 表达式 z = x &amp;amp;^ y 结果 z 的对应的 bit 位为 0，否则 z 对应的 bit 位等于 x 相应的 bit 位的值。如：</description>
    </item>
    
    <item>
      <title>错误</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/error/</guid>
      <description>错误#error 类型#error 类型是内置的接口类型。error 类型可能是 nil 或者 non-nil，nil 表示成功。
错误处理#当函数调用返回错误时，最常用的处理方式是传播错误，如。
resp, err := http.Get(url) if err != nil{ // 将这个HTTP错误返回给调用者 return nil, err } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { // fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回 // 使用该函数前缀添加额外的上下文信息到原始错误信息。 return nil, fmt.Errorf(&amp;#34;parsing %s as HTML: %v&amp;#34;, url,err) } 由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。
编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内 的同一组函数返回的错误在构成和处理方式上是相似的。
根据不同的场景，我们可能要对错误做些特殊处理，比如错误重试机制，或者打印错误日志，或者直接忽略错误。
文件结尾错误#io 包在任何由文件结束引起的读取失败都返回同一个错误 io.EOF：
in := bufio.NewReader(os.Stdin) for { r, _, err := in.</description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>http://shipengqi.github.io/golang-learn/docs/basic/oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/basic/oop/</guid>
      <description>GO 支持面向对象编程。
方法#方法声明：
func (变量名 类型) 方法名() [返回类型]{ /* 函数体*/ } 实例：
/* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&amp;#34;Area of Circle(c1) = &amp;#34;, c1.getArea()) } // 该 method 属于 Circle 类型对象中的方法 // 这里的 c 叫作方法的接收器，类似 Javascript 的 this func (c Circle) getArea() float64 { // c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.radius * c.radius } Go 没有像其它语言那样用 this 或者 self 作为接收器。Go 可以给任意类型定义方法。</description>
    </item>
    
  </channel>
</rss>
