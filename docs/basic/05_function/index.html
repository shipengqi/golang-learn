<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="函数 # 参数传递 # Go 使用的是值传递，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型， 区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。 但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
注意，如果实参是 slice、map、function、channel 等类型（引用类型），实参可能会由于函数的间接引用被修改。
没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。
表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和 垃圾回收的成本。在栈上复制小对象，要比堆上分配内存要快的多。如果复制成本高，或者需要修改原对象，使用指针更好。
可变参数 # 变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个。比如 fmt.Printf，Printf 接收一个的必备参数，之 后接收任意个数的后续参数。
在参数列表的最后一个参数类型之前加上省略符号 ...，表示该函数会接收任意数量的该类型参数。
func sum(vals ...int) int { total := 0 for _, val := range vals { total += val } return total } // 调用 fmt.Println(sum()) // &#34;0&#34; fmt.Println(sum(3)) // &#34;3&#34; fmt.Println(sum(1, 2, 3, 4)) // &#34;10&#34; // 还可以使用类似 ES6 的解构赋值的语法 values := []int{1, 2, 3, 4} fmt."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="函数"><meta property="og:description" content="函数 # 参数传递 # Go 使用的是值传递，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型， 区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。 但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
注意，如果实参是 slice、map、function、channel 等类型（引用类型），实参可能会由于函数的间接引用被修改。
没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。
表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和 垃圾回收的成本。在栈上复制小对象，要比堆上分配内存要快的多。如果复制成本高，或者需要修改原对象，使用指针更好。
可变参数 # 变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个。比如 fmt.Printf，Printf 接收一个的必备参数，之 后接收任意个数的后续参数。
在参数列表的最后一个参数类型之前加上省略符号 ...，表示该函数会接收任意数量的该类型参数。
func sum(vals ...int) int { total := 0 for _, val := range vals { total += val } return total } // 调用 fmt.Println(sum()) // &#34;0&#34; fmt.Println(sum(3)) // &#34;3&#34; fmt.Println(sum(1, 2, 3, 4)) // &#34;10&#34; // 还可以使用类似 ES6 的解构赋值的语法 values := []int{1, 2, 3, 4} fmt."><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/basic/05_function/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-06T14:16:11+08:00"><title>函数 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.756833f57d68365b51196dccf3c31cd79895a5e54135335c7562a8b3fbde8210.js integrity="sha256-dWgz9X1oNltRGW3M88Mc15iVpeVBNTNcdWKos/veghA=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/ class=active>函数</a></li><li><a href=/golang-learn/docs/basic/06_interface/>接口</a></li><li><a href=/golang-learn/docs/basic/07_reflect/>反射</a></li><li><a href=/golang-learn/docs/basic/08_generic/>泛型</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li><li><a href=/golang-learn/docs/basic/10_range/>range</a></li><li><a href=/golang-learn/docs/basic/11_select/>select</a></li><li><a href=/golang-learn/docs/basic/12_defer/>defer</a></li><li><a href=/golang-learn/docs/basic/13_panic/>panic</a></li><li><a href=/golang-learn/docs/basic/14_make_new/>make 和 new</a></li><li><a href=/golang-learn/docs/basic/15_oop/>面向对象</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li><li><a href=/golang-learn/docs/concurrency/12_errorgroup/>ErrGroup</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/03_test/>Go 测试</a></li><li><a href=/golang-learn/docs/practice/04_pprof/>Go 性能分析</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/06_trace/>Go Trace</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go CoreDump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li><li><a href=/golang-learn/docs/practice/10_remote_dev/>Go 远程开发调试</a></li><li><a href=/golang-learn/docs/practice/11_errors/>Go 常见错误</a></li></ul></li><li><span>🔍 底层原理</span><ul><li><a href=/golang-learn/docs/advance/01_mm/>内存管理</a></li><li><a href=/golang-learn/docs/advance/02_gc/>垃圾回收</a></li><li><a href=/golang-learn/docs/advance/03_scheduler/>调度器</a></li><li><a href=/golang-learn/docs/advance/04_netpooler/>网络轮询器</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>函数</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#函数>函数</a><ul><li><a href=#参数传递>参数传递</a></li><li><a href=#可变参数>可变参数</a></li><li><a href=#函数作为值>函数作为值</a></li><li><a href=#函数作为参数>函数作为参数</a></li><li><a href=#闭包>闭包</a></li><li><a href=#关键字-defer>关键字 defer</a><ul><li><a href=#defer-的性能>defer 的性能</a></li><li><a href=#什么时候不应该使用-defer>什么时候不应该使用 defer</a></li><li><a href=#如果一个函数中有多条-defer-语句那么那几个-defer-函数调用的执行顺序是怎样的>如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的</a></li></ul></li><li><a href=#传入函数的那些参数值后来怎么样了>传入函数的那些参数值后来怎么样了</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=函数>函数
<a class=anchor href=#%e5%87%bd%e6%95%b0>#</a></h1><h2 id=参数传递>参数传递
<a class=anchor href=#%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92>#</a></h2><p>Go 使用的是<strong>值传递</strong>，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型，
区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。
但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p>注意，如果实参是 <code>slice</code>、<code>map</code>、<code>function</code>、<code>channel</code> 等类型（<strong>引用类型</strong>），实参可能会由于函数的间接引用被修改。</p><p>没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。</p><p><strong>表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和
垃圾回收的成本。在栈上复制小对象，要比堆上分配内存要快的多</strong>。如果复制成本高，或者需要修改原对象，使用指针更好。</p><h2 id=可变参数>可变参数
<a class=anchor href=#%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0>#</a></h2><p><strong>变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个</strong>。比如 <code>fmt.Printf</code>，<code>Printf</code> 接收一个的必备参数，之
后接收任意个数的后续参数。</p><p>在参数列表的最后一个参数类型之前加上省略符号 <code>...</code>，表示该函数会接收任意数量的该类型参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>vals</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>total</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>vals</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>total</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>total</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sum</span>())           <span style=color:#75715e>// &#34;0&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sum</span>(<span style=color:#ae81ff>3</span>))          <span style=color:#75715e>// &#34;3&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sum</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)) <span style=color:#75715e>// &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 还可以使用类似 ES6 的解构赋值的语法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>values</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>values</span><span style=color:#f92672>...</span>)) <span style=color:#75715e>// &#34;10&#34;
</span></span></span></code></pre></div><h2 id=函数作为值>函数作为值
<a class=anchor href=#%e5%87%bd%e6%95%b0%e4%bd%9c%e4%b8%ba%e5%80%bc>#</a></h2><p>Go 函数被看作第一类值：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span> <span style=color:#75715e>/* 声明函数变量 */</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>getSquareRoot</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>float64</span>) <span style=color:#66d9ef>float64</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Sqrt</span>(<span style=color:#a6e22e>x</span>)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>/* 使用函数 */</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>getSquareRoot</span>(<span style=color:#ae81ff>9</span>)) <span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=函数作为参数>函数作为参数
<a class=anchor href=#%e5%87%bd%e6%95%b0%e4%bd%9c%e4%b8%ba%e5%8f%82%e6%95%b0>#</a></h2><p>声明一个名叫 <code>operate</code> 的函数类型，它有两个参数和一个结果，都是 <code>int</code> 类型的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>operate</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><p>编写 <code>calculate</code> 函数的签名部分。这个函数除了需要两个 <code>int</code> 类型的参数之外，还应该有一个 <code>operate</code> 类型的参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>calculate</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>op</span> <span style=color:#a6e22e>operate</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;invalid operation&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>op</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>), <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=闭包>闭包
<a class=anchor href=#%e9%97%ad%e5%8c%85>#</a></h2><p>Go 语言支持匿名函数，可作为闭包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 返回一个函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getSequence</span>() <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> { <span style=color:#75715e>// func() 是没有参数也没有返回值的函数类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 闭包
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>i</span><span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span>  
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=关键字-defer>关键字 defer
<a class=anchor href=#%e5%85%b3%e9%94%ae%e5%ad%97-defer>#</a></h2><p>在普通函数或方法前加关键字 <code>defer</code>，会使函数或方法延迟执行，直到包含该 <code>defer</code> 语句的函数执行完毕时（<strong>无论函数是否出错</strong>），
<code>defer</code> 后的函数才会被执行。</p><p>Go官方文档中对 <code>defer</code> 的执行时机做了阐述，分别是。</p><ul><li>包裹 <code>defer</code> 的函数返回时</li><li>包裹 <code>defer</code> 的函数执行到末尾时</li><li>所在的 goroutine 发生 panic 时</li></ul><p><strong>注意：</strong> 调用 <code>os.Exit</code> 时 <code>defer</code> 不会被执行。</p><p><code>defer</code> 语句一般被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。因为 <code>defer</code> 可以保证让你更任何情况下，
资源都会被释放。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>ioutil</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ReadFile</span>(<span style=color:#a6e22e>filename</span> <span style=color:#66d9ef>string</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>filename</span>)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>f</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 互斥锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mu</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lookup</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span> <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>key</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 记录何时进入和退出函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>bigSlowOperation</span>() {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>trace</span>(<span style=color:#e6db74>&#34;bigSlowOperation&#34;</span>)() <span style=color:#75715e>// 运行 trace 函数，记录了进入函数的时间，并返回一个函数值，这个函数值会延迟执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>extra</span> <span style=color:#a6e22e>parentheses</span>
</span></span><span style=display:flex><span> <span style=color:#75715e>// ...lots of work…
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>) <span style=color:#75715e>// simulate slow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>operation</span> <span style=color:#a6e22e>by</span> <span style=color:#a6e22e>sleeping</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>trace</span>(<span style=color:#a6e22e>msg</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span> <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;enter %s&#34;</span>, <span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() { 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;exit %s (%s)&#34;</span>, <span style=color:#a6e22e>msg</span>,<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>start</span>)) 
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 观察函数的返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>double</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>result</span> <span style=color:#66d9ef>int</span>) { <span style=color:#75715e>// 有名返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 由于 defer 在 return 之后执行，所以这里的 result 就是函数最终的返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;double(%d) = %d\n&#34;</span>, <span style=color:#a6e22e>x</span>,<span style=color:#a6e22e>result</span>) }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>x</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>double</span>(<span style=color:#ae81ff>4</span>) <span style=color:#75715e>// 输出 &#34;double(4) = 8&#34;
</span></span></span></code></pre></div><p>上面的例子中我们知道 <code>defer</code> 函数可以观察函数返回值，<code>defer</code> 函数还可以修改函数的返回值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>triple</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>result</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>result</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>x</span> }()
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>double</span>(<span style=color:#a6e22e>x</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>triple</span>(<span style=color:#ae81ff>4</span>)) <span style=color:#75715e>// &#34;12&#34;
</span></span></span></code></pre></div><h3 id=defer-的性能>defer 的性能
<a class=anchor href=#defer-%e7%9a%84%e6%80%a7%e8%83%bd>#</a></h3><p>相比直接用 CALL 汇编指令调用函数，<code>defer</code> 要花费更大代价，包括注册，调用操作，额为的缓存开销。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>call</span> () {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferCall</span>()  {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span> <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkCall</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>)  {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>call</span>()
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkDeferCall</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>)  {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>deferCall</span>()
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ go test -bench<span style=color:#f92672>=</span>.
</span></span><span style=display:flex><span>goos: windows
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: github.com/shipengqi/golang-learn/demos/defers
</span></span><span style=display:flex><span>BenchmarkCall-8         <span style=color:#ae81ff>92349604</span>                12.9 ns/op
</span></span><span style=display:flex><span>BenchmarkDeferCall-8    <span style=color:#ae81ff>34305316</span>                36.3 ns/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      github.com/shipengqi/golang-learn/demos/defers  2.571s
</span></span></code></pre></div><p>性能相差三倍，尽量避免使用 <code>defer</code>。</p><h3 id=什么时候不应该使用-defer>什么时候不应该使用 defer
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%b8%8d%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8-defer>#</a></h3><p>比如处理日志文件，不恰当的 <code>defer</code> 会导致关闭文件延时。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>100</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%d.log&#34;</span>, <span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的 <code>defer</code> 导致所有的 <code>f</code> 都是在 <code>main</code> 函数退出时才调用，白白消耗了资源。所以应该直接调用 <code>Close</code> 函数，
将文件操作封装到一个函数中，在该函数中调用 <code>Close</code> 函数。</p><h3 id=如果一个函数中有多条-defer-语句那么那几个-defer-函数调用的执行顺序是怎样的>如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的
<a class=anchor href=#%e5%a6%82%e6%9e%9c%e4%b8%80%e4%b8%aa%e5%87%bd%e6%95%b0%e4%b8%ad%e6%9c%89%e5%a4%9a%e6%9d%a1-defer-%e8%af%ad%e5%8f%a5%e9%82%a3%e4%b9%88%e9%82%a3%e5%87%a0%e4%b8%aa-defer-%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84>#</a></h3><p>在同一个函数中，<strong><code>defer</code> 函数调用的执行顺序与它们分别所属的 <code>defer</code> 语句的出现顺序（更严谨地说，是执行顺序）完全相反</strong>。</p><p>在 <code>defer</code> 语句每次执行的时候，Go 语言会把它携带的 <code>defer</code> 函数及其参数值另行存储到一个队列中。</p><p>这个队列与该 <code>defer</code> 语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。</p><p>在需要执行某个函数中的 <code>defer</code> 函数调用的时候，Go 语言会先拿到对应的队列，然后从该队列中一个一个地取出 <code>defer</code> 函数及
其参数值，并逐个执行调用。</p><h2 id=传入函数的那些参数值后来怎么样了>传入函数的那些参数值后来怎么样了
<a class=anchor href=#%e4%bc%a0%e5%85%a5%e5%87%bd%e6%95%b0%e7%9a%84%e9%82%a3%e4%ba%9b%e5%8f%82%e6%95%b0%e5%80%bc%e5%90%8e%e6%9d%a5%e6%80%8e%e4%b9%88%e6%a0%b7%e4%ba%86>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>array1</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>}
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;The array: %v\n&#34;</span>, <span style=color:#a6e22e>array1</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>array2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>modifyArray</span>(<span style=color:#a6e22e>array1</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;The modified array: %v\n&#34;</span>, <span style=color:#a6e22e>array2</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;The original array: %v\n&#34;</span>, <span style=color:#a6e22e>array1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>modifyArray</span>(<span style=color:#a6e22e>a</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>string</span>) [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#e6db74>&#34;x&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 <code>main</code> 函数中声明了一个数组 <code>array1</code>，然后把它传给了函数 <code>modify</code>，<code>modify</code> 对参数值稍作修改后将其作为结果值返回。<code>main</code>
函数中的代码拿到这个结果之后打印了它（即 <code>array2</code>），以及原来的数组 <code>array1</code>。关键问题是，原数组会因 <code>modify</code> 函数对参数
值的修改而改变吗？</p><p>答案是：原数组不会改变。为什么呢？原因是，<strong>所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，
而是它的副本</strong>。</p><p>由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。</p><p>注意，<strong>对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。
也就是说，这时只是浅表复制，而不是深层复制</strong>。</p><p>以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/8dd84e00e28127fae659507809861bef11ae174f title='Last modified by PengQi Shi | November 6, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 6, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/basic/05_function.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#函数>函数</a><ul><li><a href=#参数传递>参数传递</a></li><li><a href=#可变参数>可变参数</a></li><li><a href=#函数作为值>函数作为值</a></li><li><a href=#函数作为参数>函数作为参数</a></li><li><a href=#闭包>闭包</a></li><li><a href=#关键字-defer>关键字 defer</a><ul><li><a href=#defer-的性能>defer 的性能</a></li><li><a href=#什么时候不应该使用-defer>什么时候不应该使用 defer</a></li><li><a href=#如果一个函数中有多条-defer-语句那么那几个-defer-函数调用的执行顺序是怎样的>如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的</a></li></ul></li><li><a href=#传入函数的那些参数值后来怎么样了>传入函数的那些参数值后来怎么样了</a></li></ul></li></ul></nav></div></aside></main></body></html>