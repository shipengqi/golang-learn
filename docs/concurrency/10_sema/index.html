<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="信号量 # 信号量（Semaphore）是一种用于实现多进程或多线程之间同步和互斥的机制。
信号量可以简单理解为一个整型数，包含两种操作：P（Proberen，测试）操作和 V（Verhogen，增加）操作。其中，P 操作会尝试获取一个信号量，如果信号量的值大于 0，则将信号量的值减 1 并 继续执行。否则，当前进程或线程就会被阻塞，直到有其他进程或线程释放这个信号量为止。V 操作则是释放一个信号量，将信号量的值加 1。
P 操作和 V 操作可以看做是对资源的获取和释放。
Go 的 WaitGroup 和 Metux 都是通过信号量来控制 goroutine 的阻塞和唤醒，例如 Mutex 结构体中的 sema：
type Mutex struct { state int32 sema uint32 } Metux 本质上就是基于信号量（sema）+ 原子操作来实现并发控制的。
Go 操作信号量的方法：
// src/sync/runtime.go // 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1 func runtime_Semacquire(s *uint32) // 类似于 runtime_Semacquire // 如果 lifo 为 true，waiter 将会被插入到队列的头部，否则插入到队列尾部 // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int) // 将 s 增加 1，然后通知阻塞在 runtime_Semacquire 的 goroutine // 如果 handoff 为 true，传递信号到队列头部的 waiter // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_Semrelease(s *uint32, handoff bool, skipframes int) Acquire 和 Release 分别对应了 P 操作和 V 操作。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="信号量"><meta property="og:description" content="信号量 # 信号量（Semaphore）是一种用于实现多进程或多线程之间同步和互斥的机制。
信号量可以简单理解为一个整型数，包含两种操作：P（Proberen，测试）操作和 V（Verhogen，增加）操作。其中，P 操作会尝试获取一个信号量，如果信号量的值大于 0，则将信号量的值减 1 并 继续执行。否则，当前进程或线程就会被阻塞，直到有其他进程或线程释放这个信号量为止。V 操作则是释放一个信号量，将信号量的值加 1。
P 操作和 V 操作可以看做是对资源的获取和释放。
Go 的 WaitGroup 和 Metux 都是通过信号量来控制 goroutine 的阻塞和唤醒，例如 Mutex 结构体中的 sema：
type Mutex struct { state int32 sema uint32 } Metux 本质上就是基于信号量（sema）+ 原子操作来实现并发控制的。
Go 操作信号量的方法：
// src/sync/runtime.go // 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1 func runtime_Semacquire(s *uint32) // 类似于 runtime_Semacquire // 如果 lifo 为 true，waiter 将会被插入到队列的头部，否则插入到队列尾部 // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int) // 将 s 增加 1，然后通知阻塞在 runtime_Semacquire 的 goroutine // 如果 handoff 为 true，传递信号到队列头部的 waiter // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_Semrelease(s *uint32, handoff bool, skipframes int) Acquire 和 Release 分别对应了 P 操作和 V 操作。"><meta property="og:type" content="article"><meta property="og:url" content="https://shipengqi.github.io/golang-learn/docs/concurrency/10_sema/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-06T14:16:11+08:00"><title>信号量 | Go Learning</title><link rel=manifest href=/golang-learn/manifest.json><link rel=icon href=/golang-learn/favicon.png><link rel=stylesheet href=/golang-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/golang-learn/flexsearch.min.js></script>
<script defer src=/golang-learn/en.search.min.85ac43de481b0867c3ed54a5a2263e836d58519eeddb4df16af262f7ed157d12.js integrity="sha256-haxD3kgbCGfD7VSloiY+g21YUZ7t203xavJi9+0VfRI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/golang-learn/><span>Go Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/golang-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>🍚 语言基础</span><ul><li><a href=/golang-learn/docs/basic/01_basic_type/>基础数据类型</a></li><li><a href=/golang-learn/docs/basic/02_array/>数组</a></li><li><a href=/golang-learn/docs/basic/03_slice/>切片</a></li><li><a href=/golang-learn/docs/basic/04_map/>哈希表</a></li><li><a href=/golang-learn/docs/basic/05_function/>函数</a></li><li><a href=/golang-learn/docs/basic/09_pointer/>指针</a></li></ul></li><li><a href=/golang-learn/docs/concurrency/>⚡ 并发编程</a><ul><li><a href=/golang-learn/docs/concurrency/01_mutex/>互斥锁</a></li><li><a href=/golang-learn/docs/concurrency/02_rwmutex/>读写锁</a></li><li><a href=/golang-learn/docs/concurrency/03_waitgroup/>WaitGroup</a></li><li><a href=/golang-learn/docs/concurrency/04_cond/>条件变量</a></li><li><a href=/golang-learn/docs/concurrency/05_once/>Once</a></li><li><a href=/golang-learn/docs/concurrency/06_pool/>Pool</a></li><li><a href=/golang-learn/docs/concurrency/07_context/>Context</a></li><li><a href=/golang-learn/docs/concurrency/08_atomic/>原子操作</a></li><li><a href=/golang-learn/docs/concurrency/09_channel/>Channel</a></li><li><a href=/golang-learn/docs/concurrency/10_sema/ class=active>信号量</a></li><li><a href=/golang-learn/docs/concurrency/11_singleflight/>SingleFlight</a></li><li><a href=/golang-learn/docs/concurrency/12_errorgroup/>ErrGroup</a></li></ul></li><li><span>🛠️ 实践</span><ul><li><a href=/golang-learn/docs/practice/01_build/>Go 编译</a></li><li><a href=/golang-learn/docs/practice/02_go_race/>Go 数据竞争检测器</a></li><li><a href=/golang-learn/docs/practice/05_performance/>Go 性能优化</a></li><li><a href=/golang-learn/docs/practice/07_coredump/>Go Core Dump 调试</a></li><li><a href=/golang-learn/docs/practice/08_mod/>Go Modules</a></li><li><a href=/golang-learn/docs/practice/09_gin/>Gin 静态服务器</a></li></ul></li><li><span>🛠️ Go 工程实践</span><ul><li><a href=/golang-learn/docs/project/01_specs/>项目规范</a></li><li><a href=/golang-learn/docs/project/02_structure/>项目的目录结构</a></li><li><a href=/golang-learn/docs/project/03_code/>代码规范</a></li><li><a href=/golang-learn/docs/project/04_commitizen/>Commit 规范</a></li><li><a href=/golang-learn/docs/project/05_version/>版本规范</a></li><li><a href=/golang-learn/docs/project/06_api_doc/>API 文档</a></li><li><a href=/golang-learn/docs/project/07_flow/>Git 工作流程</a></li><li><a href=/golang-learn/docs/project/08_make/>项目管理</a></li><li><a href=/golang-learn/docs/project/09_actions/>GitHub Actions</a></li><li><a href=/golang-learn/docs/project/10_dependabot/>GitHub Dependabot</a></li><li><a href=/golang-learn/docs/project/11_templates/>GitHub 模板</a></li><li><a href=/golang-learn/docs/project/12_goreleaser/>GoReleaser</a></li></ul></li><li><a href=/golang-learn/docs/advance/>🔍 底层原理</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>信号量</strong>
<label for=toc-control><img src=/golang-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#信号量>信号量</a><ul><li><a href=#acquire-信号量>Acquire 信号量</a></li><li><a href=#release-信号量>Release 信号量</a></li><li><a href=#semaphore-扩展库>semaphore 扩展库</a><ul><li><a href=#使用>使用</a></li><li><a href=#原理>原理</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=信号量>信号量
<a class=anchor href=#%e4%bf%a1%e5%8f%b7%e9%87%8f>#</a></h1><p>信号量（Semaphore）是一种用于实现多进程或多线程之间同步和互斥的机制。</p><p>信号量可以简单理解为一个整型数，包含两种操作：<code>P</code>（Proberen，测试）操作和 <code>V</code>（Verhogen，增加）操作。其中，<code>P</code> 操作会尝试获取一个信号量，如果信号量的值大于 0，则将信号量的值减 1 并
继续执行。否则，当前进程或线程就会被阻塞，直到有其他进程或线程释放这个信号量为止。V 操作则是释放一个信号量，将信号量的值加 1。</p><p><code>P</code> 操作和 <code>V</code> 操作可以看做是对资源的获取和释放。</p><p>Go 的 <code>WaitGroup</code> 和 <code>Metux</code> 都是通过信号量来控制 goroutine 的阻塞和唤醒，例如 <code>Mutex</code> 结构体中的 <code>sema</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>state</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sema</span>  <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Metux</code> 本质上就是基于信号量（sema）+ 原子操作来实现并发控制的。</p><p>Go 操作信号量的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/sync/runtime.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtime_Semacquire</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 类似于 runtime_Semacquire
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果 lifo 为 true，waiter 将会被插入到队列的头部，否则插入到队列尾部
</span></span></span><span style=display:flex><span><span style=color:#75715e>// skipframes 是跟踪过程中要省略的帧数，从这里开始计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtime_SemacquireMutex</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>lifo</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 将 s 增加 1，然后通知阻塞在 runtime_Semacquire 的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果 handoff 为 true，传递信号到队列头部的 waiter
</span></span></span><span style=display:flex><span><span style=color:#75715e>// skipframes 是跟踪过程中要省略的帧数，从这里开始计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtime_Semrelease</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>handoff</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>)
</span></span></code></pre></div><p>Acquire 和 Release 分别对应了 <code>P</code> 操作和 <code>V</code> 操作。</p><h2 id=acquire-信号量>Acquire 信号量
<a class=anchor href=#acquire-%e4%bf%a1%e5%8f%b7%e9%87%8f>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/sema.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_Semacquire</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>semacquire1</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>semaBlockProfile</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>waitReasonSemacquire</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_SemacquireMutex</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>lifo</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>semacquire1</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>lifo</span>, <span style=color:#a6e22e>semaBlockProfile</span>|<span style=color:#a6e22e>semaMutexProfile</span>, <span style=color:#a6e22e>skipframes</span>, <span style=color:#a6e22e>waitReasonSyncMutexLock</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>runtime_Semacquire</code> 和 <code>runtime_SemacquireMutex</code> 最终都是调用了 <code>semacquire1</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>semacquire1</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>lifo</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>profile</span> <span style=color:#a6e22e>semaProfileFlags</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>reason</span> <span style=color:#a6e22e>waitReason</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;semacquire not on the G stack&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Easy case.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 信号量大于 0，直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Harder case:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 构造一个 sudog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将信号量的地址放到到 semtable 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 返回一个 semaRoot 类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>semtable</span>.<span style=color:#a6e22e>rootFor</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t0</span> <span style=color:#f92672>:=</span> int64(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>acquiretime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>lockWithRank</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankRoot</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 等待计数 +1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 再次检查信号量是否大于 0，避免错误唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 将当前 goroutine 放入到 semaRoot 的等待者队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>queue</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>lifo</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 挂起当前 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>goparkunlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>reason</span>, <span style=color:#a6e22e>traceBlockSync</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>+</span><span style=color:#a6e22e>skipframes</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>+</span><span style=color:#a6e22e>skipframes</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>cansemacquire</code> 就是判断信号量的值，若等于 0，则直接返回 <code>false</code>，否则，CAS 操作信号量 -1，成功则返回 <code>true</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 等于 0，表示没有资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>v</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>semtable</code> 是一个 <code>semTable</code> 类型，<code>semTable.rootFor</code> 返回的是一个 <code>semaRoot</code> 类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/sema.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>semaRoot</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span>  <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>treap</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>        <span style=color:#75715e>// 等待者队列（平衡树）的根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>nwait</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span> <span style=color:#75715e>// 等待者的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>semtable</span> <span style=color:#a6e22e>semTable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>semTable</span> [<span style=color:#a6e22e>semTabSize</span>]<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span> <span style=color:#a6e22e>semaRoot</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pad</span>  [<span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>semaRoot</span>{})]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// rootFor 本质上就是将 semaRoot 与信号量绑定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>semTable</span>) <span style=color:#a6e22e>rootFor</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>semaRoot</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>[(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>addr</span>))<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>3</span>)<span style=color:#f92672>%</span><span style=color:#a6e22e>semTabSize</span>].<span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=release-信号量>Release 信号量
<a class=anchor href=#release-%e4%bf%a1%e5%8f%b7%e9%87%8f>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/sema.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_Semrelease</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>handoff</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>semrelease1</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>handoff</span>, <span style=color:#a6e22e>skipframes</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>runtime_Semrelease</code> 最终是调用了 <code>semrelease1</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>semrelease1</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>handoff</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 取出信号量对应的 semaRoot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>semtable</span>.<span style=color:#a6e22e>rootFor</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 信号量 +1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Easy case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 没有等待者，直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>.<span style=color:#a6e22e>Load</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Harder case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lockWithRank</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankRoot</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 再次检查等待者计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>.<span style=color:#a6e22e>Load</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 计数已经被其他 goroutine 消费，不需要唤醒其他 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 队当前信号量上的 sudog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>t0</span>, <span style=color:#a6e22e>tailtime</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>dequeue</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 等待者计数 -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// May be slow or even yield, so unlock first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 唤醒 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>readyWithTime</span>(<span style=color:#a6e22e>s</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>+</span><span style=color:#a6e22e>skipframes</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>goyield</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>readyWithTime</code> 的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>readyWithTime</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置 goroutine 的状态为 runnable 等待被重新调度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>traceskip</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=semaphore-扩展库>semaphore 扩展库
<a class=anchor href=#semaphore-%e6%89%a9%e5%b1%95%e5%ba%93>#</a></h2><p>前面 Go 对信号量的实现都是隐藏在 runtime 中的，并没有标准库来供外部使用。不过 Go 的扩展库 <code>golang.org/x/sync</code> 提供了 <code>semaphore</code> 包实现的信号量操作。</p><p>使用 <code>func NewWeighted(n int64) *Weighted</code> 来创建信号量。</p><p><code>Weighted</code> 有三个方法：</p><ul><li><code>Acquire(ctx contex.Context, n int64) error</code>：对应 <code>P</code> 操作，可以一次获取 n 个资源，如果没有足够多的资源，调用者就会被阻塞。</li><li><code>Release(n int64)</code>：对应 <code>V</code> 操作，可以释放 n 个资源。</li><li><code>TryAcquire(n int64) bool</code>：尝试获取 n 个资源，但是它不会阻塞，成功获取 n 个资源则返回 <code>true</code>。否则一个也不获取，返回 <code>false</code>。</li></ul><h3 id=使用>使用
<a class=anchor href=#%e4%bd%bf%e7%94%a8>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxWorkers</span> = <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#ae81ff>0</span>)                    <span style=color:#75715e>// worker 数量和 CPU 核数一样
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sema</span>       = <span style=color:#a6e22e>semaphore</span>.<span style=color:#a6e22e>NewWeighted</span>(int64(<span style=color:#a6e22e>maxWorkers</span>)) <span style=color:#75715e>// 信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>task</span>       = make([]<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>maxWorkers</span><span style=color:#f92672>*</span><span style=color:#ae81ff>4</span>)                <span style=color:#75715e>// 任务数，是 worker 的四倍
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>task</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有 worker 可用，会阻塞在这里，直到某个 worker 被释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sema</span>.<span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#ae81ff>1</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动 worker goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>sema</span>.<span style=color:#a6e22e>Release</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>) <span style=color:#75715e>// 模拟一个耗时操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>task</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取最大计数值的信号量，这样能确保前面的 worker 都执行完
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sema</span>.<span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>ctx</span>, int64(<span style=color:#a6e22e>maxWorkers</span>)); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;获取所有的 worker 失败: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>task</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=原理>原理
<a class=anchor href=#%e5%8e%9f%e7%90%86>#</a></h3><p><code>Weighted</code> 是使用互斥锁和 List 实现的，信号量 <code>semaphore.Weighted</code> 的结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Weighted</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>size</span>    <span style=color:#66d9ef>int64</span>         <span style=color:#75715e>// 最大资源数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>cur</span>     <span style=color:#66d9ef>int64</span>         <span style=color:#75715e>// 当前已被使用的资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mu</span>      <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>    <span style=color:#75715e>// 互斥锁，保证并发安全 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>waiters</span> <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>List</span>     <span style=color:#75715e>// 等待者队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>List 实现了一个等待队列，等待者的通知是通过 channel 实现的。</p><p><code>Acquire</code> 实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Weighted</span>) <span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 剩余的资源大于 n，直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>size</span><span style=color:#f92672>-</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cur</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waiters</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 已被使用的资源 +n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cur</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 请求的资源数 n 大于最大的资源数 size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &gt; <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>size</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 依赖 ctx 的状态返回，否则会一直阻塞
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 走到这里，说明资源不足
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 把调用者加入到等待队列中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 创建一个 ready chan,以便被通知唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ready</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{})
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>waiter</span>{<span style=color:#a6e22e>n</span>: <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>ready</span>: <span style=color:#a6e22e>ready</span>}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 插入到队列尾部，elem 是新插入的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waiters</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>w</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 阻塞等待，直到 ctx 被取消或者超时，或者被唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>(): <span style=color:#75715e>// ctx 被取消或者超时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ready</span>: <span style=color:#75715e>// 被唤醒了，那么就忽略 ctx 的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>err</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>: 
</span></span><span style=display:flex><span>			<span style=color:#75715e>// s.waiters.Front() 取出队列的第一个 等待者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>isFront</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waiters</span>.<span style=color:#a6e22e>Front</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 直接移除当前 等待者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waiters</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 还有资源，通知其它的 等待者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isFront</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>size</span> &gt; <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cur</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>notifyWaiters</span>()
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ready</span>: <span style=color:#75715e>// 被唤醒了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Release</code> 的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Weighted</span>) <span style=color:#a6e22e>Release</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int64</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 已被使用的资源 -n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cur</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cur</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>        panic(<span style=color:#e6db74>&#34;semaphore: released more than held&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 唤醒等待队列中等待者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>notifyWaiters</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>notifyWaiters</code> 就是遍历等待队列中的等待者，如果资源不够，或者等待队列是空的，就返回：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Weighted</span>) <span style=color:#a6e22e>notifyWaiters</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waiters</span>.<span style=color:#a6e22e>Front</span>()
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 没有等待者了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span> <span style=color:#75715e>// No more waiters blocked.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#a6e22e>waiter</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 资源不足，退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// s.waiters.Front() 是以先入先出的方式取出等待者，如果第一个等待者没有足够的资源，那么队列中的所有等待者都会继续等待
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>size</span><span style=color:#f92672>-</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cur</span> &lt; <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>n</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 资源足够
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 已被使用的资源 +n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cur</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 将等待者移出队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waiters</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>next</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 关闭 channel，唤醒等待者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		close(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>ready</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/commit/8dd84e00e28127fae659507809861bef11ae174f title='Last modified by PengQi Shi | November 6, 2023' target=_blank rel=noopener><img src=/golang-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 6, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/golang-learn/edit/master/content/docs/concurrency/10_sema.md target=_blank rel=noopener><img src=/golang-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#信号量>信号量</a><ul><li><a href=#acquire-信号量>Acquire 信号量</a></li><li><a href=#release-信号量>Release 信号量</a></li><li><a href=#semaphore-扩展库>semaphore 扩展库</a><ul><li><a href=#使用>使用</a></li><li><a href=#原理>原理</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>