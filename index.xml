<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>主要内容 on Go Learning</title><link>https://shipengqi.github.io/golang-learn/</link><description>Recent content in 主要内容 on Go Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://shipengqi.github.io/golang-learn/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 编译</title><link>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/01_build/</guid><description>Go 编译 # 条件编译 # Go 支持两种条件编译方式：
编译标签（build tag） 文件后缀 编译标签 # 编译标签的规则：
空格表示：AND 逗号表示：OR ! 表示：NOT 换行表示：AND 每个条件项的名字用 &amp;ldquo;字母+数字&amp;rdquo; 表示。主要支持以下几种条件：
操作系统，例如：windows、linux 等，对应 runtime.GOOS 的值。 计算机架构，例如：amd64、386，对应 runtime.GOARCH 的值。 编译器，例如：gccgo、gc，是否开启 CGO,cgo。 Go 版本，例如：go1.19、go1.20 等。 自定义的标签，例如：编译时通过指定 -tags 传入的值。 //go:build ignore，编译时自动忽略该文件 go:build 之后必须有空行，否则会被编译器当做普通注释。
//go:build linux,386 darwin,!cgo package testpkg 运算表达式为：(linux &amp;amp;&amp;amp; 386) || (darwin &amp;amp;&amp;amp; !cgo)。
自定义 tag 只需要在 go build 指令后用 -tags 指定编译条件即可
go build -tags mytag1 mytag2 对于 -tags，多个标签既可以用逗号分隔，也可以用空格分隔，但它们都表示&amp;quot;与&amp;quot;的关系。早期 go 版本用空格分隔，后来改成了用逗号分隔，但空格依然可以识别。</description></item><item><title>互斥锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/01_mutex/</guid><description>互斥锁 # Go 的标准库 sync 提供了两种锁类型：sync.Mutex 和 sync.RWMutex，前者是互斥锁（排他锁），后者是读写锁。
互斥锁是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。
Go 定义的锁接口只有两个方法：
type Locker interface { Lock() // 请求锁 Unlock() // 释放锁 } 使用 # import &amp;#34;sync&amp;#34; var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() defer mu.Unlock() balance = balance + amount } func Balance() int { mu.Lock() defer mu.Unlock() b := balance return b } 当已经有 goroutine 调用 Lock 方法获得了这个锁，再有 goroutine 请求这个锁就会阻塞在 Lock 方法的调用上， 直到持有这个锁的 goroutine 调用 UnLock 释放这个锁。</description></item><item><title>内存管理</title><link>https://shipengqi.github.io/golang-learn/docs/advance/01_mm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/01_mm/</guid><description>内存管理 # 函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。
分配方法 # 内存分配器一般包含两种分配方法，一种是线性分配器（Sequential Allocator，Bump Allocator），另一种是空闲链表分配器（Free-List Allocator）
线性分配器 # 高效的内存分配方法，但是有较大的局限性。当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：
但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器是无法重新利用红色的这部分内存的：
需要合适的垃圾回收算法配合使用。标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。
空闲链表分配器 # 可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：
因为不同的内存块以链表的方式连接，所以使用这种方式分配内存的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度就是 O(n)。
可以选择不同的策略在链表中的内存块中进行选择，最常见的就是以下四种方式：
首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块； 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块； 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块； 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块； Go 语言使用的内存分配策略与第四种策略有些相似
如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，我们会在上图中的第二个链表找到空闲的内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。
分级分配 # 线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 malloc 函数还要快很多2。Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。
Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：
类别 大小 微对象 (0, 16B) 小对象 [16B, 32KB] 大对象 (32KB, +∞)
TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存：</description></item><item><title>基础据类型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/01_basic_type/</guid><description>数值类型 # 整型 # uint，无符号 32 或 64 位整型 uint8，无符号 8 位整型 (0 到 255) uint16，无符号 16 位整型 (0 到 65535) uint32，无符号 32 位整型 (0 到 4294967295) uint64，无符号 64 位整型 (0 到 18446744073709551615) int，有符号 32 或 64 位整型 int8，有符号 8 位整型 (-128 到 127) int16，有符号 16 位整型 (-32768 到 32767) int32，有符号 32 位整型 (-2147483648 到 2147483647) int64，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) int 和 uint 对应的是 CPU 平台机器的字大小。
浮点数 # float32 和 float64 的算术规范由 IEEE-754 浮点数国际标准定义。</description></item><item><title>Go 数据竞争检测器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/02_go_race/</guid><description>Go 数据竞争检测器 # 数据竞争是并发系统中最常见，同时也最难处理的 Bug 类型之一。数据竞争会在两个 goroutine 并发访问同一个变量，且至少有一个访问为写入时产生。
这个数据竞争的例子可导致程序崩溃和内存数据损坏（memory corruption）。
package main import &amp;#34;fmt&amp;#34; func main() { c := make(chan bool) m := make(map[string]string) go func() { m[&amp;#34;1&amp;#34;] = &amp;#34;a&amp;#34; // 第一个冲突的访问 c &amp;lt;- true }() m[&amp;#34;2&amp;#34;] = &amp;#34;b&amp;#34; // 第二个冲突的访问 &amp;lt;-c for k, v := range m { fmt.Println(k, v) } } 运行 go run -race ./main.go 或者 go build -race ./main.go 编译后再运行会抛出类似的错误：
================== WARNING: DATA RACE Write at 0x00c00010a090 by goroutine 7: runtime.</description></item><item><title>垃圾回收</title><link>https://shipengqi.github.io/golang-learn/docs/advance/02_gc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/02_gc/</guid><description>Go 语言中使用的垃圾回收使用的是标记清扫算法。标记清理最典型的做法是三⾊标记。进行垃圾回收时会 STW(stop the world）， 就是 runtime 把所有的线程全部冻结掉，意味着⽤户逻辑都是暂停的，所有的⽤户对象都不会被修改了，这时候去扫描肯定是安全的， 对象要么活着要么死着，所以会造成中间暂停时间可能会很⻓，⽤户逻辑对于⽤户的反应就中⽌了。
Go GC 的基本特征：非分代，非紧缩，写屏障，并发标记清理。
三色标记和写屏障 # 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收； 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象； 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；
三色标记算法原理如下：
起初所有对象都是白色。 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。 重复 3，直到灰色对象队列为空。 扫描和标记完成后，只剩下白色（待回收）和黑色（活跃对象）的对象，清理操作将白色对象内存回收。
在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。
因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW。在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。
本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性
屏障技术 # 想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：
强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象； 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径 遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性。而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。
垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。
增量和并发 # 增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间
增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序对内存的修改都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只有优点的。
并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响
虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。
何时触发 GC # 垃圾回收器在初始化时，设置 gcpercent 和 next_gc 阈值。</description></item><item><title>数组</title><link>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/02_array/</guid><description> 数组 # 数组是一个由固定长度，相同类型的元素组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，并且可以利用索引快速访问数组中的元素。
初始化 # arr1 := [3]int{1, 2, 3} arr2 := [...]int{1, 2, 3} // `...` 省略号，表示数组的长度是根据初始化值的个数来计算 数组的长度在编译阶段确定，初始化之后大小就无法改变。
数组是否应该在堆栈中初始化在编译期就确定了。
根据数组大小：
当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上。 当元素数量大于 4 个时，会将数组中的元素放置到静态区，并在运行时取出。</description></item><item><title>读写锁</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/02_rwmutex/</guid><description>读写锁 # 读写互斥锁 sync.RWMutex 是细粒度的互斥锁，一般来说有几种情况：
读锁之间不互斥 写锁之间是互斥的 写锁与读锁是互斥的 sync.RWMutex 类型中的 Lock 方法和 Unlock 方法用于对写锁进行锁定和解锁，RLock 方法和 RUnlock 方法则分别用于对读锁进行锁定和解锁。
原理 # type RWMutex struct { w Mutex // 复用互斥锁提供的能力，解决多个 writer 的竞争 writerSem uint32 // writer 的信号量 readerSem uint32 // reader 的信号量 readerCount atomic.Int32 // 正在执行的 reader 的数量 readerWait atomic.Int32 // 当写操作被阻塞时需要等待 read 完成的 reader 的数量 } const rwmutexMaxReaders = 1 &amp;lt;&amp;lt; 30 rwmutexMaxReaders：定义了最大的 reader 数量。
RLock 和 RUnlock # 移除了 race 等无关紧要的代码：</description></item><item><title>Go 测试</title><link>https://shipengqi.github.io/golang-learn/docs/practice/03_test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/03_test/</guid><description>Go 测试 # go test 命令测试代码，包目录内，所有以 _test.go 为后缀名的源文件在执行 go build 时不会被构建成包的一部分， 它们是 go test 测试的一部分。
在 *_test.go 文件中，有三种类型的函数：
测试函数，测试程序的一些逻辑行为是否正确。go test 命令会调用这些测试函数并报告测试结果是 PASS 或 FAIL。 基准测试函数，衡量一些函数的性能。go test 命令会多次运行基准函数以计算一个平均的执行时间。 示例函数，提供一个由编译器保证正确性的示例文档。 go test 会生成一个临时 main 包调用测试函数。 参数
-v，打印每个测试函数的名字和运行时间。 -run，指定一个正则表达式，只有匹配到的测试函数名才会被 go test 运行，如 go test -v -run=&amp;quot;French|Canal&amp;quot;。 -cover，测试覆盖率。 -bench，运行基准测试。例如 go test -bench=.（如果在 Windows Powershell 环境下使用 go test -bench=&amp;quot;.&amp;quot;） -c，生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为 pkg.test，其中的 pkg 即为被测试代码包的 导入路径的最后一个元素的名称。 -i，安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。 -o，指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记 -c 或 -i。 测试函数 # 测试函数必须导入 testing 包，并以 Test 为函数名前缀，后缀名必须以大写字母开头，并且参数列表中只应有一个 *testing.</description></item><item><title>WaitGroup</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/03_waitgroup/</guid><description>WaitGroup # sync.WaitGroup 可以等待一组 goroutine 的返回，常用于处理批量的并发任务。它是并发安全的。
使用 # 并发发送 HTTP 请求的示例：
requests := []*Request{...} wg := &amp;amp;sync.WaitGroup{} wg.Add(len(requests)) for _, request := range requests { go func(r *Request) { defer wg.Done() // res, err := service.call(r) }(request) } wg.Wait() WaitGroup 提供了三个方法：
Add：用来设置 WaitGroup 的计数值。 Done：用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。 Wait：调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。 不要把 Add 和 Wait 方法的调用放在不同的 goroutine 中执行，以免 Add 还未执行，Wait 已经退出：
var wg sync.WaitGroup go func(){ wg.</description></item><item><title>切片</title><link>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/03_slice/</guid><description>切片 # 切片 (slice) 在使用上和数组差不多，区别是切片是可变长的，定义的时候不需要指定 size。
切片可以看做是对数组的一层简单的封装，切片的底层数据结构中，包含了一个数组。
切片的结构体：
// src/reflect/value.go type SliceHeader struct { Data uintptr // 指向底层数组 Len int // 当前切片长度 Cap int // 当前切片容量 } 注意 Cap 也是底层数组的长度。Data 是一块连续的内存，可以存储切片 Cap 大小的所有元素。
如图，虽然 slice 的 Len 是 5，但是底层数组的长度是 10，也就是 Cap。
初始化 # 初始化切片有三种方式：
使用 make // len 是切片的初始长度 // capacity 为可选参数, 指定容量 s := make([]int, len, capacity) 使用字面量 arr :=[]int{1,2,3} 使用下标截取数组或者切片的一部分，这里可以传入三个参数 [low:high:max]，max - low 是新的切片的容量 cap。 numbers := []int{0,1,2,3,4,5,6,7,8} s := numbers[1:4] // [1 2 3] s := numbers[4:] // [4 5 6 7 8] s := numbers[:3]) // [0 1 2] 《Go 学习笔记》 第四版 中的示例：</description></item><item><title>调度器</title><link>https://shipengqi.github.io/golang-learn/docs/advance/03_scheduler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/03_scheduler/</guid><description>调度器 # type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</description></item><item><title>Go 性能分析</title><link>https://shipengqi.github.io/golang-learn/docs/practice/04_pprof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/04_pprof/</guid><description>Go 性能分析 # PProf 是 Go 提供的用于可视化和分析性能分析数据的工具。
runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析 主要可以用于：
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期 时花费时间的位置。 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置。 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况。 性能分析 # 分析 HTTP Server # Web # import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; ) var datas []string func Add(str string) string { data := []byte(str) sData := string(data) datas = append(datas, sData) return sData } func main() { go func() { for { log.</description></item><item><title>map</title><link>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/04_map/</guid><description>map # map 是一个无序的 key/value 对的集合。map 是引用类型。这意味着它拥有对底层数据结构的引用， 就像指针一样。它底层的数据结构是 hash table 或 hash map。
map 作为引用类型是非常好的，因为无论 map 有多大，都只会有一个副本。
定义 map，使用 map 关键字：
/* 声明变量，默认 map 是 nil */ var 变量名 map[键类型]值类型 /* 使用 make 函数 */ 变量名 := make(map[键类型]值类型) /* 字面值的语法创建 */ 变量名 := map[键类型]值类型{ key1: value1, key2: value2, ... } 一个 map 在未初始化之前默认为 nil。 通过索引下标 key 来访问 map 中对应的 value
age, ok := ages[&amp;#34;bob&amp;#34;] if !ok { /* &amp;#34;bob&amp;#34; is not a key in this map; age == 0.</description></item><item><title>条件变量</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/04_cond/</guid><description>条件变量 # Go 标准库提供了条件变量 sync.Cond 它可以让一组的 goroutine 都在满足特定条件时被唤醒。
sync.Cond 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 for {} 进行忙碌等待相比，sync.Cond 能够让出处理器的使用权，提高 CPU 的利用率。
sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么？
互斥锁 sync.Mutex 通常用来保护临界区和共享资源，条件变量 sync.Cond 用来协调想要访问共享资源的 goroutine。
sync.Cond 经常用在多个 goroutine 等待，一个 goroutine 通知的场景。
比如有一个 goroutine 在异步地接收数据，剩下的多个 goroutine 必须等待这个协程接收完数据，才能读取到正确的数据。这个时候，就需要有个全局的变量来标志第一 个 goroutine 数据是否接受完毕，剩下的 goroutine，反复检查该变量的值，直到满足要求。
当然也可以创建多个 channel，每个 goroutine 阻塞在一个 channel 上，由接收数据的 goroutine 在数据接收完毕后，逐个通知。但是这种方式更复杂一点。
使用 # NewCond 用来创建 sync.Cond 实例，sync.Cond 暴露了几个方法：
Broadcast 用来唤醒所有等待条件变量的 goroutine，无需锁保护。 Signal 唤醒一个 goroutine。 Wait 调用 Wait 会自动释放锁，并挂起调用者所在的 goroutine，也就是当前 goroutine 会阻塞在 Wait 方法调用的地方。如果其他 goroutine 调用了 Signal 或 Broadcast 唤醒 了该 goroutine，那么 Wait 方法在结束阻塞时，会重新加锁，并且继续执行 Wait 后面的代码。 var status int64 func main() { c := sync.</description></item><item><title>网络轮询器</title><link>https://shipengqi.github.io/golang-learn/docs/advance/04_netpooler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/advance/04_netpooler/</guid><description>网络轮询器 # epoll
https://segmentfault.com/a/1190000003063859</description></item><item><title>Go 性能优化</title><link>https://shipengqi.github.io/golang-learn/docs/practice/05_performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/05_performance/</guid><description>Go 性能优化 # JSON 优化 # Go 官方的 encoding/json 是通过反射来实现的。性能相对有些慢。 可以使用第三方库来替代标准库：
json-iterator/go，完全兼容标准库，性能有很大提升。 go-json，完全兼容标准库，性能强于 json-iterator/go。 sonic，字节开发的的 JSON 序列化/反序列化库，速度快，但是对硬件有一些要求。 实际开发中可以根据编译标签来选择 JSON 库，参考 component-base/json。
使用空结构体 # 在 Go 中空结构体 struct{} 不占据内存空间：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { fmt.Println(unsafe.Sizeof(struct{}{})) // 0 } 空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用，可以节省资源。
集合 Set # 要实现一个 Set，通常会使用 map 来实现，比如 map[string]bool。 但是对于集合来说， 只需要 map 的键，而不需要值。将值设置为 bool 类型，就会多占据 1 个字节。这个时候就可以使用空结构体 map[string]struct{}。
channel 通知 # 有时候使用 channel 不需要发送任何的数据，只用来通知 goroutine 执行任务，或结束等。这个时候就可以使用空结构体。
内存对齐 # 为什么需要内存对齐？ # CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如：</description></item><item><title>Once</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/05_once/</guid><description>Once # Go 标准库中 sync.Once 可以保证 Go 程序运行期间的某段代码只会执行一次。常常用于单例对象的初始化场景。
使用 # sync.Once 只有一个对外唯一暴露的方法 Do，可以多次调用，但是只第一次调用时会执行一次。
func main() { o := &amp;amp;sync.Once{} for i := 0; i &amp;lt; 10; i++ { o.Do(func() { fmt.Println(&amp;#34;only once&amp;#34;) }) } } 运行：
$ go run main.go only once 利用 channel 实现 Once # 下面的代码也可以达到执行一次的效果，不过重复执行会导致 panic：
var setonce chan struct{} func initialize() { // channel 不可以重复关闭，否则会 panic close(a.setonce) // 初始化 // ... } 原理 # sync.Once 的实现：</description></item><item><title>函数</title><link>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/05_function/</guid><description>函数 # 参数传递 # Go 使用的是值传递，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型， 区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。 但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
注意，如果实参是 slice、map、function、channel 等类型（引用类型），实参可能会由于函数的间接引用被修改。
没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。
表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和 垃圾回收的成本。在栈上复制小对象，要比堆上分配内存要快的多。如果复制成本高，或者需要修改原对象，使用指针更好。
可变参数 # 变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个。比如 fmt.Printf，Printf 接收一个的必备参数，之 后接收任意个数的后续参数。
在参数列表的最后一个参数类型之前加上省略符号 ...，表示该函数会接收任意数量的该类型参数。
func sum(vals ...int) int { total := 0 for _, val := range vals { total += val } return total } // 调用 fmt.Println(sum()) // &amp;#34;0&amp;#34; fmt.Println(sum(3)) // &amp;#34;3&amp;#34; fmt.Println(sum(1, 2, 3, 4)) // &amp;#34;10&amp;#34; // 还可以使用类似 ES6 的解构赋值的语法 values := []int{1, 2, 3, 4} fmt.</description></item><item><title>Go Trace</title><link>https://shipengqi.github.io/golang-learn/docs/practice/06_trace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/06_trace/</guid><description>Go Trace # Go PProf 很难完成 Goroutine 的分析。这就需要使用 go tool trace 命令。
go tool pprof 可以跟踪运行缓慢的函数，或者找到大部分 CPU 时间花费在哪里。 go tool trace 更适合于找出程序在一段时间内正在做什么，而不是总体上的开销。
package main import ( &amp;#34;os&amp;#34; &amp;#34;runtime/trace&amp;#34; ) func main() { f, err := os.Create(&amp;#34;trace.out&amp;#34;) if err != nil { panic(err) } defer f.Close() err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() ch := make(chan string) go func() { ch &amp;lt;- &amp;#34;hello&amp;#34; }() // read from channel &amp;lt;-ch } 生成跟踪文件：</description></item><item><title>Pool</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/06_pool/</guid><description>Pool # Go 从 1.3 版本开始提供了对象重用的机制，即 sync.Pool。sync.Pool 用来保存可以被重复使用的临时对象，避免了重复创建和销毁临时对象带来的消耗，降低 GC 压力，提高性能。
sync.Pool 是可伸缩的，也是并发安全的。可以在多个 goroutine 中并发调用 sync.Pool 存取对象。
使用 # var buffers = sync.Pool{ New: func() interface{} { return new(bytes.Buffer) }, } func GetBuffer() *bytes.Buffer { return buffers.Get().(*bytes.Buffer) } func PutBuffer(buf *bytes.Buffer) { buf.Reset() buffers.Put(buf) } New：类型是 func() interface{}，用来创建新的元素。 Get：从 Pool 中取出一个元素，如果没有更多的空闲元素，就调用 New 创建新的元素。如果没有设置 New 那么可能返回 nil。 Put：将一个元素放回 Pool 中，使该元素可以重复使用，如果 Put 的值是 nil，会被忽略。
可以先 Put，再 Get 么？ # 不可以。
type item struct { value int } func main() { pool := sync.</description></item><item><title>接口</title><link>https://shipengqi.github.io/golang-learn/docs/basic/06_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/06_interface/</guid><description>接口 # Go 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实 现了这个接口，无须显示声明。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。
一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。
接口的零值就是它的类型和值的部分都是 nil。
简单的说，interface 是一组 method 的组合，我们通过 interface 来定义对象的一组行为。
定义接口：
type 接口名 interface { 方法名1 [返回类型] 方法名2 [返回类型] 方法名3 [返回类型] ... } /* 定义结构体 */ type struct_name struct { /* variables */ } /* 实现接口方法 */ func (struct_name_variable struct_name) 方法名1() [返回类型] { /* 方法实现 */ } ... func (struct_name_variable struct_name) 方法名2() [返回类型] { /* 方法实现*/ } 实例：
type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.</description></item><item><title>Context</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/07_context/</guid><description>Context # Go 1.7 版本中正式引入新标准库 context。主要的作用是在在一组 goroutine 之间传递共享的值、取消信号、deadline 等。
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline — 返回当前 context 的截止时间。 Done — 返回一个只读的 channel，可用于识别当前 channel 是否已经被关闭，其原因可能是到期，也可能是被取消了。多次调用 Done 方法会返回同一个 channel。 Err — 返回当前 context 被关闭的原因。 如果 context 被取消，会返回 Canceled 错误。 如果 context 超时，会返回 DeadlineExceeded 错误。 Value — 返回当前 context 对应所存储的 context信息，可以用来传递请求特定的数据。 创建 context：
Background：创建一个空的 context，一般用在主函数、初始化、测试以及创建 root context 的时候。 TODO：创建一个空的 context，不知道要传递一些什么上下文信息的时候，就用这个。 WithCancel：基于 parent context 创建一个可以取消的新 context。 WithTimeout：基于 parent context 创建一个具有超时时间的新 context。 WithDeadline：和 WithTimeout 一样，只不过参数是截止时间（超时时间加上当前时间）。 WithValue：基于某个 context 创建并存储对应的上下文信息。 最常用的场景，使用 context 来取消一个 goroutine 的运行：</description></item><item><title>Go CoreDump 调试</title><link>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/07_coredump/</guid><description>Go CoreDump 调试 # Go 也可以开启类似 C++ CoreDump 功能，CoreDump 是异常退出程序的内存快照。程序崩溃时，可以帮助定位 crash 发生的原因。
如何生成 CoreDump 文件 # GOTRACEBACK 可以控制程序崩溃时输出的详细程度。 可选的值：
none 不显示任何 goroutine 栈 trace。 single, 默认选项，显示当前 goroutine 栈 trace。 all 显示所有用户创建的 goroutine 栈 trace。 system 显示所有 goroutine 栈 trace,甚至运行时的 trace。 crash 类似 system, 而且还会生成 core dump。 可以设置 export GOTRACEBACK=crash 来生成 core dump。
编译时要确保使用编译器标志 -N 和 -l 来构建二进制文件,它会禁用编译器优化，编译器优化可能会使调试更加困难。
$ go build -gcflags=all=&amp;#34;-N -l&amp;#34; 如果 coredump 没有生成，可能是 coredump size 配置为 0，如下命令将 coredump 配置为 1MB 大小：</description></item><item><title>反射</title><link>https://shipengqi.github.io/golang-learn/docs/basic/07_reflect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/07_reflect/</guid><description>反射 # 反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道 这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。
reflect.TypeOf # reflect.TypeOf 获取类型信息。 reflect.TypeOf 接受任意的 interface{} 类型, 并以 reflect.Type 形式返回其动态类型：
t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; type X int func main() { var a X = 20 t := reflect.TypeOf(a) fmt.Println(t.Name(), t.Kind()) // X int } 上面的代码，注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型。所以在判断类型时， 要选择正确的方式。
type X int type Y int func main() { var a, b X = 10, 20 var c Y = 30 ta, tb, tc := reflect.</description></item><item><title>Go Modules</title><link>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/08_mod/</guid><description>Go Modules # Golang 在 1.11 推出了 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，解决了 GOPATH 的问题，相当于弃用了 GOPATH。
Go Module 机制 # Go Module 不同于基于 GOPATH 和 Vendor 的项目构建，其主要是通过 $GOPATH/pkg/mod 下缓存的模块来对项目进行构建。 同一个模块版本的数据只缓存一份，所有其他模块共享使用。
可以使用 go clean -modcache 清理所有已缓存的模块版本数据。
GO111MODULE # Go Module 目前是可选的，可以通过环境变量 GO111MODULE 来控制是否启用，GO111MODULE 有三种类型:
on 所有的构建，都使用 Module 机制 off 所有的构建，都不使用 Module 机制，而是使用 GOPATH 和 Vendor auto 在 GOPATH 下的项目，不使用 Module 机制，不在 GOPATH 下的项目使用 GOPROXY # GOPROXY 用于设置 Go Module 代理。使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它的值是一个以 , 分割的 Go module proxy 列表。Golang 1.</description></item><item><title>原子操作</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/08_atomic/</guid><description>原子操作 # 原子操作就是执行过程中不能被中断的操作。
Go 的标准库 sync/atomic 提供了一些实现原子操作的方法：
Add CompareAndSwap（简称 CAS） Load Swap Store 这些函数针对的数据类型有：
int32 int64 uint32 uint64 uintptr unsafe 包中的 Pointer 以 Add 为例，上面类型对应的原子操作函数为：
func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) unsafe.Pointer 类型，并未提供进行原子加法操作的函数。
sync/atomic 包还提供了一个名为 Value 的类型，它可以被用来存储（Store）和加载（Load）任意类型的值。
它只有两个指针方法：
Store Load。 尽量不要向原子值中存储引用类型的值。</description></item><item><title>泛型</title><link>https://shipengqi.github.io/golang-learn/docs/basic/08_generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/08_generic/</guid><description> 泛型 #</description></item><item><title>Channel</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/09_channel/</guid><description>Channel # Don’t communicate by sharing memory; share memory by communicating. 不要通过共享内存来通信，通过通信来共享内存。 这是 Go 语言最重要的编程理念。goroutine 通过 channel 向另一个 goroutine 发送消息，channel 和 goroutine 结合，可以实现用通信代替共享内存的 CSP （Communicating Sequential Process）模型。
使用 # 创建 channel：
// 无缓冲 channel ch := make(chan int) // 带缓冲 channel，缓冲区为 3 ch = make(chan int, 3) channel 的零值是 nil。
无缓冲 channel # 无缓冲 channel 也叫做同步 channel：
一个 goroutine 基于一个无缓冲 channel 发送数据，那么就会阻塞，直到另一个 goroutine 在相同的 channel 上执行接收操作。 一个 goroutine 基于一个无缓冲 channel 先执行了接收操作，也会阻塞，直到另一个 goroutine 在相同的 channel 上执行发送操作 带缓冲 channel # 带缓冲的 channel 有一个缓冲区：</description></item><item><title>Gin 静态服务器</title><link>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/09_gin/</guid><description>Gin 如何实现前端网页的静态服务器 # Gin 作为 Web 框架提供 API 接口非常方便，但是在同一个项目中，既提供 API 接口，又要作为前端网页的静态服务器，就比较麻烦。通常 Angular (React/Vue) 项目需要在 Nginx 或者 Tomcat 转发才可以。有些小项目并不需要前后端分离，如何解决？
利用 embed 标签 # Go 的 1.16 版本增加了 embed 的标签，可以利用这个标签将静态资源打包到二进制文件中。
. ├── config ├── controller ├── model ├── options ├── pkg │ └── response │ └── response.go ├── resources │ ├── dist │ └── html.go ├── html.go ├── resource.go ├── router.go ├── server.go └── store ├── audited.go ├── groups.go ├── mysql.go ├── settings.</description></item><item><title>指针</title><link>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/09_pointer/</guid><description>指针 # 指针和内存地址不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个 保存内存地址的整形变量。
x := 1 p := &amp;amp;x // p, of type *int, points to x fmt.Println(*p) // &amp;#34;1&amp;#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &amp;#34;2&amp;#34; 上面的代码，初始化一个变量 x，&amp;amp; 是取地址操作，&amp;amp;x 就是取变量 x 的内存地址，那么 p 就是一个指针， 类型是 *int，p 这个指针保存了变量 x 的内存地址。接下来 *p 表示读取指针指向的变量的值，也就是变量 x 的值 1。 *p也可以被赋值。
任何类型的指针的零值都是 nil。当指针指向同一个变量或者 nil 时是相等的。 当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。
指向指针的指针 # var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;amp;a /* 指向指针 ptr 地址 */ pptr = &amp;amp;ptr /* 获取 pptr 的值 */ fmt.</description></item><item><title>Go 远程开发调试</title><link>https://shipengqi.github.io/golang-learn/docs/practice/10_remote_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/10_remote_dev/</guid><description> Go 远程开发调试 #</description></item><item><title>range</title><link>https://shipengqi.github.io/golang-learn/docs/basic/10_range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/10_range/</guid><description>range # 带有 range 子句的 for 语句会先把被遍历的字符串值拆成一个字节序列（注意是字节序列），然后再试图找出这个字节序列中 包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。
这样的 for 语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码 值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 rune。
str := &amp;#34;Go 爱好者 &amp;#34; for i, c := range str { fmt.Printf(&amp;#34;%d: %q [% x]\n&amp;#34;, i, c, []byte(string(c))) } 完整的打印内容如下：
0: &amp;#39;G&amp;#39; [47] 1: &amp;#39;o&amp;#39; [6f] 2: &amp;#39;爱&amp;#39; [e7 88 b1] 5: &amp;#39;好&amp;#39; [e5 a5 bd] 8: &amp;#39;者&amp;#39; [e8 80 85] 注意了，&amp;lsquo;爱&amp;rsquo;是由三个字节共同表达的，所以第四个 Unicode 字符&amp;rsquo;好&amp;rsquo;对应的索引值并不是 3，而是 2 加 3 后得到的 5。</description></item><item><title>信号量</title><link>https://shipengqi.github.io/golang-learn/docs/concurrency/10_sema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/concurrency/10_sema/</guid><description>信号量 # 信号量（Semaphore）是一种用于实现多进程或多线程之间同步和互斥的机制。
信号量可以简单理解为一个整型数，包含两种操作：P（Proberen，测试）操作和 V（Verhogen，增加）操作。其中，P 操作会尝试获取一个信号量，如果信号量的值大于 0，则将信号量的值减 1 并 继续执行。否则，当前进程或线程就会被阻塞，直到有其他进程或线程释放这个信号量为止。V 操作则是释放一个信号量，将信号量的值加 1。
P 操作和 V 操作可以看做是对资源的获取和释放。
Go 的 WaitGroup 和 Metux 都是通过信号量来控制 goroutine 的阻塞和唤醒，例如 Mutex 结构体中的 sema：
type Mutex struct { state int32 sema uint32 } Metux 本质上就是基于信号量（sema）+ 原子操作来实现并发控制的。
Go 操作信号量的方法：
// src/sync/runtime.go // 阻塞等待直到 s 大于 0，然后立刻将 s 减去 1 func runtime_Semacquire(s *uint32) // 类似于 runtime_Semacquire // 如果 lifo 为 true，waiter 将会被插入到队列的头部，否则插入到队列尾部 // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int) // 将 s 增加 1，然后通知阻塞在 runtime_Semacquire 的 goroutine // 如果 handoff 为 true，传递信号到队列头部的 waiter // skipframes 是跟踪过程中要省略的帧数，从这里开始计算 func runtime_Semrelease(s *uint32, handoff bool, skipframes int) Acquire 和 Release 分别对应了 P 操作和 V 操作。</description></item><item><title>Go 常见错误</title><link>https://shipengqi.github.io/golang-learn/docs/practice/11_errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/practice/11_errors/</guid><description>Go 常见错误 # go mod tidy error message: &amp;ldquo;but go 1.16 would select&amp;rdquo; # $ go mod tidy github.com/shipengqi/crtctl/internal/secret-writer imports github.com/shipengqi/kube imports k8s.io/client-go/kubernetes imports k8s.io/client-go/kubernetes/typed/admissionregistration/v1 imports k8s.io/client-go/applyconfigurations/admissionregistration/v1 imports k8s.io/apimachinery/pkg/util/managedfields imports k8s.io/kube-openapi/pkg/util/proto tested by k8s.io/kube-openapi/pkg/util/proto.test imports github.com/onsi/ginkgo imports github.com/onsi/ginkgo/internal/remote imports github.com/nxadm/tail imports github.com/nxadm/tail/winfile loaded from github.com/nxadm/tail@v1.4.4, but go 1.16 would select v1.4.8 To upgrade to the versions selected by go 1.16: go mod tidy -go=1.16 &amp;amp;&amp;amp; go mod tidy -go=1.17 If reproducibility with go 1.</description></item><item><title>select</title><link>https://shipengqi.github.io/golang-learn/docs/basic/11_select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/11_select/</guid><description>select # select 类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。
当条件满足时，select 会去通信并执行 case 之后的语句，这时候其它通信是不会执行的。 如果多个 case 同时满足条件，select 会随机地选择一个执行。如果没有 case 可运行，它将阻塞，直到有 case 可运行。
一个默认的子句应该总是可运行的。
select { case communication clause: ... case communication clause: ... default: /* 可选 */ ... } for range 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。for range 会复制目标数据。可改用数组指针或者切片。
range 关键字右边的位置上的代码被称为 range 表达式。
range 表达式只会在 for 语句开始执行时被求值一次，无论后边会有多少次迭代； range 表达式的求值结果会被复制，也就是说，被迭代的对象是 range 表达式结果值的副本而不是原值。 for range 在性能比 for 稍差，因为 for range 会进行值拷贝。 字符串的复制成本很小，切片，字典，通道等引用类型本身是指针的封装，复制成本也很小，无序专门优化。
如果 range 的目标表达式是函数，也只会运行一次。
numbers1 := []int{1, 2, 3, 4, 5, 6} for i := range numbers1 { if i == 3 { numbers1[i] |= i } } fmt.</description></item><item><title>defer</title><link>https://shipengqi.github.io/golang-learn/docs/basic/12_defer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/12_defer/</guid><description>defer # 堆上分配 # 编译器不仅将 defer 关键字都转换成 runtime.deferproc 函数，它还会通过以下三个步骤为所有调用 defer 的函数末尾插入 runtime.deferreturn 的函数调用
runtime.deferproc 负责创建新的延迟调用； runtime.deferreturn 负责在函数调用结束时执行所有的延迟调用；
runtime.deferproc 会为 defer 创建一个新的 runtime._defer 结构体、设置它的函数指针 fn、程序计数器 pc 和栈指针 sp 并将相关的参数拷贝到相邻的内存空间中：
func deferproc(siz int32, fn *funcval) { sp := getcallersp() argp := uintptr(unsafe.Pointer(&amp;amp;fn)) + unsafe.Sizeof(fn) callerpc := getcallerpc() d := newdefer(siz) if d._panic != nil { throw(&amp;#34;deferproc: d.panic != nil after newdefer&amp;#34;) } d.fn = fn d.pc = callerpc d.sp = sp switch siz { case 0: case sys.</description></item><item><title>panic</title><link>https://shipengqi.github.io/golang-learn/docs/basic/13_panic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/13_panic/</guid><description>panic # Panic 异常 # Go 运行时错误会引起 painc 异常。 一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（defer 机制）。随后，程序崩溃 并输出日志信息。
由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使 用 Go 提供的错误机制，而不是 panic，尽量避免程序的崩溃。
panic 函数 # panic 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 panic。
panic 详情中都有什么 # panic: runtime error: index out of range goroutine 1 [running]: main.main() /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d exit status 2 第一行是 panic: runtime error: index out of range。其中的 runtime error 的含义是，这是一个 runtime 代码包中 抛出的 panic。
goroutine 1 [running]，它表示有一个 ID 为1的 goroutine 在此 panic 被引发的时候正在运行。这里的 ID 其实并不重要。</description></item><item><title>make 和 new</title><link>https://shipengqi.github.io/golang-learn/docs/basic/14_make_new/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/14_make_new/</guid><description> make 和 new #</description></item><item><title>面向对象</title><link>https://shipengqi.github.io/golang-learn/docs/basic/15_oop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/golang-learn/docs/basic/15_oop/</guid><description>面向对象 # GO 支持面向对象编程。
方法 # 方法声明：
func (变量名 类型) 方法名() [返回类型]{ /* 函数体*/ } 实例：
/* 定义结构体 */ type Circle struct { radius float64 } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&amp;#34;Area of Circle(c1) = &amp;#34;, c1.getArea()) } // 该 method 属于 Circle 类型对象中的方法 // 这里的 c 叫作方法的接收器，类似 Javascript 的 this func (c Circle) getArea() float64 { // c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.</description></item></channel></rss>