<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>常用标准库 on Golang Learning</title>
    <link>http://shipengqi.github.io/golang-learn/docs/standards/</link>
    <description>Recent content in 常用标准库 on Golang Learning</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="http://shipengqi.github.io/golang-learn/docs/standards/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/unsafe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/unsafe/</guid>
      <description>Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。
限制一：Go的指针不能进行数学运算。
a := 5 p := &amp;amp;a p++ p = &amp;amp;a + 3 上面的代码将不能通过编译，会报编译错误：invalid operation，也就是说不能对指针做数学运算。
限制二：不同类型的指针不能相互转换。
func main() { a :=int(100) var f *float64 f = &amp;amp;a } 也会报编译错误：cannot use &amp;amp;a (type *int) as type *float64 in assignment
限制三：不同类型的指针不能使用==或!=比较。
只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 == 和 != 直接和 nil 作比较。
限制四：不同类型的指针变量不能相互赋值。
这一点同限制三。
unsafe#Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。
unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。
它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。
Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。</description>
    </item>
    
    <item>
      <title>log</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/log/</guid>
      <description>log#log 模块用于在程序中输出日志。
package main import &amp;#34;log&amp;#34; func main() { log.Print(&amp;#34;Hello World&amp;#34;) // 2019/09/12 13:56:36 Hello World } Logger#通过 New 函数可以创建多个 Logger 实例，函数声明如下：
func New(out io.Writer, prefix string, flag int) *Logger 参数：
out：日志输出的 IO 对象，通常是标准输出 os.Stdout，os.Stderr，或者绑定到文件的 IO。 prefix：日志前缀，可以是任意字符串。 flag：日志包含的通用信息标识位 一条日志的结构：
{日志前缀} {标识1} {标识2} ... {标识n} {日志内容} 标识通过 flag 参数设置，当某个标识被设置，会在日志中进行显示，log 模块中已经提供了如下标识，多个标识通过 | 组合：
Ldate 显示当前日期（当前时区） Ltime 显示当前时间（当前时区） microseconds 显示当前时间（微秒） Llongfile 包含路径的完整文件名 Lshortfile 不包含路径的文件名 LUTC Ldata 和 Ltime 使用 UTC 时间 LstdFlags 标准 Logger 的标识，等价于 Ldate | Ltime package main import ( &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) func main() { prefix := &amp;#34;[THIS IS THE LOG]&amp;#34; logger := log.</description>
    </item>
    
    <item>
      <title>time</title>
      <link>http://shipengqi.github.io/golang-learn/docs/standards/time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shipengqi.github.io/golang-learn/docs/standards/time/</guid>
      <description>time#time 提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数，比如：
time.Now() 获取当前时间。 t.Day()、t.Minute() 获取时间的一部分。 time.After、time.Ticker 在经过一定时间或周期执行某项任务（事件处理的特例）。 time.Sleep（Duration d） 暂停某个进程（ goroutine），暂停时长为 d。 Duration 代表两个时间点之间经过的时间，以纳秒为单位，类型为 int64。 Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。 时区#Go 语言使用 Location 来表示地区相关的时区，一个 Location 可能表示多个时区。
time 包提供了 Location 的两个实例：
Local 代表当前系统本地时区； UTC 代表通用协调时间，也就是零时区。time 包默认（为显示提供时区）使用 UTC 时区。 Local 是如何做到表示本地时区的？#在初始化 Local 时，通过读取 /etc/localtime （这是一个符号链接，指向 /usr/share/zoneinfo 中某一个时区）可以获取到系统本地时区。
如果设置了环境变量 TZ，则会优先使用它。
tz, ok := syscall.Getenv(&amp;#34;TZ&amp;#34;) switch { case !ok: z, err := loadZoneFile(&amp;#34;&amp;#34;, &amp;#34;/etc/localtime&amp;#34;) if err == nil { localLoc = *z localLoc.</description>
    </item>
    
  </channel>
</rss>
